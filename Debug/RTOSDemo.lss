
RTOSDemo.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000af98  00400000  00400000  00010000  2**6
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  0040af98  0040af98  0001af98  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     000008ac  20400000  0040afa0  00020000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          0000bc14  204008ac  0040b84c  000208ac  2**2
                  ALLOC
  4 .stack        00002000  2040c4c0  00417460  000208ac  2**0
                  ALLOC
  5 .heap         00001000  2040e4c0  00419460  000208ac  2**0
                  ALLOC
  6 .ARM.attributes 0000002e  00000000  00000000  000208ac  2**0
                  CONTENTS, READONLY
  7 .comment      00000059  00000000  00000000  000208da  2**0
                  CONTENTS, READONLY
  8 .debug_info   0000c56a  00000000  00000000  00020933  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00002049  00000000  00000000  0002ce9d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000505f  00000000  00000000  0002eee6  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 000009f8  00000000  00000000  00033f45  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000008b8  00000000  00000000  0003493d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000bd91  00000000  00000000  000351f5  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   00016143  00000000  00000000  00040f86  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00086411  00000000  00000000  000570c9  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00003808  00000000  00000000  000dd4dc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <_sfixed>:
  400000:	2040e4c0 	.word	0x2040e4c0
  400004:	00403611 	.word	0x00403611
  400008:	004036bd 	.word	0x004036bd
  40000c:	004036bd 	.word	0x004036bd
  400010:	004036bd 	.word	0x004036bd
  400014:	004036bd 	.word	0x004036bd
  400018:	004036bd 	.word	0x004036bd
	...
  40002c:	004003c1 	.word	0x004003c1
  400030:	004036bd 	.word	0x004036bd
  400034:	00000000 	.word	0x00000000
  400038:	004005a1 	.word	0x004005a1
  40003c:	00400609 	.word	0x00400609
  400040:	004036bd 	.word	0x004036bd
  400044:	004036bd 	.word	0x004036bd
  400048:	004036bd 	.word	0x004036bd
  40004c:	004036bd 	.word	0x004036bd
  400050:	004036bd 	.word	0x004036bd
  400054:	004036bd 	.word	0x004036bd
  400058:	004036bd 	.word	0x004036bd
  40005c:	004036bd 	.word	0x004036bd
  400060:	004036bd 	.word	0x004036bd
  400064:	00000000 	.word	0x00000000
  400068:	004036bd 	.word	0x004036bd
  40006c:	004036bd 	.word	0x004036bd
  400070:	004036bd 	.word	0x004036bd
  400074:	004036bd 	.word	0x004036bd
  400078:	004036bd 	.word	0x004036bd
  40007c:	004036bd 	.word	0x004036bd
  400080:	004036bd 	.word	0x004036bd
  400084:	004036bd 	.word	0x004036bd
  400088:	004036bd 	.word	0x004036bd
  40008c:	004036bd 	.word	0x004036bd
  400090:	004036bd 	.word	0x004036bd
  400094:	004036bd 	.word	0x004036bd
  400098:	004036bd 	.word	0x004036bd
  40009c:	00403535 	.word	0x00403535
  4000a0:	00403599 	.word	0x00403599
  4000a4:	004036bd 	.word	0x004036bd
  4000a8:	004036bd 	.word	0x004036bd
  4000ac:	004036bd 	.word	0x004036bd
  4000b0:	004036bd 	.word	0x004036bd
  4000b4:	004036bd 	.word	0x004036bd
  4000b8:	004036bd 	.word	0x004036bd
  4000bc:	004036bd 	.word	0x004036bd
  4000c0:	004036bd 	.word	0x004036bd
  4000c4:	004036bd 	.word	0x004036bd
  4000c8:	004036bd 	.word	0x004036bd
  4000cc:	004036bd 	.word	0x004036bd
  4000d0:	004036bd 	.word	0x004036bd
  4000d4:	004036bd 	.word	0x004036bd
  4000d8:	004036bd 	.word	0x004036bd
  4000dc:	004036bd 	.word	0x004036bd
  4000e0:	004036bd 	.word	0x004036bd
  4000e4:	004036bd 	.word	0x004036bd
  4000e8:	004036bd 	.word	0x004036bd
  4000ec:	004036bd 	.word	0x004036bd
  4000f0:	004036bd 	.word	0x004036bd
  4000f4:	004036bd 	.word	0x004036bd
  4000f8:	004036bd 	.word	0x004036bd
  4000fc:	004036bd 	.word	0x004036bd
  400100:	004036bd 	.word	0x004036bd
  400104:	004036bd 	.word	0x004036bd
  400108:	004036bd 	.word	0x004036bd
  40010c:	004036bd 	.word	0x004036bd
  400110:	004036bd 	.word	0x004036bd
  400114:	004036bd 	.word	0x004036bd
	...
  400120:	004036bd 	.word	0x004036bd
  400124:	004036bd 	.word	0x004036bd
  400128:	004036bd 	.word	0x004036bd
  40012c:	004036bd 	.word	0x004036bd
  400130:	004036bd 	.word	0x004036bd
  400134:	00000000 	.word	0x00000000
  400138:	004036bd 	.word	0x004036bd
  40013c:	004036bd 	.word	0x004036bd

00400140 <__do_global_dtors_aux>:
  400140:	b510      	push	{r4, lr}
  400142:	4c05      	ldr	r4, [pc, #20]	; (400158 <__do_global_dtors_aux+0x18>)
  400144:	7823      	ldrb	r3, [r4, #0]
  400146:	b933      	cbnz	r3, 400156 <__do_global_dtors_aux+0x16>
  400148:	4b04      	ldr	r3, [pc, #16]	; (40015c <__do_global_dtors_aux+0x1c>)
  40014a:	b113      	cbz	r3, 400152 <__do_global_dtors_aux+0x12>
  40014c:	4804      	ldr	r0, [pc, #16]	; (400160 <__do_global_dtors_aux+0x20>)
  40014e:	f3af 8000 	nop.w
  400152:	2301      	movs	r3, #1
  400154:	7023      	strb	r3, [r4, #0]
  400156:	bd10      	pop	{r4, pc}
  400158:	204008ac 	.word	0x204008ac
  40015c:	00000000 	.word	0x00000000
  400160:	0040afa0 	.word	0x0040afa0

00400164 <frame_dummy>:
  400164:	4b08      	ldr	r3, [pc, #32]	; (400188 <frame_dummy+0x24>)
  400166:	b510      	push	{r4, lr}
  400168:	b11b      	cbz	r3, 400172 <frame_dummy+0xe>
  40016a:	4908      	ldr	r1, [pc, #32]	; (40018c <frame_dummy+0x28>)
  40016c:	4808      	ldr	r0, [pc, #32]	; (400190 <frame_dummy+0x2c>)
  40016e:	f3af 8000 	nop.w
  400172:	4808      	ldr	r0, [pc, #32]	; (400194 <frame_dummy+0x30>)
  400174:	6803      	ldr	r3, [r0, #0]
  400176:	b903      	cbnz	r3, 40017a <frame_dummy+0x16>
  400178:	bd10      	pop	{r4, pc}
  40017a:	4b07      	ldr	r3, [pc, #28]	; (400198 <frame_dummy+0x34>)
  40017c:	2b00      	cmp	r3, #0
  40017e:	d0fb      	beq.n	400178 <frame_dummy+0x14>
  400180:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  400184:	4718      	bx	r3
  400186:	bf00      	nop
  400188:	00000000 	.word	0x00000000
  40018c:	204008b0 	.word	0x204008b0
  400190:	0040afa0 	.word	0x0040afa0
  400194:	0040afa0 	.word	0x0040afa0
  400198:	00000000 	.word	0x00000000

0040019c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
  40019c:	b480      	push	{r7}
  40019e:	b083      	sub	sp, #12
  4001a0:	af00      	add	r7, sp, #0
  4001a2:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  4001a4:	687b      	ldr	r3, [r7, #4]
  4001a6:	f103 0208 	add.w	r2, r3, #8
  4001aa:	687b      	ldr	r3, [r7, #4]
  4001ac:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  4001ae:	687b      	ldr	r3, [r7, #4]
  4001b0:	f04f 32ff 	mov.w	r2, #4294967295
  4001b4:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  4001b6:	687b      	ldr	r3, [r7, #4]
  4001b8:	f103 0208 	add.w	r2, r3, #8
  4001bc:	687b      	ldr	r3, [r7, #4]
  4001be:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  4001c0:	687b      	ldr	r3, [r7, #4]
  4001c2:	f103 0208 	add.w	r2, r3, #8
  4001c6:	687b      	ldr	r3, [r7, #4]
  4001c8:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
  4001ca:	687b      	ldr	r3, [r7, #4]
  4001cc:	2200      	movs	r2, #0
  4001ce:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
  4001d0:	bf00      	nop
  4001d2:	370c      	adds	r7, #12
  4001d4:	46bd      	mov	sp, r7
  4001d6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4001da:	4770      	bx	lr

004001dc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
  4001dc:	b480      	push	{r7}
  4001de:	b083      	sub	sp, #12
  4001e0:	af00      	add	r7, sp, #0
  4001e2:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
  4001e4:	687b      	ldr	r3, [r7, #4]
  4001e6:	2200      	movs	r2, #0
  4001e8:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
  4001ea:	bf00      	nop
  4001ec:	370c      	adds	r7, #12
  4001ee:	46bd      	mov	sp, r7
  4001f0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4001f4:	4770      	bx	lr
  4001f6:	bf00      	nop

004001f8 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
  4001f8:	b480      	push	{r7}
  4001fa:	b085      	sub	sp, #20
  4001fc:	af00      	add	r7, sp, #0
  4001fe:	6078      	str	r0, [r7, #4]
  400200:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
  400202:	687b      	ldr	r3, [r7, #4]
  400204:	685b      	ldr	r3, [r3, #4]
  400206:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
  400208:	683b      	ldr	r3, [r7, #0]
  40020a:	68fa      	ldr	r2, [r7, #12]
  40020c:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
  40020e:	68fb      	ldr	r3, [r7, #12]
  400210:	689a      	ldr	r2, [r3, #8]
  400212:	683b      	ldr	r3, [r7, #0]
  400214:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
  400216:	68fb      	ldr	r3, [r7, #12]
  400218:	689b      	ldr	r3, [r3, #8]
  40021a:	683a      	ldr	r2, [r7, #0]
  40021c:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
  40021e:	68fb      	ldr	r3, [r7, #12]
  400220:	683a      	ldr	r2, [r7, #0]
  400222:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  400224:	683b      	ldr	r3, [r7, #0]
  400226:	687a      	ldr	r2, [r7, #4]
  400228:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
  40022a:	687b      	ldr	r3, [r7, #4]
  40022c:	681b      	ldr	r3, [r3, #0]
  40022e:	1c5a      	adds	r2, r3, #1
  400230:	687b      	ldr	r3, [r7, #4]
  400232:	601a      	str	r2, [r3, #0]
}
  400234:	bf00      	nop
  400236:	3714      	adds	r7, #20
  400238:	46bd      	mov	sp, r7
  40023a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40023e:	4770      	bx	lr

00400240 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
  400240:	b480      	push	{r7}
  400242:	b085      	sub	sp, #20
  400244:	af00      	add	r7, sp, #0
  400246:	6078      	str	r0, [r7, #4]
  400248:	6039      	str	r1, [r7, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
  40024a:	683b      	ldr	r3, [r7, #0]
  40024c:	681b      	ldr	r3, [r3, #0]
  40024e:	60bb      	str	r3, [r7, #8]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
  400250:	68bb      	ldr	r3, [r7, #8]
  400252:	f1b3 3fff 	cmp.w	r3, #4294967295
  400256:	d103      	bne.n	400260 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
  400258:	687b      	ldr	r3, [r7, #4]
  40025a:	691b      	ldr	r3, [r3, #16]
  40025c:	60fb      	str	r3, [r7, #12]
  40025e:	e00c      	b.n	40027a <vListInsert+0x3a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  400260:	687b      	ldr	r3, [r7, #4]
  400262:	3308      	adds	r3, #8
  400264:	60fb      	str	r3, [r7, #12]
  400266:	e002      	b.n	40026e <vListInsert+0x2e>
  400268:	68fb      	ldr	r3, [r7, #12]
  40026a:	685b      	ldr	r3, [r3, #4]
  40026c:	60fb      	str	r3, [r7, #12]
  40026e:	68fb      	ldr	r3, [r7, #12]
  400270:	685b      	ldr	r3, [r3, #4]
  400272:	681a      	ldr	r2, [r3, #0]
  400274:	68bb      	ldr	r3, [r7, #8]
  400276:	429a      	cmp	r2, r3
  400278:	d9f6      	bls.n	400268 <vListInsert+0x28>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
  40027a:	68fb      	ldr	r3, [r7, #12]
  40027c:	685a      	ldr	r2, [r3, #4]
  40027e:	683b      	ldr	r3, [r7, #0]
  400280:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
  400282:	683b      	ldr	r3, [r7, #0]
  400284:	685b      	ldr	r3, [r3, #4]
  400286:	683a      	ldr	r2, [r7, #0]
  400288:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
  40028a:	683b      	ldr	r3, [r7, #0]
  40028c:	68fa      	ldr	r2, [r7, #12]
  40028e:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
  400290:	68fb      	ldr	r3, [r7, #12]
  400292:	683a      	ldr	r2, [r7, #0]
  400294:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  400296:	683b      	ldr	r3, [r7, #0]
  400298:	687a      	ldr	r2, [r7, #4]
  40029a:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
  40029c:	687b      	ldr	r3, [r7, #4]
  40029e:	681b      	ldr	r3, [r3, #0]
  4002a0:	1c5a      	adds	r2, r3, #1
  4002a2:	687b      	ldr	r3, [r7, #4]
  4002a4:	601a      	str	r2, [r3, #0]
}
  4002a6:	bf00      	nop
  4002a8:	3714      	adds	r7, #20
  4002aa:	46bd      	mov	sp, r7
  4002ac:	f85d 7b04 	ldr.w	r7, [sp], #4
  4002b0:	4770      	bx	lr
  4002b2:	bf00      	nop

004002b4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
  4002b4:	b480      	push	{r7}
  4002b6:	b085      	sub	sp, #20
  4002b8:	af00      	add	r7, sp, #0
  4002ba:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
  4002bc:	687b      	ldr	r3, [r7, #4]
  4002be:	691b      	ldr	r3, [r3, #16]
  4002c0:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  4002c2:	687b      	ldr	r3, [r7, #4]
  4002c4:	685b      	ldr	r3, [r3, #4]
  4002c6:	687a      	ldr	r2, [r7, #4]
  4002c8:	6892      	ldr	r2, [r2, #8]
  4002ca:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  4002cc:	687b      	ldr	r3, [r7, #4]
  4002ce:	689b      	ldr	r3, [r3, #8]
  4002d0:	687a      	ldr	r2, [r7, #4]
  4002d2:	6852      	ldr	r2, [r2, #4]
  4002d4:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
  4002d6:	68fb      	ldr	r3, [r7, #12]
  4002d8:	685a      	ldr	r2, [r3, #4]
  4002da:	687b      	ldr	r3, [r7, #4]
  4002dc:	429a      	cmp	r2, r3
  4002de:	d103      	bne.n	4002e8 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  4002e0:	687b      	ldr	r3, [r7, #4]
  4002e2:	689a      	ldr	r2, [r3, #8]
  4002e4:	68fb      	ldr	r3, [r7, #12]
  4002e6:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
  4002e8:	687b      	ldr	r3, [r7, #4]
  4002ea:	2200      	movs	r2, #0
  4002ec:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
  4002ee:	68fb      	ldr	r3, [r7, #12]
  4002f0:	681b      	ldr	r3, [r3, #0]
  4002f2:	1e5a      	subs	r2, r3, #1
  4002f4:	68fb      	ldr	r3, [r7, #12]
  4002f6:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
  4002f8:	68fb      	ldr	r3, [r7, #12]
  4002fa:	681b      	ldr	r3, [r3, #0]
}
  4002fc:	4618      	mov	r0, r3
  4002fe:	3714      	adds	r7, #20
  400300:	46bd      	mov	sp, r7
  400302:	f85d 7b04 	ldr.w	r7, [sp], #4
  400306:	4770      	bx	lr

00400308 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
  400308:	b480      	push	{r7}
  40030a:	b085      	sub	sp, #20
  40030c:	af00      	add	r7, sp, #0
  40030e:	60f8      	str	r0, [r7, #12]
  400310:	60b9      	str	r1, [r7, #8]
  400312:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */

	/* Offset added to account for the way the MCU uses the stack on entry/exit
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;
  400314:	68fb      	ldr	r3, [r7, #12]
  400316:	3b04      	subs	r3, #4
  400318:	60fb      	str	r3, [r7, #12]

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
  40031a:	68fb      	ldr	r3, [r7, #12]
  40031c:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
  400320:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
  400322:	68fb      	ldr	r3, [r7, #12]
  400324:	3b04      	subs	r3, #4
  400326:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
  400328:	68bb      	ldr	r3, [r7, #8]
  40032a:	f023 0201 	bic.w	r2, r3, #1
  40032e:	68fb      	ldr	r3, [r7, #12]
  400330:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
  400332:	68fb      	ldr	r3, [r7, #12]
  400334:	3b04      	subs	r3, #4
  400336:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
  400338:	4a0c      	ldr	r2, [pc, #48]	; (40036c <pxPortInitialiseStack+0x64>)
  40033a:	68fb      	ldr	r3, [r7, #12]
  40033c:	601a      	str	r2, [r3, #0]

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
  40033e:	68fb      	ldr	r3, [r7, #12]
  400340:	3b14      	subs	r3, #20
  400342:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
  400344:	687a      	ldr	r2, [r7, #4]
  400346:	68fb      	ldr	r3, [r7, #12]
  400348:	601a      	str	r2, [r3, #0]

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
  40034a:	68fb      	ldr	r3, [r7, #12]
  40034c:	3b04      	subs	r3, #4
  40034e:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
  400350:	68fb      	ldr	r3, [r7, #12]
  400352:	f06f 0202 	mvn.w	r2, #2
  400356:	601a      	str	r2, [r3, #0]

	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
  400358:	68fb      	ldr	r3, [r7, #12]
  40035a:	3b20      	subs	r3, #32
  40035c:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
  40035e:	68fb      	ldr	r3, [r7, #12]
}
  400360:	4618      	mov	r0, r3
  400362:	3714      	adds	r7, #20
  400364:	46bd      	mov	sp, r7
  400366:	f85d 7b04 	ldr.w	r7, [sp], #4
  40036a:	4770      	bx	lr
  40036c:	00400371 	.word	0x00400371

00400370 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
  400370:	b480      	push	{r7}
  400372:	b083      	sub	sp, #12
  400374:	af00      	add	r7, sp, #0
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
  400376:	4b0e      	ldr	r3, [pc, #56]	; (4003b0 <prvTaskExitError+0x40>)
  400378:	681b      	ldr	r3, [r3, #0]
  40037a:	f1b3 3fff 	cmp.w	r3, #4294967295
  40037e:	d00b      	beq.n	400398 <prvTaskExitError+0x28>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
  400380:	f04f 0380 	mov.w	r3, #128	; 0x80
  400384:	b672      	cpsid	i
  400386:	f383 8811 	msr	BASEPRI, r3
  40038a:	f3bf 8f6f 	isb	sy
  40038e:	f3bf 8f4f 	dsb	sy
  400392:	b662      	cpsie	i
  400394:	603b      	str	r3, [r7, #0]
  400396:	e7fe      	b.n	400396 <prvTaskExitError+0x26>
  400398:	f04f 0380 	mov.w	r3, #128	; 0x80
  40039c:	b672      	cpsid	i
  40039e:	f383 8811 	msr	BASEPRI, r3
  4003a2:	f3bf 8f6f 	isb	sy
  4003a6:	f3bf 8f4f 	dsb	sy
  4003aa:	b662      	cpsie	i
  4003ac:	607b      	str	r3, [r7, #4]
	portDISABLE_INTERRUPTS();
	for( ;; );
  4003ae:	e7fe      	b.n	4003ae <prvTaskExitError+0x3e>
  4003b0:	20400000 	.word	0x20400000
	...

004003c0 <SVC_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
  4003c0:	4b07      	ldr	r3, [pc, #28]	; (4003e0 <pxCurrentTCBConst2>)
  4003c2:	6819      	ldr	r1, [r3, #0]
  4003c4:	6808      	ldr	r0, [r1, #0]
  4003c6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4003ca:	f380 8809 	msr	PSP, r0
  4003ce:	f3bf 8f6f 	isb	sy
  4003d2:	f04f 0000 	mov.w	r0, #0
  4003d6:	f380 8811 	msr	BASEPRI, r0
  4003da:	4770      	bx	lr
  4003dc:	f3af 8000 	nop.w

004003e0 <pxCurrentTCBConst2>:
  4003e0:	2040c0fc 	.word	0x2040c0fc
					"	bx r14							\n"
					"									\n"
					"	.align 4						\n"
					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
				);
}
  4003e4:	bf00      	nop
  4003e6:	bf00      	nop

004003e8 <prvPortStartFirstTask>:
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
  4003e8:	4806      	ldr	r0, [pc, #24]	; (400404 <prvPortStartFirstTask+0x1c>)
  4003ea:	6800      	ldr	r0, [r0, #0]
  4003ec:	6800      	ldr	r0, [r0, #0]
  4003ee:	f380 8808 	msr	MSP, r0
  4003f2:	b662      	cpsie	i
  4003f4:	b661      	cpsie	f
  4003f6:	f3bf 8f4f 	dsb	sy
  4003fa:	f3bf 8f6f 	isb	sy
  4003fe:	df00      	svc	0
  400400:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
  400402:	bf00      	nop
  400404:	e000ed08 	.word	0xe000ed08

00400408 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
  400408:	b580      	push	{r7, lr}
  40040a:	b084      	sub	sp, #16
  40040c:	af00      	add	r7, sp, #0
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	#if( configASSERT_DEFINED == 1 )
	{
		volatile uint32_t ulOriginalPriority;
		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
  40040e:	4b2c      	ldr	r3, [pc, #176]	; (4004c0 <xPortStartScheduler+0xb8>)
  400410:	60fb      	str	r3, [r7, #12]
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
  400412:	68fb      	ldr	r3, [r7, #12]
  400414:	781b      	ldrb	r3, [r3, #0]
  400416:	b2db      	uxtb	r3, r3
  400418:	60bb      	str	r3, [r7, #8]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
  40041a:	68fb      	ldr	r3, [r7, #12]
  40041c:	22ff      	movs	r2, #255	; 0xff
  40041e:	701a      	strb	r2, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
  400420:	68fb      	ldr	r3, [r7, #12]
  400422:	781b      	ldrb	r3, [r3, #0]
  400424:	b2db      	uxtb	r3, r3
  400426:	71fb      	strb	r3, [r7, #7]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
  400428:	79fb      	ldrb	r3, [r7, #7]
  40042a:	b2db      	uxtb	r3, r3
  40042c:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  400430:	b2da      	uxtb	r2, r3
  400432:	4b24      	ldr	r3, [pc, #144]	; (4004c4 <xPortStartScheduler+0xbc>)
  400434:	701a      	strb	r2, [r3, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
  400436:	4b24      	ldr	r3, [pc, #144]	; (4004c8 <xPortStartScheduler+0xc0>)
  400438:	2207      	movs	r2, #7
  40043a:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
  40043c:	e009      	b.n	400452 <xPortStartScheduler+0x4a>
		{
			ulMaxPRIGROUPValue--;
  40043e:	4b22      	ldr	r3, [pc, #136]	; (4004c8 <xPortStartScheduler+0xc0>)
  400440:	681b      	ldr	r3, [r3, #0]
  400442:	3b01      	subs	r3, #1
  400444:	4a20      	ldr	r2, [pc, #128]	; (4004c8 <xPortStartScheduler+0xc0>)
  400446:	6013      	str	r3, [r2, #0]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
  400448:	79fb      	ldrb	r3, [r7, #7]
  40044a:	b2db      	uxtb	r3, r3
  40044c:	005b      	lsls	r3, r3, #1
  40044e:	b2db      	uxtb	r3, r3
  400450:	71fb      	strb	r3, [r7, #7]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
  400452:	79fb      	ldrb	r3, [r7, #7]
  400454:	b2db      	uxtb	r3, r3
  400456:	b25b      	sxtb	r3, r3
  400458:	2b00      	cmp	r3, #0
  40045a:	dbf0      	blt.n	40043e <xPortStartScheduler+0x36>
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
		}

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
  40045c:	4b1a      	ldr	r3, [pc, #104]	; (4004c8 <xPortStartScheduler+0xc0>)
  40045e:	681b      	ldr	r3, [r3, #0]
  400460:	021b      	lsls	r3, r3, #8
  400462:	4a19      	ldr	r2, [pc, #100]	; (4004c8 <xPortStartScheduler+0xc0>)
  400464:	6013      	str	r3, [r2, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
  400466:	4b18      	ldr	r3, [pc, #96]	; (4004c8 <xPortStartScheduler+0xc0>)
  400468:	681b      	ldr	r3, [r3, #0]
  40046a:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  40046e:	4a16      	ldr	r2, [pc, #88]	; (4004c8 <xPortStartScheduler+0xc0>)
  400470:	6013      	str	r3, [r2, #0]

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pucFirstUserPriorityRegister = ulOriginalPriority;
  400472:	68bb      	ldr	r3, [r7, #8]
  400474:	b2da      	uxtb	r2, r3
  400476:	68fb      	ldr	r3, [r7, #12]
  400478:	701a      	strb	r2, [r3, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
  40047a:	4a14      	ldr	r2, [pc, #80]	; (4004cc <xPortStartScheduler+0xc4>)
  40047c:	4b13      	ldr	r3, [pc, #76]	; (4004cc <xPortStartScheduler+0xc4>)
  40047e:	681b      	ldr	r3, [r3, #0]
  400480:	f443 0360 	orr.w	r3, r3, #14680064	; 0xe00000
  400484:	6013      	str	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
  400486:	4a11      	ldr	r2, [pc, #68]	; (4004cc <xPortStartScheduler+0xc4>)
  400488:	4b10      	ldr	r3, [pc, #64]	; (4004cc <xPortStartScheduler+0xc4>)
  40048a:	681b      	ldr	r3, [r3, #0]
  40048c:	f043 4360 	orr.w	r3, r3, #3758096384	; 0xe0000000
  400490:	6013      	str	r3, [r2, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
  400492:	4b0f      	ldr	r3, [pc, #60]	; (4004d0 <xPortStartScheduler+0xc8>)
  400494:	4798      	blx	r3

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
  400496:	4b0f      	ldr	r3, [pc, #60]	; (4004d4 <xPortStartScheduler+0xcc>)
  400498:	2200      	movs	r2, #0
  40049a:	601a      	str	r2, [r3, #0]

	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
  40049c:	4b0e      	ldr	r3, [pc, #56]	; (4004d8 <xPortStartScheduler+0xd0>)
  40049e:	4798      	blx	r3

	/* Lazy save always. */
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
  4004a0:	4a0e      	ldr	r2, [pc, #56]	; (4004dc <xPortStartScheduler+0xd4>)
  4004a2:	4b0e      	ldr	r3, [pc, #56]	; (4004dc <xPortStartScheduler+0xd4>)
  4004a4:	681b      	ldr	r3, [r3, #0]
  4004a6:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
  4004aa:	6013      	str	r3, [r2, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
  4004ac:	4b0c      	ldr	r3, [pc, #48]	; (4004e0 <xPortStartScheduler+0xd8>)
  4004ae:	4798      	blx	r3

	/* Should never get here as the tasks will now be executing!  Call the task
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS. */
	prvTaskExitError();
  4004b0:	4b0c      	ldr	r3, [pc, #48]	; (4004e4 <xPortStartScheduler+0xdc>)
  4004b2:	4798      	blx	r3

	/* Should not get here! */
	return 0;
  4004b4:	2300      	movs	r3, #0
}
  4004b6:	4618      	mov	r0, r3
  4004b8:	3710      	adds	r7, #16
  4004ba:	46bd      	mov	sp, r7
  4004bc:	bd80      	pop	{r7, pc}
  4004be:	bf00      	nop
  4004c0:	e000e400 	.word	0xe000e400
  4004c4:	204008cd 	.word	0x204008cd
  4004c8:	204008d0 	.word	0x204008d0
  4004cc:	e000ed20 	.word	0xe000ed20
  4004d0:	00400651 	.word	0x00400651
  4004d4:	20400000 	.word	0x20400000
  4004d8:	00400679 	.word	0x00400679
  4004dc:	e000ef34 	.word	0xe000ef34
  4004e0:	004003e9 	.word	0x004003e9
  4004e4:	00400371 	.word	0x00400371

004004e8 <vPortEnterCritical>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
  4004e8:	b480      	push	{r7}
  4004ea:	b083      	sub	sp, #12
  4004ec:	af00      	add	r7, sp, #0
  4004ee:	f04f 0380 	mov.w	r3, #128	; 0x80
  4004f2:	b672      	cpsid	i
  4004f4:	f383 8811 	msr	BASEPRI, r3
  4004f8:	f3bf 8f6f 	isb	sy
  4004fc:	f3bf 8f4f 	dsb	sy
  400500:	b662      	cpsie	i
  400502:	603b      	str	r3, [r7, #0]
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
  400504:	4b0f      	ldr	r3, [pc, #60]	; (400544 <vPortEnterCritical+0x5c>)
  400506:	681b      	ldr	r3, [r3, #0]
  400508:	3301      	adds	r3, #1
  40050a:	4a0e      	ldr	r2, [pc, #56]	; (400544 <vPortEnterCritical+0x5c>)
  40050c:	6013      	str	r3, [r2, #0]
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
  40050e:	4b0d      	ldr	r3, [pc, #52]	; (400544 <vPortEnterCritical+0x5c>)
  400510:	681b      	ldr	r3, [r3, #0]
  400512:	2b01      	cmp	r3, #1
  400514:	d110      	bne.n	400538 <vPortEnterCritical+0x50>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
  400516:	4b0c      	ldr	r3, [pc, #48]	; (400548 <vPortEnterCritical+0x60>)
  400518:	681b      	ldr	r3, [r3, #0]
  40051a:	b2db      	uxtb	r3, r3
  40051c:	2b00      	cmp	r3, #0
  40051e:	d00b      	beq.n	400538 <vPortEnterCritical+0x50>
  400520:	f04f 0380 	mov.w	r3, #128	; 0x80
  400524:	b672      	cpsid	i
  400526:	f383 8811 	msr	BASEPRI, r3
  40052a:	f3bf 8f6f 	isb	sy
  40052e:	f3bf 8f4f 	dsb	sy
  400532:	b662      	cpsie	i
  400534:	607b      	str	r3, [r7, #4]
  400536:	e7fe      	b.n	400536 <vPortEnterCritical+0x4e>
	}
}
  400538:	bf00      	nop
  40053a:	370c      	adds	r7, #12
  40053c:	46bd      	mov	sp, r7
  40053e:	f85d 7b04 	ldr.w	r7, [sp], #4
  400542:	4770      	bx	lr
  400544:	20400000 	.word	0x20400000
  400548:	e000ed04 	.word	0xe000ed04

0040054c <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
  40054c:	b480      	push	{r7}
  40054e:	b083      	sub	sp, #12
  400550:	af00      	add	r7, sp, #0
	configASSERT( uxCriticalNesting );
  400552:	4b12      	ldr	r3, [pc, #72]	; (40059c <vPortExitCritical+0x50>)
  400554:	681b      	ldr	r3, [r3, #0]
  400556:	2b00      	cmp	r3, #0
  400558:	d10b      	bne.n	400572 <vPortExitCritical+0x26>
  40055a:	f04f 0380 	mov.w	r3, #128	; 0x80
  40055e:	b672      	cpsid	i
  400560:	f383 8811 	msr	BASEPRI, r3
  400564:	f3bf 8f6f 	isb	sy
  400568:	f3bf 8f4f 	dsb	sy
  40056c:	b662      	cpsie	i
  40056e:	603b      	str	r3, [r7, #0]
  400570:	e7fe      	b.n	400570 <vPortExitCritical+0x24>
	uxCriticalNesting--;
  400572:	4b0a      	ldr	r3, [pc, #40]	; (40059c <vPortExitCritical+0x50>)
  400574:	681b      	ldr	r3, [r3, #0]
  400576:	3b01      	subs	r3, #1
  400578:	4a08      	ldr	r2, [pc, #32]	; (40059c <vPortExitCritical+0x50>)
  40057a:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
  40057c:	4b07      	ldr	r3, [pc, #28]	; (40059c <vPortExitCritical+0x50>)
  40057e:	681b      	ldr	r3, [r3, #0]
  400580:	2b00      	cmp	r3, #0
  400582:	d104      	bne.n	40058e <vPortExitCritical+0x42>
  400584:	2300      	movs	r3, #0
  400586:	607b      	str	r3, [r7, #4]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
  400588:	687b      	ldr	r3, [r7, #4]
  40058a:	f383 8811 	msr	BASEPRI, r3
	{
		portENABLE_INTERRUPTS();
	}
}
  40058e:	bf00      	nop
  400590:	370c      	adds	r7, #12
  400592:	46bd      	mov	sp, r7
  400594:	f85d 7b04 	ldr.w	r7, [sp], #4
  400598:	4770      	bx	lr
  40059a:	bf00      	nop
  40059c:	20400000 	.word	0x20400000

004005a0 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
  4005a0:	f3ef 8009 	mrs	r0, PSP
  4005a4:	f3bf 8f6f 	isb	sy
  4005a8:	4b15      	ldr	r3, [pc, #84]	; (400600 <pxCurrentTCBConst>)
  4005aa:	681a      	ldr	r2, [r3, #0]
  4005ac:	f01e 0f10 	tst.w	lr, #16
  4005b0:	bf08      	it	eq
  4005b2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
  4005b6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4005ba:	6010      	str	r0, [r2, #0]
  4005bc:	f84d 3d04 	str.w	r3, [sp, #-4]!
  4005c0:	f04f 0080 	mov.w	r0, #128	; 0x80
  4005c4:	b672      	cpsid	i
  4005c6:	f380 8811 	msr	BASEPRI, r0
  4005ca:	f3bf 8f4f 	dsb	sy
  4005ce:	f3bf 8f6f 	isb	sy
  4005d2:	b662      	cpsie	i
  4005d4:	f001 fcee 	bl	401fb4 <vTaskSwitchContext>
  4005d8:	f04f 0000 	mov.w	r0, #0
  4005dc:	f380 8811 	msr	BASEPRI, r0
  4005e0:	bc08      	pop	{r3}
  4005e2:	6819      	ldr	r1, [r3, #0]
  4005e4:	6808      	ldr	r0, [r1, #0]
  4005e6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4005ea:	f01e 0f10 	tst.w	lr, #16
  4005ee:	bf08      	it	eq
  4005f0:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
  4005f4:	f380 8809 	msr	PSP, r0
  4005f8:	f3bf 8f6f 	isb	sy
  4005fc:	4770      	bx	lr
  4005fe:	bf00      	nop

00400600 <pxCurrentTCBConst>:
  400600:	2040c0fc 	.word	0x2040c0fc
	"										\n"
	"	.align 4							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
	);
}
  400604:	bf00      	nop
  400606:	bf00      	nop

00400608 <SysTick_Handler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
  400608:	b580      	push	{r7, lr}
  40060a:	b082      	sub	sp, #8
  40060c:	af00      	add	r7, sp, #0

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
  40060e:	f04f 0380 	mov.w	r3, #128	; 0x80
  400612:	b672      	cpsid	i
  400614:	f383 8811 	msr	BASEPRI, r3
  400618:	f3bf 8f6f 	isb	sy
  40061c:	f3bf 8f4f 	dsb	sy
  400620:	b662      	cpsie	i
  400622:	603b      	str	r3, [r7, #0]
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
  400624:	4b08      	ldr	r3, [pc, #32]	; (400648 <SysTick_Handler+0x40>)
  400626:	4798      	blx	r3
  400628:	4603      	mov	r3, r0
  40062a:	2b00      	cmp	r3, #0
  40062c:	d003      	beq.n	400636 <SysTick_Handler+0x2e>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  40062e:	4b07      	ldr	r3, [pc, #28]	; (40064c <SysTick_Handler+0x44>)
  400630:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  400634:	601a      	str	r2, [r3, #0]
  400636:	2300      	movs	r3, #0
  400638:	607b      	str	r3, [r7, #4]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
  40063a:	687b      	ldr	r3, [r7, #4]
  40063c:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();
}
  400640:	bf00      	nop
  400642:	3708      	adds	r7, #8
  400644:	46bd      	mov	sp, r7
  400646:	bd80      	pop	{r7, pc}
  400648:	00401e19 	.word	0x00401e19
  40064c:	e000ed04 	.word	0xe000ed04

00400650 <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
{
  400650:	b480      	push	{r7}
  400652:	af00      	add	r7, sp, #0
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
  400654:	4b05      	ldr	r3, [pc, #20]	; (40066c <vPortSetupTimerInterrupt+0x1c>)
  400656:	4a06      	ldr	r2, [pc, #24]	; (400670 <vPortSetupTimerInterrupt+0x20>)
  400658:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
  40065a:	4b06      	ldr	r3, [pc, #24]	; (400674 <vPortSetupTimerInterrupt+0x24>)
  40065c:	2207      	movs	r2, #7
  40065e:	601a      	str	r2, [r3, #0]
}
  400660:	bf00      	nop
  400662:	46bd      	mov	sp, r7
  400664:	f85d 7b04 	ldr.w	r7, [sp], #4
  400668:	4770      	bx	lr
  40066a:	bf00      	nop
  40066c:	e000e014 	.word	0xe000e014
  400670:	000493df 	.word	0x000493df
  400674:	e000e010 	.word	0xe000e010

00400678 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
  400678:	f8df 000c 	ldr.w	r0, [pc, #12]	; 400688 <vPortEnableVFP+0x10>
  40067c:	6801      	ldr	r1, [r0, #0]
  40067e:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  400682:	6001      	str	r1, [r0, #0]
  400684:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
  400686:	bf00      	nop
  400688:	e000ed88 	.word	0xe000ed88

0040068c <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
  40068c:	b480      	push	{r7}
  40068e:	b085      	sub	sp, #20
  400690:	af00      	add	r7, sp, #0
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
  400692:	f3ef 8305 	mrs	r3, IPSR
  400696:	60fb      	str	r3, [r7, #12]

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
  400698:	68fb      	ldr	r3, [r7, #12]
  40069a:	2b0f      	cmp	r3, #15
  40069c:	d915      	bls.n	4006ca <vPortValidateInterruptPriority+0x3e>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
  40069e:	4a18      	ldr	r2, [pc, #96]	; (400700 <vPortValidateInterruptPriority+0x74>)
  4006a0:	68fb      	ldr	r3, [r7, #12]
  4006a2:	4413      	add	r3, r2
  4006a4:	781b      	ldrb	r3, [r3, #0]
  4006a6:	72fb      	strb	r3, [r7, #11]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
  4006a8:	4b16      	ldr	r3, [pc, #88]	; (400704 <vPortValidateInterruptPriority+0x78>)
  4006aa:	781b      	ldrb	r3, [r3, #0]
  4006ac:	7afa      	ldrb	r2, [r7, #11]
  4006ae:	429a      	cmp	r2, r3
  4006b0:	d20b      	bcs.n	4006ca <vPortValidateInterruptPriority+0x3e>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
  4006b2:	f04f 0380 	mov.w	r3, #128	; 0x80
  4006b6:	b672      	cpsid	i
  4006b8:	f383 8811 	msr	BASEPRI, r3
  4006bc:	f3bf 8f6f 	isb	sy
  4006c0:	f3bf 8f4f 	dsb	sy
  4006c4:	b662      	cpsie	i
  4006c6:	603b      	str	r3, [r7, #0]
  4006c8:	e7fe      	b.n	4006c8 <vPortValidateInterruptPriority+0x3c>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
  4006ca:	4b0f      	ldr	r3, [pc, #60]	; (400708 <vPortValidateInterruptPriority+0x7c>)
  4006cc:	681b      	ldr	r3, [r3, #0]
  4006ce:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
  4006d2:	4b0e      	ldr	r3, [pc, #56]	; (40070c <vPortValidateInterruptPriority+0x80>)
  4006d4:	681b      	ldr	r3, [r3, #0]
  4006d6:	429a      	cmp	r2, r3
  4006d8:	d90b      	bls.n	4006f2 <vPortValidateInterruptPriority+0x66>
  4006da:	f04f 0380 	mov.w	r3, #128	; 0x80
  4006de:	b672      	cpsid	i
  4006e0:	f383 8811 	msr	BASEPRI, r3
  4006e4:	f3bf 8f6f 	isb	sy
  4006e8:	f3bf 8f4f 	dsb	sy
  4006ec:	b662      	cpsie	i
  4006ee:	607b      	str	r3, [r7, #4]
  4006f0:	e7fe      	b.n	4006f0 <vPortValidateInterruptPriority+0x64>
	}
  4006f2:	bf00      	nop
  4006f4:	3714      	adds	r7, #20
  4006f6:	46bd      	mov	sp, r7
  4006f8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4006fc:	4770      	bx	lr
  4006fe:	bf00      	nop
  400700:	e000e3f0 	.word	0xe000e3f0
  400704:	204008cd 	.word	0x204008cd
  400708:	e000ed0c 	.word	0xe000ed0c
  40070c:	204008d0 	.word	0x204008d0

00400710 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  400710:	b580      	push	{r7, lr}
  400712:	b08a      	sub	sp, #40	; 0x28
  400714:	af00      	add	r7, sp, #0
  400716:	6078      	str	r0, [r7, #4]
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
  400718:	2300      	movs	r3, #0
  40071a:	61fb      	str	r3, [r7, #28]

	vTaskSuspendAll();
  40071c:	4b5d      	ldr	r3, [pc, #372]	; (400894 <pvPortMalloc+0x184>)
  40071e:	4798      	blx	r3
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
  400720:	4b5d      	ldr	r3, [pc, #372]	; (400898 <pvPortMalloc+0x188>)
  400722:	681b      	ldr	r3, [r3, #0]
  400724:	2b00      	cmp	r3, #0
  400726:	d101      	bne.n	40072c <pvPortMalloc+0x1c>
		{
			prvHeapInit();
  400728:	4b5c      	ldr	r3, [pc, #368]	; (40089c <pvPortMalloc+0x18c>)
  40072a:	4798      	blx	r3

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
  40072c:	4b5c      	ldr	r3, [pc, #368]	; (4008a0 <pvPortMalloc+0x190>)
  40072e:	681a      	ldr	r2, [r3, #0]
  400730:	687b      	ldr	r3, [r7, #4]
  400732:	4013      	ands	r3, r2
  400734:	2b00      	cmp	r3, #0
  400736:	f040 8090 	bne.w	40085a <pvPortMalloc+0x14a>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
  40073a:	687b      	ldr	r3, [r7, #4]
  40073c:	2b00      	cmp	r3, #0
  40073e:	d01e      	beq.n	40077e <pvPortMalloc+0x6e>
			{
				xWantedSize += xHeapStructSize;
  400740:	2208      	movs	r2, #8
  400742:	687b      	ldr	r3, [r7, #4]
  400744:	4413      	add	r3, r2
  400746:	607b      	str	r3, [r7, #4]

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
  400748:	687b      	ldr	r3, [r7, #4]
  40074a:	f003 0307 	and.w	r3, r3, #7
  40074e:	2b00      	cmp	r3, #0
  400750:	d015      	beq.n	40077e <pvPortMalloc+0x6e>
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
  400752:	687b      	ldr	r3, [r7, #4]
  400754:	f023 0307 	bic.w	r3, r3, #7
  400758:	3308      	adds	r3, #8
  40075a:	607b      	str	r3, [r7, #4]
					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
  40075c:	687b      	ldr	r3, [r7, #4]
  40075e:	f003 0307 	and.w	r3, r3, #7
  400762:	2b00      	cmp	r3, #0
  400764:	d00b      	beq.n	40077e <pvPortMalloc+0x6e>
  400766:	f04f 0380 	mov.w	r3, #128	; 0x80
  40076a:	b672      	cpsid	i
  40076c:	f383 8811 	msr	BASEPRI, r3
  400770:	f3bf 8f6f 	isb	sy
  400774:	f3bf 8f4f 	dsb	sy
  400778:	b662      	cpsie	i
  40077a:	60fb      	str	r3, [r7, #12]
  40077c:	e7fe      	b.n	40077c <pvPortMalloc+0x6c>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
  40077e:	687b      	ldr	r3, [r7, #4]
  400780:	2b00      	cmp	r3, #0
  400782:	d06a      	beq.n	40085a <pvPortMalloc+0x14a>
  400784:	4b47      	ldr	r3, [pc, #284]	; (4008a4 <pvPortMalloc+0x194>)
  400786:	681b      	ldr	r3, [r3, #0]
  400788:	687a      	ldr	r2, [r7, #4]
  40078a:	429a      	cmp	r2, r3
  40078c:	d865      	bhi.n	40085a <pvPortMalloc+0x14a>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
  40078e:	4b46      	ldr	r3, [pc, #280]	; (4008a8 <pvPortMalloc+0x198>)
  400790:	623b      	str	r3, [r7, #32]
				pxBlock = xStart.pxNextFreeBlock;
  400792:	4b45      	ldr	r3, [pc, #276]	; (4008a8 <pvPortMalloc+0x198>)
  400794:	681b      	ldr	r3, [r3, #0]
  400796:	627b      	str	r3, [r7, #36]	; 0x24
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  400798:	e004      	b.n	4007a4 <pvPortMalloc+0x94>
				{
					pxPreviousBlock = pxBlock;
  40079a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40079c:	623b      	str	r3, [r7, #32]
					pxBlock = pxBlock->pxNextFreeBlock;
  40079e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4007a0:	681b      	ldr	r3, [r3, #0]
  4007a2:	627b      	str	r3, [r7, #36]	; 0x24
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  4007a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4007a6:	685a      	ldr	r2, [r3, #4]
  4007a8:	687b      	ldr	r3, [r7, #4]
  4007aa:	429a      	cmp	r2, r3
  4007ac:	d203      	bcs.n	4007b6 <pvPortMalloc+0xa6>
  4007ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4007b0:	681b      	ldr	r3, [r3, #0]
  4007b2:	2b00      	cmp	r3, #0
  4007b4:	d1f1      	bne.n	40079a <pvPortMalloc+0x8a>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
  4007b6:	4b38      	ldr	r3, [pc, #224]	; (400898 <pvPortMalloc+0x188>)
  4007b8:	681b      	ldr	r3, [r3, #0]
  4007ba:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  4007bc:	429a      	cmp	r2, r3
  4007be:	d04c      	beq.n	40085a <pvPortMalloc+0x14a>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
  4007c0:	6a3b      	ldr	r3, [r7, #32]
  4007c2:	681b      	ldr	r3, [r3, #0]
  4007c4:	2208      	movs	r2, #8
  4007c6:	4413      	add	r3, r2
  4007c8:	61fb      	str	r3, [r7, #28]

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
  4007ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4007cc:	681a      	ldr	r2, [r3, #0]
  4007ce:	6a3b      	ldr	r3, [r7, #32]
  4007d0:	601a      	str	r2, [r3, #0]

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
  4007d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4007d4:	685a      	ldr	r2, [r3, #4]
  4007d6:	687b      	ldr	r3, [r7, #4]
  4007d8:	1ad2      	subs	r2, r2, r3
  4007da:	2308      	movs	r3, #8
  4007dc:	005b      	lsls	r3, r3, #1
  4007de:	429a      	cmp	r2, r3
  4007e0:	d920      	bls.n	400824 <pvPortMalloc+0x114>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
  4007e2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  4007e4:	687b      	ldr	r3, [r7, #4]
  4007e6:	4413      	add	r3, r2
  4007e8:	617b      	str	r3, [r7, #20]
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
  4007ea:	697b      	ldr	r3, [r7, #20]
  4007ec:	f003 0307 	and.w	r3, r3, #7
  4007f0:	2b00      	cmp	r3, #0
  4007f2:	d00b      	beq.n	40080c <pvPortMalloc+0xfc>
  4007f4:	f04f 0380 	mov.w	r3, #128	; 0x80
  4007f8:	b672      	cpsid	i
  4007fa:	f383 8811 	msr	BASEPRI, r3
  4007fe:	f3bf 8f6f 	isb	sy
  400802:	f3bf 8f4f 	dsb	sy
  400806:	b662      	cpsie	i
  400808:	61bb      	str	r3, [r7, #24]
  40080a:	e7fe      	b.n	40080a <pvPortMalloc+0xfa>

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
  40080c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40080e:	685a      	ldr	r2, [r3, #4]
  400810:	687b      	ldr	r3, [r7, #4]
  400812:	1ad2      	subs	r2, r2, r3
  400814:	697b      	ldr	r3, [r7, #20]
  400816:	605a      	str	r2, [r3, #4]
						pxBlock->xBlockSize = xWantedSize;
  400818:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40081a:	687a      	ldr	r2, [r7, #4]
  40081c:	605a      	str	r2, [r3, #4]

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
  40081e:	6978      	ldr	r0, [r7, #20]
  400820:	4b22      	ldr	r3, [pc, #136]	; (4008ac <pvPortMalloc+0x19c>)
  400822:	4798      	blx	r3
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
  400824:	4b1f      	ldr	r3, [pc, #124]	; (4008a4 <pvPortMalloc+0x194>)
  400826:	681a      	ldr	r2, [r3, #0]
  400828:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40082a:	685b      	ldr	r3, [r3, #4]
  40082c:	1ad3      	subs	r3, r2, r3
  40082e:	4a1d      	ldr	r2, [pc, #116]	; (4008a4 <pvPortMalloc+0x194>)
  400830:	6013      	str	r3, [r2, #0]

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
  400832:	4b1c      	ldr	r3, [pc, #112]	; (4008a4 <pvPortMalloc+0x194>)
  400834:	681a      	ldr	r2, [r3, #0]
  400836:	4b1e      	ldr	r3, [pc, #120]	; (4008b0 <pvPortMalloc+0x1a0>)
  400838:	681b      	ldr	r3, [r3, #0]
  40083a:	429a      	cmp	r2, r3
  40083c:	d203      	bcs.n	400846 <pvPortMalloc+0x136>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
  40083e:	4b19      	ldr	r3, [pc, #100]	; (4008a4 <pvPortMalloc+0x194>)
  400840:	681b      	ldr	r3, [r3, #0]
  400842:	4a1b      	ldr	r2, [pc, #108]	; (4008b0 <pvPortMalloc+0x1a0>)
  400844:	6013      	str	r3, [r2, #0]
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
  400846:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  400848:	685a      	ldr	r2, [r3, #4]
  40084a:	4b15      	ldr	r3, [pc, #84]	; (4008a0 <pvPortMalloc+0x190>)
  40084c:	681b      	ldr	r3, [r3, #0]
  40084e:	431a      	orrs	r2, r3
  400850:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  400852:	605a      	str	r2, [r3, #4]
					pxBlock->pxNextFreeBlock = NULL;
  400854:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  400856:	2200      	movs	r2, #0
  400858:	601a      	str	r2, [r3, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
  40085a:	4b16      	ldr	r3, [pc, #88]	; (4008b4 <pvPortMalloc+0x1a4>)
  40085c:	4798      	blx	r3

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
  40085e:	69fb      	ldr	r3, [r7, #28]
  400860:	2b00      	cmp	r3, #0
  400862:	d101      	bne.n	400868 <pvPortMalloc+0x158>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
  400864:	4b14      	ldr	r3, [pc, #80]	; (4008b8 <pvPortMalloc+0x1a8>)
  400866:	4798      	blx	r3
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
  400868:	69fb      	ldr	r3, [r7, #28]
  40086a:	f003 0307 	and.w	r3, r3, #7
  40086e:	2b00      	cmp	r3, #0
  400870:	d00b      	beq.n	40088a <pvPortMalloc+0x17a>
  400872:	f04f 0380 	mov.w	r3, #128	; 0x80
  400876:	b672      	cpsid	i
  400878:	f383 8811 	msr	BASEPRI, r3
  40087c:	f3bf 8f6f 	isb	sy
  400880:	f3bf 8f4f 	dsb	sy
  400884:	b662      	cpsie	i
  400886:	613b      	str	r3, [r7, #16]
  400888:	e7fe      	b.n	400888 <pvPortMalloc+0x178>
	return pvReturn;
  40088a:	69fb      	ldr	r3, [r7, #28]
}
  40088c:	4618      	mov	r0, r3
  40088e:	3728      	adds	r7, #40	; 0x28
  400890:	46bd      	mov	sp, r7
  400892:	bd80      	pop	{r7, pc}
  400894:	00401c89 	.word	0x00401c89
  400898:	2040c0e4 	.word	0x2040c0e4
  40089c:	00400981 	.word	0x00400981
  4008a0:	2040c0f0 	.word	0x2040c0f0
  4008a4:	2040c0e8 	.word	0x2040c0e8
  4008a8:	2040c0dc 	.word	0x2040c0dc
  4008ac:	00400a45 	.word	0x00400a45
  4008b0:	2040c0ec 	.word	0x2040c0ec
  4008b4:	00401ca5 	.word	0x00401ca5
  4008b8:	00404361 	.word	0x00404361

004008bc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
  4008bc:	b580      	push	{r7, lr}
  4008be:	b086      	sub	sp, #24
  4008c0:	af00      	add	r7, sp, #0
  4008c2:	6078      	str	r0, [r7, #4]
uint8_t *puc = ( uint8_t * ) pv;
  4008c4:	687b      	ldr	r3, [r7, #4]
  4008c6:	617b      	str	r3, [r7, #20]
BlockLink_t *pxLink;

	if( pv != NULL )
  4008c8:	687b      	ldr	r3, [r7, #4]
  4008ca:	2b00      	cmp	r3, #0
  4008cc:	d04a      	beq.n	400964 <vPortFree+0xa8>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
  4008ce:	2308      	movs	r3, #8
  4008d0:	425b      	negs	r3, r3
  4008d2:	697a      	ldr	r2, [r7, #20]
  4008d4:	4413      	add	r3, r2
  4008d6:	617b      	str	r3, [r7, #20]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
  4008d8:	697b      	ldr	r3, [r7, #20]
  4008da:	613b      	str	r3, [r7, #16]

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
  4008dc:	693b      	ldr	r3, [r7, #16]
  4008de:	685a      	ldr	r2, [r3, #4]
  4008e0:	4b22      	ldr	r3, [pc, #136]	; (40096c <vPortFree+0xb0>)
  4008e2:	681b      	ldr	r3, [r3, #0]
  4008e4:	4013      	ands	r3, r2
  4008e6:	2b00      	cmp	r3, #0
  4008e8:	d10b      	bne.n	400902 <vPortFree+0x46>
  4008ea:	f04f 0380 	mov.w	r3, #128	; 0x80
  4008ee:	b672      	cpsid	i
  4008f0:	f383 8811 	msr	BASEPRI, r3
  4008f4:	f3bf 8f6f 	isb	sy
  4008f8:	f3bf 8f4f 	dsb	sy
  4008fc:	b662      	cpsie	i
  4008fe:	60bb      	str	r3, [r7, #8]
  400900:	e7fe      	b.n	400900 <vPortFree+0x44>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
  400902:	693b      	ldr	r3, [r7, #16]
  400904:	681b      	ldr	r3, [r3, #0]
  400906:	2b00      	cmp	r3, #0
  400908:	d00b      	beq.n	400922 <vPortFree+0x66>
  40090a:	f04f 0380 	mov.w	r3, #128	; 0x80
  40090e:	b672      	cpsid	i
  400910:	f383 8811 	msr	BASEPRI, r3
  400914:	f3bf 8f6f 	isb	sy
  400918:	f3bf 8f4f 	dsb	sy
  40091c:	b662      	cpsie	i
  40091e:	60fb      	str	r3, [r7, #12]
  400920:	e7fe      	b.n	400920 <vPortFree+0x64>

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
  400922:	693b      	ldr	r3, [r7, #16]
  400924:	685a      	ldr	r2, [r3, #4]
  400926:	4b11      	ldr	r3, [pc, #68]	; (40096c <vPortFree+0xb0>)
  400928:	681b      	ldr	r3, [r3, #0]
  40092a:	4013      	ands	r3, r2
  40092c:	2b00      	cmp	r3, #0
  40092e:	d019      	beq.n	400964 <vPortFree+0xa8>
		{
			if( pxLink->pxNextFreeBlock == NULL )
  400930:	693b      	ldr	r3, [r7, #16]
  400932:	681b      	ldr	r3, [r3, #0]
  400934:	2b00      	cmp	r3, #0
  400936:	d115      	bne.n	400964 <vPortFree+0xa8>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
  400938:	693b      	ldr	r3, [r7, #16]
  40093a:	685a      	ldr	r2, [r3, #4]
  40093c:	4b0b      	ldr	r3, [pc, #44]	; (40096c <vPortFree+0xb0>)
  40093e:	681b      	ldr	r3, [r3, #0]
  400940:	43db      	mvns	r3, r3
  400942:	401a      	ands	r2, r3
  400944:	693b      	ldr	r3, [r7, #16]
  400946:	605a      	str	r2, [r3, #4]

				vTaskSuspendAll();
  400948:	4b09      	ldr	r3, [pc, #36]	; (400970 <vPortFree+0xb4>)
  40094a:	4798      	blx	r3
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
  40094c:	693b      	ldr	r3, [r7, #16]
  40094e:	685a      	ldr	r2, [r3, #4]
  400950:	4b08      	ldr	r3, [pc, #32]	; (400974 <vPortFree+0xb8>)
  400952:	681b      	ldr	r3, [r3, #0]
  400954:	4413      	add	r3, r2
  400956:	4a07      	ldr	r2, [pc, #28]	; (400974 <vPortFree+0xb8>)
  400958:	6013      	str	r3, [r2, #0]
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
  40095a:	6938      	ldr	r0, [r7, #16]
  40095c:	4b06      	ldr	r3, [pc, #24]	; (400978 <vPortFree+0xbc>)
  40095e:	4798      	blx	r3
				}
				( void ) xTaskResumeAll();
  400960:	4b06      	ldr	r3, [pc, #24]	; (40097c <vPortFree+0xc0>)
  400962:	4798      	blx	r3
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
  400964:	bf00      	nop
  400966:	3718      	adds	r7, #24
  400968:	46bd      	mov	sp, r7
  40096a:	bd80      	pop	{r7, pc}
  40096c:	2040c0f0 	.word	0x2040c0f0
  400970:	00401c89 	.word	0x00401c89
  400974:	2040c0e8 	.word	0x2040c0e8
  400978:	00400a45 	.word	0x00400a45
  40097c:	00401ca5 	.word	0x00401ca5

00400980 <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
  400980:	b480      	push	{r7}
  400982:	b085      	sub	sp, #20
  400984:	af00      	add	r7, sp, #0
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
  400986:	f44f 4338 	mov.w	r3, #47104	; 0xb800
  40098a:	60bb      	str	r3, [r7, #8]

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
  40098c:	4b27      	ldr	r3, [pc, #156]	; (400a2c <prvHeapInit+0xac>)
  40098e:	60fb      	str	r3, [r7, #12]

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
  400990:	68fb      	ldr	r3, [r7, #12]
  400992:	f003 0307 	and.w	r3, r3, #7
  400996:	2b00      	cmp	r3, #0
  400998:	d00c      	beq.n	4009b4 <prvHeapInit+0x34>
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
  40099a:	68fb      	ldr	r3, [r7, #12]
  40099c:	3307      	adds	r3, #7
  40099e:	60fb      	str	r3, [r7, #12]
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
  4009a0:	68fb      	ldr	r3, [r7, #12]
  4009a2:	f023 0307 	bic.w	r3, r3, #7
  4009a6:	60fb      	str	r3, [r7, #12]
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
  4009a8:	68ba      	ldr	r2, [r7, #8]
  4009aa:	68fb      	ldr	r3, [r7, #12]
  4009ac:	1ad3      	subs	r3, r2, r3
  4009ae:	4a1f      	ldr	r2, [pc, #124]	; (400a2c <prvHeapInit+0xac>)
  4009b0:	4413      	add	r3, r2
  4009b2:	60bb      	str	r3, [r7, #8]
	}

	pucAlignedHeap = ( uint8_t * ) uxAddress;
  4009b4:	68fb      	ldr	r3, [r7, #12]
  4009b6:	607b      	str	r3, [r7, #4]

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
  4009b8:	4a1d      	ldr	r2, [pc, #116]	; (400a30 <prvHeapInit+0xb0>)
  4009ba:	687b      	ldr	r3, [r7, #4]
  4009bc:	6013      	str	r3, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
  4009be:	4b1c      	ldr	r3, [pc, #112]	; (400a30 <prvHeapInit+0xb0>)
  4009c0:	2200      	movs	r2, #0
  4009c2:	605a      	str	r2, [r3, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
  4009c4:	687a      	ldr	r2, [r7, #4]
  4009c6:	68bb      	ldr	r3, [r7, #8]
  4009c8:	4413      	add	r3, r2
  4009ca:	60fb      	str	r3, [r7, #12]
	uxAddress -= xHeapStructSize;
  4009cc:	2208      	movs	r2, #8
  4009ce:	68fb      	ldr	r3, [r7, #12]
  4009d0:	1a9b      	subs	r3, r3, r2
  4009d2:	60fb      	str	r3, [r7, #12]
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
  4009d4:	68fb      	ldr	r3, [r7, #12]
  4009d6:	f023 0307 	bic.w	r3, r3, #7
  4009da:	60fb      	str	r3, [r7, #12]
	pxEnd = ( void * ) uxAddress;
  4009dc:	68fb      	ldr	r3, [r7, #12]
  4009de:	4a15      	ldr	r2, [pc, #84]	; (400a34 <prvHeapInit+0xb4>)
  4009e0:	6013      	str	r3, [r2, #0]
	pxEnd->xBlockSize = 0;
  4009e2:	4b14      	ldr	r3, [pc, #80]	; (400a34 <prvHeapInit+0xb4>)
  4009e4:	681b      	ldr	r3, [r3, #0]
  4009e6:	2200      	movs	r2, #0
  4009e8:	605a      	str	r2, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
  4009ea:	4b12      	ldr	r3, [pc, #72]	; (400a34 <prvHeapInit+0xb4>)
  4009ec:	681b      	ldr	r3, [r3, #0]
  4009ee:	2200      	movs	r2, #0
  4009f0:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
  4009f2:	687b      	ldr	r3, [r7, #4]
  4009f4:	603b      	str	r3, [r7, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
  4009f6:	683b      	ldr	r3, [r7, #0]
  4009f8:	68fa      	ldr	r2, [r7, #12]
  4009fa:	1ad2      	subs	r2, r2, r3
  4009fc:	683b      	ldr	r3, [r7, #0]
  4009fe:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
  400a00:	4b0c      	ldr	r3, [pc, #48]	; (400a34 <prvHeapInit+0xb4>)
  400a02:	681a      	ldr	r2, [r3, #0]
  400a04:	683b      	ldr	r3, [r7, #0]
  400a06:	601a      	str	r2, [r3, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
  400a08:	683b      	ldr	r3, [r7, #0]
  400a0a:	685b      	ldr	r3, [r3, #4]
  400a0c:	4a0a      	ldr	r2, [pc, #40]	; (400a38 <prvHeapInit+0xb8>)
  400a0e:	6013      	str	r3, [r2, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
  400a10:	683b      	ldr	r3, [r7, #0]
  400a12:	685b      	ldr	r3, [r3, #4]
  400a14:	4a09      	ldr	r2, [pc, #36]	; (400a3c <prvHeapInit+0xbc>)
  400a16:	6013      	str	r3, [r2, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
  400a18:	4b09      	ldr	r3, [pc, #36]	; (400a40 <prvHeapInit+0xc0>)
  400a1a:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
  400a1e:	601a      	str	r2, [r3, #0]
}
  400a20:	bf00      	nop
  400a22:	3714      	adds	r7, #20
  400a24:	46bd      	mov	sp, r7
  400a26:	f85d 7b04 	ldr.w	r7, [sp], #4
  400a2a:	4770      	bx	lr
  400a2c:	204008dc 	.word	0x204008dc
  400a30:	2040c0dc 	.word	0x2040c0dc
  400a34:	2040c0e4 	.word	0x2040c0e4
  400a38:	2040c0ec 	.word	0x2040c0ec
  400a3c:	2040c0e8 	.word	0x2040c0e8
  400a40:	2040c0f0 	.word	0x2040c0f0

00400a44 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
  400a44:	b480      	push	{r7}
  400a46:	b085      	sub	sp, #20
  400a48:	af00      	add	r7, sp, #0
  400a4a:	6078      	str	r0, [r7, #4]
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
  400a4c:	4b28      	ldr	r3, [pc, #160]	; (400af0 <prvInsertBlockIntoFreeList+0xac>)
  400a4e:	60fb      	str	r3, [r7, #12]
  400a50:	e002      	b.n	400a58 <prvInsertBlockIntoFreeList+0x14>
  400a52:	68fb      	ldr	r3, [r7, #12]
  400a54:	681b      	ldr	r3, [r3, #0]
  400a56:	60fb      	str	r3, [r7, #12]
  400a58:	68fb      	ldr	r3, [r7, #12]
  400a5a:	681a      	ldr	r2, [r3, #0]
  400a5c:	687b      	ldr	r3, [r7, #4]
  400a5e:	429a      	cmp	r2, r3
  400a60:	d3f7      	bcc.n	400a52 <prvInsertBlockIntoFreeList+0xe>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
  400a62:	68fb      	ldr	r3, [r7, #12]
  400a64:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
  400a66:	68fb      	ldr	r3, [r7, #12]
  400a68:	685b      	ldr	r3, [r3, #4]
  400a6a:	68ba      	ldr	r2, [r7, #8]
  400a6c:	441a      	add	r2, r3
  400a6e:	687b      	ldr	r3, [r7, #4]
  400a70:	429a      	cmp	r2, r3
  400a72:	d108      	bne.n	400a86 <prvInsertBlockIntoFreeList+0x42>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
  400a74:	68fb      	ldr	r3, [r7, #12]
  400a76:	685a      	ldr	r2, [r3, #4]
  400a78:	687b      	ldr	r3, [r7, #4]
  400a7a:	685b      	ldr	r3, [r3, #4]
  400a7c:	441a      	add	r2, r3
  400a7e:	68fb      	ldr	r3, [r7, #12]
  400a80:	605a      	str	r2, [r3, #4]
		pxBlockToInsert = pxIterator;
  400a82:	68fb      	ldr	r3, [r7, #12]
  400a84:	607b      	str	r3, [r7, #4]
		mtCOVERAGE_TEST_MARKER();
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
  400a86:	687b      	ldr	r3, [r7, #4]
  400a88:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
  400a8a:	687b      	ldr	r3, [r7, #4]
  400a8c:	685b      	ldr	r3, [r3, #4]
  400a8e:	68ba      	ldr	r2, [r7, #8]
  400a90:	441a      	add	r2, r3
  400a92:	68fb      	ldr	r3, [r7, #12]
  400a94:	681b      	ldr	r3, [r3, #0]
  400a96:	429a      	cmp	r2, r3
  400a98:	d118      	bne.n	400acc <prvInsertBlockIntoFreeList+0x88>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
  400a9a:	68fb      	ldr	r3, [r7, #12]
  400a9c:	681a      	ldr	r2, [r3, #0]
  400a9e:	4b15      	ldr	r3, [pc, #84]	; (400af4 <prvInsertBlockIntoFreeList+0xb0>)
  400aa0:	681b      	ldr	r3, [r3, #0]
  400aa2:	429a      	cmp	r2, r3
  400aa4:	d00d      	beq.n	400ac2 <prvInsertBlockIntoFreeList+0x7e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
  400aa6:	687b      	ldr	r3, [r7, #4]
  400aa8:	685a      	ldr	r2, [r3, #4]
  400aaa:	68fb      	ldr	r3, [r7, #12]
  400aac:	681b      	ldr	r3, [r3, #0]
  400aae:	685b      	ldr	r3, [r3, #4]
  400ab0:	441a      	add	r2, r3
  400ab2:	687b      	ldr	r3, [r7, #4]
  400ab4:	605a      	str	r2, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
  400ab6:	68fb      	ldr	r3, [r7, #12]
  400ab8:	681b      	ldr	r3, [r3, #0]
  400aba:	681a      	ldr	r2, [r3, #0]
  400abc:	687b      	ldr	r3, [r7, #4]
  400abe:	601a      	str	r2, [r3, #0]
  400ac0:	e008      	b.n	400ad4 <prvInsertBlockIntoFreeList+0x90>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
  400ac2:	4b0c      	ldr	r3, [pc, #48]	; (400af4 <prvInsertBlockIntoFreeList+0xb0>)
  400ac4:	681a      	ldr	r2, [r3, #0]
  400ac6:	687b      	ldr	r3, [r7, #4]
  400ac8:	601a      	str	r2, [r3, #0]
  400aca:	e003      	b.n	400ad4 <prvInsertBlockIntoFreeList+0x90>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
  400acc:	68fb      	ldr	r3, [r7, #12]
  400ace:	681a      	ldr	r2, [r3, #0]
  400ad0:	687b      	ldr	r3, [r7, #4]
  400ad2:	601a      	str	r2, [r3, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
  400ad4:	68fa      	ldr	r2, [r7, #12]
  400ad6:	687b      	ldr	r3, [r7, #4]
  400ad8:	429a      	cmp	r2, r3
  400ada:	d002      	beq.n	400ae2 <prvInsertBlockIntoFreeList+0x9e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
  400adc:	68fb      	ldr	r3, [r7, #12]
  400ade:	687a      	ldr	r2, [r7, #4]
  400ae0:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
  400ae2:	bf00      	nop
  400ae4:	3714      	adds	r7, #20
  400ae6:	46bd      	mov	sp, r7
  400ae8:	f85d 7b04 	ldr.w	r7, [sp], #4
  400aec:	4770      	bx	lr
  400aee:	bf00      	nop
  400af0:	2040c0dc 	.word	0x2040c0dc
  400af4:	2040c0e4 	.word	0x2040c0e4

00400af8 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
  400af8:	b580      	push	{r7, lr}
  400afa:	b084      	sub	sp, #16
  400afc:	af00      	add	r7, sp, #0
  400afe:	6078      	str	r0, [r7, #4]
  400b00:	6039      	str	r1, [r7, #0]
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  400b02:	687b      	ldr	r3, [r7, #4]
  400b04:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
  400b06:	68fb      	ldr	r3, [r7, #12]
  400b08:	2b00      	cmp	r3, #0
  400b0a:	d10b      	bne.n	400b24 <xQueueGenericReset+0x2c>
  400b0c:	f04f 0380 	mov.w	r3, #128	; 0x80
  400b10:	b672      	cpsid	i
  400b12:	f383 8811 	msr	BASEPRI, r3
  400b16:	f3bf 8f6f 	isb	sy
  400b1a:	f3bf 8f4f 	dsb	sy
  400b1e:	b662      	cpsie	i
  400b20:	60bb      	str	r3, [r7, #8]
  400b22:	e7fe      	b.n	400b22 <xQueueGenericReset+0x2a>

	taskENTER_CRITICAL();
  400b24:	4b28      	ldr	r3, [pc, #160]	; (400bc8 <xQueueGenericReset+0xd0>)
  400b26:	4798      	blx	r3
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  400b28:	68fb      	ldr	r3, [r7, #12]
  400b2a:	681a      	ldr	r2, [r3, #0]
  400b2c:	68fb      	ldr	r3, [r7, #12]
  400b2e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  400b30:	68f9      	ldr	r1, [r7, #12]
  400b32:	6c09      	ldr	r1, [r1, #64]	; 0x40
  400b34:	fb01 f303 	mul.w	r3, r1, r3
  400b38:	441a      	add	r2, r3
  400b3a:	68fb      	ldr	r3, [r7, #12]
  400b3c:	605a      	str	r2, [r3, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  400b3e:	68fb      	ldr	r3, [r7, #12]
  400b40:	2200      	movs	r2, #0
  400b42:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
  400b44:	68fb      	ldr	r3, [r7, #12]
  400b46:	681a      	ldr	r2, [r3, #0]
  400b48:	68fb      	ldr	r3, [r7, #12]
  400b4a:	609a      	str	r2, [r3, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
  400b4c:	68fb      	ldr	r3, [r7, #12]
  400b4e:	681a      	ldr	r2, [r3, #0]
  400b50:	68fb      	ldr	r3, [r7, #12]
  400b52:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  400b54:	3b01      	subs	r3, #1
  400b56:	68f9      	ldr	r1, [r7, #12]
  400b58:	6c09      	ldr	r1, [r1, #64]	; 0x40
  400b5a:	fb01 f303 	mul.w	r3, r1, r3
  400b5e:	441a      	add	r2, r3
  400b60:	68fb      	ldr	r3, [r7, #12]
  400b62:	60da      	str	r2, [r3, #12]
		pxQueue->cRxLock = queueUNLOCKED;
  400b64:	68fb      	ldr	r3, [r7, #12]
  400b66:	22ff      	movs	r2, #255	; 0xff
  400b68:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
  400b6c:	68fb      	ldr	r3, [r7, #12]
  400b6e:	22ff      	movs	r2, #255	; 0xff
  400b70:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

		if( xNewQueue == pdFALSE )
  400b74:	683b      	ldr	r3, [r7, #0]
  400b76:	2b00      	cmp	r3, #0
  400b78:	d114      	bne.n	400ba4 <xQueueGenericReset+0xac>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  400b7a:	68fb      	ldr	r3, [r7, #12]
  400b7c:	691b      	ldr	r3, [r3, #16]
  400b7e:	2b00      	cmp	r3, #0
  400b80:	d01a      	beq.n	400bb8 <xQueueGenericReset+0xc0>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  400b82:	68fb      	ldr	r3, [r7, #12]
  400b84:	3310      	adds	r3, #16
  400b86:	4618      	mov	r0, r3
  400b88:	4b10      	ldr	r3, [pc, #64]	; (400bcc <xQueueGenericReset+0xd4>)
  400b8a:	4798      	blx	r3
  400b8c:	4603      	mov	r3, r0
  400b8e:	2b00      	cmp	r3, #0
  400b90:	d012      	beq.n	400bb8 <xQueueGenericReset+0xc0>
				{
					queueYIELD_IF_USING_PREEMPTION();
  400b92:	4b0f      	ldr	r3, [pc, #60]	; (400bd0 <xQueueGenericReset+0xd8>)
  400b94:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  400b98:	601a      	str	r2, [r3, #0]
  400b9a:	f3bf 8f4f 	dsb	sy
  400b9e:	f3bf 8f6f 	isb	sy
  400ba2:	e009      	b.n	400bb8 <xQueueGenericReset+0xc0>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
  400ba4:	68fb      	ldr	r3, [r7, #12]
  400ba6:	3310      	adds	r3, #16
  400ba8:	4618      	mov	r0, r3
  400baa:	4b0a      	ldr	r3, [pc, #40]	; (400bd4 <xQueueGenericReset+0xdc>)
  400bac:	4798      	blx	r3
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
  400bae:	68fb      	ldr	r3, [r7, #12]
  400bb0:	3324      	adds	r3, #36	; 0x24
  400bb2:	4618      	mov	r0, r3
  400bb4:	4b07      	ldr	r3, [pc, #28]	; (400bd4 <xQueueGenericReset+0xdc>)
  400bb6:	4798      	blx	r3
		}
	}
	taskEXIT_CRITICAL();
  400bb8:	4b07      	ldr	r3, [pc, #28]	; (400bd8 <xQueueGenericReset+0xe0>)
  400bba:	4798      	blx	r3

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
  400bbc:	2301      	movs	r3, #1
}
  400bbe:	4618      	mov	r0, r3
  400bc0:	3710      	adds	r7, #16
  400bc2:	46bd      	mov	sp, r7
  400bc4:	bd80      	pop	{r7, pc}
  400bc6:	bf00      	nop
  400bc8:	004004e9 	.word	0x004004e9
  400bcc:	00402171 	.word	0x00402171
  400bd0:	e000ed04 	.word	0xe000ed04
  400bd4:	0040019d 	.word	0x0040019d
  400bd8:	0040054d 	.word	0x0040054d

00400bdc <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
  400bdc:	b590      	push	{r4, r7, lr}
  400bde:	b08b      	sub	sp, #44	; 0x2c
  400be0:	af02      	add	r7, sp, #8
  400be2:	60f8      	str	r0, [r7, #12]
  400be4:	60b9      	str	r1, [r7, #8]
  400be6:	4613      	mov	r3, r2
  400be8:	71fb      	strb	r3, [r7, #7]
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
  400bea:	68fb      	ldr	r3, [r7, #12]
  400bec:	2b00      	cmp	r3, #0
  400bee:	d10b      	bne.n	400c08 <xQueueGenericCreate+0x2c>
  400bf0:	f04f 0380 	mov.w	r3, #128	; 0x80
  400bf4:	b672      	cpsid	i
  400bf6:	f383 8811 	msr	BASEPRI, r3
  400bfa:	f3bf 8f6f 	isb	sy
  400bfe:	f3bf 8f4f 	dsb	sy
  400c02:	b662      	cpsie	i
  400c04:	613b      	str	r3, [r7, #16]
  400c06:	e7fe      	b.n	400c06 <xQueueGenericCreate+0x2a>

		if( uxItemSize == ( UBaseType_t ) 0 )
  400c08:	68bb      	ldr	r3, [r7, #8]
  400c0a:	2b00      	cmp	r3, #0
  400c0c:	d102      	bne.n	400c14 <xQueueGenericCreate+0x38>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
  400c0e:	2300      	movs	r3, #0
  400c10:	61fb      	str	r3, [r7, #28]
  400c12:	e004      	b.n	400c1e <xQueueGenericCreate+0x42>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  400c14:	68fb      	ldr	r3, [r7, #12]
  400c16:	68ba      	ldr	r2, [r7, #8]
  400c18:	fb02 f303 	mul.w	r3, r2, r3
  400c1c:	61fb      	str	r3, [r7, #28]
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
  400c1e:	69fb      	ldr	r3, [r7, #28]
  400c20:	3354      	adds	r3, #84	; 0x54
  400c22:	4618      	mov	r0, r3
  400c24:	4b0b      	ldr	r3, [pc, #44]	; (400c54 <xQueueGenericCreate+0x78>)
  400c26:	4798      	blx	r3
  400c28:	61b8      	str	r0, [r7, #24]

		if( pxNewQueue != NULL )
  400c2a:	69bb      	ldr	r3, [r7, #24]
  400c2c:	2b00      	cmp	r3, #0
  400c2e:	d00b      	beq.n	400c48 <xQueueGenericCreate+0x6c>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
  400c30:	69bb      	ldr	r3, [r7, #24]
  400c32:	3354      	adds	r3, #84	; 0x54
  400c34:	617b      	str	r3, [r7, #20]
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
  400c36:	79fa      	ldrb	r2, [r7, #7]
  400c38:	69bb      	ldr	r3, [r7, #24]
  400c3a:	9300      	str	r3, [sp, #0]
  400c3c:	4613      	mov	r3, r2
  400c3e:	697a      	ldr	r2, [r7, #20]
  400c40:	68b9      	ldr	r1, [r7, #8]
  400c42:	68f8      	ldr	r0, [r7, #12]
  400c44:	4c04      	ldr	r4, [pc, #16]	; (400c58 <xQueueGenericCreate+0x7c>)
  400c46:	47a0      	blx	r4
		}

		return pxNewQueue;
  400c48:	69bb      	ldr	r3, [r7, #24]
	}
  400c4a:	4618      	mov	r0, r3
  400c4c:	3724      	adds	r7, #36	; 0x24
  400c4e:	46bd      	mov	sp, r7
  400c50:	bd90      	pop	{r4, r7, pc}
  400c52:	bf00      	nop
  400c54:	00400711 	.word	0x00400711
  400c58:	00400c5d 	.word	0x00400c5d

00400c5c <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
  400c5c:	b580      	push	{r7, lr}
  400c5e:	b084      	sub	sp, #16
  400c60:	af00      	add	r7, sp, #0
  400c62:	60f8      	str	r0, [r7, #12]
  400c64:	60b9      	str	r1, [r7, #8]
  400c66:	607a      	str	r2, [r7, #4]
  400c68:	70fb      	strb	r3, [r7, #3]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
  400c6a:	68bb      	ldr	r3, [r7, #8]
  400c6c:	2b00      	cmp	r3, #0
  400c6e:	d103      	bne.n	400c78 <prvInitialiseNewQueue+0x1c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
  400c70:	69bb      	ldr	r3, [r7, #24]
  400c72:	69ba      	ldr	r2, [r7, #24]
  400c74:	601a      	str	r2, [r3, #0]
  400c76:	e002      	b.n	400c7e <prvInitialiseNewQueue+0x22>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
  400c78:	69bb      	ldr	r3, [r7, #24]
  400c7a:	687a      	ldr	r2, [r7, #4]
  400c7c:	601a      	str	r2, [r3, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
  400c7e:	69bb      	ldr	r3, [r7, #24]
  400c80:	68fa      	ldr	r2, [r7, #12]
  400c82:	63da      	str	r2, [r3, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
  400c84:	69bb      	ldr	r3, [r7, #24]
  400c86:	68ba      	ldr	r2, [r7, #8]
  400c88:	641a      	str	r2, [r3, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
  400c8a:	2101      	movs	r1, #1
  400c8c:	69b8      	ldr	r0, [r7, #24]
  400c8e:	4b06      	ldr	r3, [pc, #24]	; (400ca8 <prvInitialiseNewQueue+0x4c>)
  400c90:	4798      	blx	r3

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
  400c92:	69bb      	ldr	r3, [r7, #24]
  400c94:	78fa      	ldrb	r2, [r7, #3]
  400c96:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
	}
	#endif /* configUSE_TRACE_FACILITY */

	#if( configUSE_QUEUE_SETS == 1 )
	{
		pxNewQueue->pxQueueSetContainer = NULL;
  400c9a:	69bb      	ldr	r3, [r7, #24]
  400c9c:	2200      	movs	r2, #0
  400c9e:	649a      	str	r2, [r3, #72]	; 0x48
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
  400ca0:	bf00      	nop
  400ca2:	3710      	adds	r7, #16
  400ca4:	46bd      	mov	sp, r7
  400ca6:	bd80      	pop	{r7, pc}
  400ca8:	00400af9 	.word	0x00400af9

00400cac <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
  400cac:	b580      	push	{r7, lr}
  400cae:	b08e      	sub	sp, #56	; 0x38
  400cb0:	af00      	add	r7, sp, #0
  400cb2:	60f8      	str	r0, [r7, #12]
  400cb4:	60b9      	str	r1, [r7, #8]
  400cb6:	607a      	str	r2, [r7, #4]
  400cb8:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
  400cba:	2300      	movs	r3, #0
  400cbc:	637b      	str	r3, [r7, #52]	; 0x34
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  400cbe:	68fb      	ldr	r3, [r7, #12]
  400cc0:	633b      	str	r3, [r7, #48]	; 0x30

	configASSERT( pxQueue );
  400cc2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  400cc4:	2b00      	cmp	r3, #0
  400cc6:	d10b      	bne.n	400ce0 <xQueueGenericSend+0x34>
  400cc8:	f04f 0380 	mov.w	r3, #128	; 0x80
  400ccc:	b672      	cpsid	i
  400cce:	f383 8811 	msr	BASEPRI, r3
  400cd2:	f3bf 8f6f 	isb	sy
  400cd6:	f3bf 8f4f 	dsb	sy
  400cda:	b662      	cpsie	i
  400cdc:	61fb      	str	r3, [r7, #28]
  400cde:	e7fe      	b.n	400cde <xQueueGenericSend+0x32>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  400ce0:	68bb      	ldr	r3, [r7, #8]
  400ce2:	2b00      	cmp	r3, #0
  400ce4:	d103      	bne.n	400cee <xQueueGenericSend+0x42>
  400ce6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  400ce8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  400cea:	2b00      	cmp	r3, #0
  400cec:	d101      	bne.n	400cf2 <xQueueGenericSend+0x46>
  400cee:	2301      	movs	r3, #1
  400cf0:	e000      	b.n	400cf4 <xQueueGenericSend+0x48>
  400cf2:	2300      	movs	r3, #0
  400cf4:	2b00      	cmp	r3, #0
  400cf6:	d10b      	bne.n	400d10 <xQueueGenericSend+0x64>
  400cf8:	f04f 0380 	mov.w	r3, #128	; 0x80
  400cfc:	b672      	cpsid	i
  400cfe:	f383 8811 	msr	BASEPRI, r3
  400d02:	f3bf 8f6f 	isb	sy
  400d06:	f3bf 8f4f 	dsb	sy
  400d0a:	b662      	cpsie	i
  400d0c:	623b      	str	r3, [r7, #32]
  400d0e:	e7fe      	b.n	400d0e <xQueueGenericSend+0x62>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  400d10:	683b      	ldr	r3, [r7, #0]
  400d12:	2b02      	cmp	r3, #2
  400d14:	d103      	bne.n	400d1e <xQueueGenericSend+0x72>
  400d16:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  400d18:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  400d1a:	2b01      	cmp	r3, #1
  400d1c:	d101      	bne.n	400d22 <xQueueGenericSend+0x76>
  400d1e:	2301      	movs	r3, #1
  400d20:	e000      	b.n	400d24 <xQueueGenericSend+0x78>
  400d22:	2300      	movs	r3, #0
  400d24:	2b00      	cmp	r3, #0
  400d26:	d10b      	bne.n	400d40 <xQueueGenericSend+0x94>
  400d28:	f04f 0380 	mov.w	r3, #128	; 0x80
  400d2c:	b672      	cpsid	i
  400d2e:	f383 8811 	msr	BASEPRI, r3
  400d32:	f3bf 8f6f 	isb	sy
  400d36:	f3bf 8f4f 	dsb	sy
  400d3a:	b662      	cpsie	i
  400d3c:	627b      	str	r3, [r7, #36]	; 0x24
  400d3e:	e7fe      	b.n	400d3e <xQueueGenericSend+0x92>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
  400d40:	4b64      	ldr	r3, [pc, #400]	; (400ed4 <xQueueGenericSend+0x228>)
  400d42:	4798      	blx	r3
  400d44:	4603      	mov	r3, r0
  400d46:	2b00      	cmp	r3, #0
  400d48:	d102      	bne.n	400d50 <xQueueGenericSend+0xa4>
  400d4a:	687b      	ldr	r3, [r7, #4]
  400d4c:	2b00      	cmp	r3, #0
  400d4e:	d101      	bne.n	400d54 <xQueueGenericSend+0xa8>
  400d50:	2301      	movs	r3, #1
  400d52:	e000      	b.n	400d56 <xQueueGenericSend+0xaa>
  400d54:	2300      	movs	r3, #0
  400d56:	2b00      	cmp	r3, #0
  400d58:	d10b      	bne.n	400d72 <xQueueGenericSend+0xc6>
  400d5a:	f04f 0380 	mov.w	r3, #128	; 0x80
  400d5e:	b672      	cpsid	i
  400d60:	f383 8811 	msr	BASEPRI, r3
  400d64:	f3bf 8f6f 	isb	sy
  400d68:	f3bf 8f4f 	dsb	sy
  400d6c:	b662      	cpsie	i
  400d6e:	62bb      	str	r3, [r7, #40]	; 0x28
  400d70:	e7fe      	b.n	400d70 <xQueueGenericSend+0xc4>
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  400d72:	4b59      	ldr	r3, [pc, #356]	; (400ed8 <xQueueGenericSend+0x22c>)
  400d74:	4798      	blx	r3
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  400d76:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  400d78:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  400d7a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  400d7c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  400d7e:	429a      	cmp	r2, r3
  400d80:	d302      	bcc.n	400d88 <xQueueGenericSend+0xdc>
  400d82:	683b      	ldr	r3, [r7, #0]
  400d84:	2b02      	cmp	r3, #2
  400d86:	d13d      	bne.n	400e04 <xQueueGenericSend+0x158>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  400d88:	683a      	ldr	r2, [r7, #0]
  400d8a:	68b9      	ldr	r1, [r7, #8]
  400d8c:	6b38      	ldr	r0, [r7, #48]	; 0x30
  400d8e:	4b53      	ldr	r3, [pc, #332]	; (400edc <xQueueGenericSend+0x230>)
  400d90:	4798      	blx	r3
  400d92:	62f8      	str	r0, [r7, #44]	; 0x2c

				#if ( configUSE_QUEUE_SETS == 1 )
				{
					if( pxQueue->pxQueueSetContainer != NULL )
  400d94:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  400d96:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  400d98:	2b00      	cmp	r3, #0
  400d9a:	d00f      	beq.n	400dbc <xQueueGenericSend+0x110>
					{
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
  400d9c:	6839      	ldr	r1, [r7, #0]
  400d9e:	6b38      	ldr	r0, [r7, #48]	; 0x30
  400da0:	4b4f      	ldr	r3, [pc, #316]	; (400ee0 <xQueueGenericSend+0x234>)
  400da2:	4798      	blx	r3
  400da4:	4603      	mov	r3, r0
  400da6:	2b00      	cmp	r3, #0
  400da8:	d028      	beq.n	400dfc <xQueueGenericSend+0x150>
						{
							/* The queue is a member of a queue set, and posting
							to the queue set caused a higher priority task to
							unblock. A context switch is required. */
							queueYIELD_IF_USING_PREEMPTION();
  400daa:	4b4e      	ldr	r3, [pc, #312]	; (400ee4 <xQueueGenericSend+0x238>)
  400dac:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  400db0:	601a      	str	r2, [r3, #0]
  400db2:	f3bf 8f4f 	dsb	sy
  400db6:	f3bf 8f6f 	isb	sy
  400dba:	e01f      	b.n	400dfc <xQueueGenericSend+0x150>
					}
					else
					{
						/* If there was a task waiting for data to arrive on the
						queue then unblock it now. */
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  400dbc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  400dbe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  400dc0:	2b00      	cmp	r3, #0
  400dc2:	d010      	beq.n	400de6 <xQueueGenericSend+0x13a>
						{
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  400dc4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  400dc6:	3324      	adds	r3, #36	; 0x24
  400dc8:	4618      	mov	r0, r3
  400dca:	4b47      	ldr	r3, [pc, #284]	; (400ee8 <xQueueGenericSend+0x23c>)
  400dcc:	4798      	blx	r3
  400dce:	4603      	mov	r3, r0
  400dd0:	2b00      	cmp	r3, #0
  400dd2:	d013      	beq.n	400dfc <xQueueGenericSend+0x150>
							{
								/* The unblocked task has a priority higher than
								our own so yield immediately.  Yes it is ok to
								do this from within the critical section - the
								kernel takes care of that. */
								queueYIELD_IF_USING_PREEMPTION();
  400dd4:	4b43      	ldr	r3, [pc, #268]	; (400ee4 <xQueueGenericSend+0x238>)
  400dd6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  400dda:	601a      	str	r2, [r3, #0]
  400ddc:	f3bf 8f4f 	dsb	sy
  400de0:	f3bf 8f6f 	isb	sy
  400de4:	e00a      	b.n	400dfc <xQueueGenericSend+0x150>
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
						}
						else if( xYieldRequired != pdFALSE )
  400de6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  400de8:	2b00      	cmp	r3, #0
  400dea:	d007      	beq.n	400dfc <xQueueGenericSend+0x150>
						{
							/* This path is a special case that will only get
							executed if the task was holding multiple mutexes
							and the mutexes were given back in an order that is
							different to that in which they were taken. */
							queueYIELD_IF_USING_PREEMPTION();
  400dec:	4b3d      	ldr	r3, [pc, #244]	; (400ee4 <xQueueGenericSend+0x238>)
  400dee:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  400df2:	601a      	str	r2, [r3, #0]
  400df4:	f3bf 8f4f 	dsb	sy
  400df8:	f3bf 8f6f 	isb	sy
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
  400dfc:	4b3b      	ldr	r3, [pc, #236]	; (400eec <xQueueGenericSend+0x240>)
  400dfe:	4798      	blx	r3
				return pdPASS;
  400e00:	2301      	movs	r3, #1
  400e02:	e063      	b.n	400ecc <xQueueGenericSend+0x220>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
  400e04:	687b      	ldr	r3, [r7, #4]
  400e06:	2b00      	cmp	r3, #0
  400e08:	d103      	bne.n	400e12 <xQueueGenericSend+0x166>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  400e0a:	4b38      	ldr	r3, [pc, #224]	; (400eec <xQueueGenericSend+0x240>)
  400e0c:	4798      	blx	r3

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
  400e0e:	2300      	movs	r3, #0
  400e10:	e05c      	b.n	400ecc <xQueueGenericSend+0x220>
				}
				else if( xEntryTimeSet == pdFALSE )
  400e12:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  400e14:	2b00      	cmp	r3, #0
  400e16:	d106      	bne.n	400e26 <xQueueGenericSend+0x17a>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  400e18:	f107 0314 	add.w	r3, r7, #20
  400e1c:	4618      	mov	r0, r3
  400e1e:	4b34      	ldr	r3, [pc, #208]	; (400ef0 <xQueueGenericSend+0x244>)
  400e20:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
  400e22:	2301      	movs	r3, #1
  400e24:	637b      	str	r3, [r7, #52]	; 0x34
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
  400e26:	4b31      	ldr	r3, [pc, #196]	; (400eec <xQueueGenericSend+0x240>)
  400e28:	4798      	blx	r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  400e2a:	4b32      	ldr	r3, [pc, #200]	; (400ef4 <xQueueGenericSend+0x248>)
  400e2c:	4798      	blx	r3
		prvLockQueue( pxQueue );
  400e2e:	4b2a      	ldr	r3, [pc, #168]	; (400ed8 <xQueueGenericSend+0x22c>)
  400e30:	4798      	blx	r3
  400e32:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  400e34:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
  400e38:	b25b      	sxtb	r3, r3
  400e3a:	f1b3 3fff 	cmp.w	r3, #4294967295
  400e3e:	d103      	bne.n	400e48 <xQueueGenericSend+0x19c>
  400e40:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  400e42:	2200      	movs	r2, #0
  400e44:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  400e48:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  400e4a:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
  400e4e:	b25b      	sxtb	r3, r3
  400e50:	f1b3 3fff 	cmp.w	r3, #4294967295
  400e54:	d103      	bne.n	400e5e <xQueueGenericSend+0x1b2>
  400e56:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  400e58:	2200      	movs	r2, #0
  400e5a:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
  400e5e:	4b23      	ldr	r3, [pc, #140]	; (400eec <xQueueGenericSend+0x240>)
  400e60:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  400e62:	1d3a      	adds	r2, r7, #4
  400e64:	f107 0314 	add.w	r3, r7, #20
  400e68:	4611      	mov	r1, r2
  400e6a:	4618      	mov	r0, r3
  400e6c:	4b22      	ldr	r3, [pc, #136]	; (400ef8 <xQueueGenericSend+0x24c>)
  400e6e:	4798      	blx	r3
  400e70:	4603      	mov	r3, r0
  400e72:	2b00      	cmp	r3, #0
  400e74:	d124      	bne.n	400ec0 <xQueueGenericSend+0x214>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
  400e76:	6b38      	ldr	r0, [r7, #48]	; 0x30
  400e78:	4b20      	ldr	r3, [pc, #128]	; (400efc <xQueueGenericSend+0x250>)
  400e7a:	4798      	blx	r3
  400e7c:	4603      	mov	r3, r0
  400e7e:	2b00      	cmp	r3, #0
  400e80:	d018      	beq.n	400eb4 <xQueueGenericSend+0x208>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
  400e82:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  400e84:	3310      	adds	r3, #16
  400e86:	687a      	ldr	r2, [r7, #4]
  400e88:	4611      	mov	r1, r2
  400e8a:	4618      	mov	r0, r3
  400e8c:	4b1c      	ldr	r3, [pc, #112]	; (400f00 <xQueueGenericSend+0x254>)
  400e8e:	4798      	blx	r3
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
  400e90:	6b38      	ldr	r0, [r7, #48]	; 0x30
  400e92:	4b1c      	ldr	r3, [pc, #112]	; (400f04 <xQueueGenericSend+0x258>)
  400e94:	4798      	blx	r3
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
  400e96:	4b1c      	ldr	r3, [pc, #112]	; (400f08 <xQueueGenericSend+0x25c>)
  400e98:	4798      	blx	r3
  400e9a:	4603      	mov	r3, r0
  400e9c:	2b00      	cmp	r3, #0
  400e9e:	f47f af68 	bne.w	400d72 <xQueueGenericSend+0xc6>
				{
					portYIELD_WITHIN_API();
  400ea2:	4b10      	ldr	r3, [pc, #64]	; (400ee4 <xQueueGenericSend+0x238>)
  400ea4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  400ea8:	601a      	str	r2, [r3, #0]
  400eaa:	f3bf 8f4f 	dsb	sy
  400eae:	f3bf 8f6f 	isb	sy
  400eb2:	e75e      	b.n	400d72 <xQueueGenericSend+0xc6>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  400eb4:	6b38      	ldr	r0, [r7, #48]	; 0x30
  400eb6:	4b13      	ldr	r3, [pc, #76]	; (400f04 <xQueueGenericSend+0x258>)
  400eb8:	4798      	blx	r3
				( void ) xTaskResumeAll();
  400eba:	4b13      	ldr	r3, [pc, #76]	; (400f08 <xQueueGenericSend+0x25c>)
  400ebc:	4798      	blx	r3
  400ebe:	e758      	b.n	400d72 <xQueueGenericSend+0xc6>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
  400ec0:	6b38      	ldr	r0, [r7, #48]	; 0x30
  400ec2:	4b10      	ldr	r3, [pc, #64]	; (400f04 <xQueueGenericSend+0x258>)
  400ec4:	4798      	blx	r3
			( void ) xTaskResumeAll();
  400ec6:	4b10      	ldr	r3, [pc, #64]	; (400f08 <xQueueGenericSend+0x25c>)
  400ec8:	4798      	blx	r3

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
  400eca:	2300      	movs	r3, #0
		}
	}
}
  400ecc:	4618      	mov	r0, r3
  400ece:	3738      	adds	r7, #56	; 0x38
  400ed0:	46bd      	mov	sp, r7
  400ed2:	bd80      	pop	{r7, pc}
  400ed4:	0040252d 	.word	0x0040252d
  400ed8:	004004e9 	.word	0x004004e9
  400edc:	004013f5 	.word	0x004013f5
  400ee0:	00401775 	.word	0x00401775
  400ee4:	e000ed04 	.word	0xe000ed04
  400ee8:	00402171 	.word	0x00402171
  400eec:	0040054d 	.word	0x0040054d
  400ef0:	00402241 	.word	0x00402241
  400ef4:	00401c89 	.word	0x00401c89
  400ef8:	0040228d 	.word	0x0040228d
  400efc:	00401629 	.word	0x00401629
  400f00:	004020bd 	.word	0x004020bd
  400f04:	00401521 	.word	0x00401521
  400f08:	00401ca5 	.word	0x00401ca5

00400f0c <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
  400f0c:	b580      	push	{r7, lr}
  400f0e:	b08e      	sub	sp, #56	; 0x38
  400f10:	af00      	add	r7, sp, #0
  400f12:	60f8      	str	r0, [r7, #12]
  400f14:	60b9      	str	r1, [r7, #8]
  400f16:	607a      	str	r2, [r7, #4]
  400f18:	603b      	str	r3, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  400f1a:	68fb      	ldr	r3, [r7, #12]
  400f1c:	633b      	str	r3, [r7, #48]	; 0x30

	configASSERT( pxQueue );
  400f1e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  400f20:	2b00      	cmp	r3, #0
  400f22:	d10b      	bne.n	400f3c <xQueueGenericSendFromISR+0x30>
  400f24:	f04f 0380 	mov.w	r3, #128	; 0x80
  400f28:	b672      	cpsid	i
  400f2a:	f383 8811 	msr	BASEPRI, r3
  400f2e:	f3bf 8f6f 	isb	sy
  400f32:	f3bf 8f4f 	dsb	sy
  400f36:	b662      	cpsie	i
  400f38:	617b      	str	r3, [r7, #20]
  400f3a:	e7fe      	b.n	400f3a <xQueueGenericSendFromISR+0x2e>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  400f3c:	68bb      	ldr	r3, [r7, #8]
  400f3e:	2b00      	cmp	r3, #0
  400f40:	d103      	bne.n	400f4a <xQueueGenericSendFromISR+0x3e>
  400f42:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  400f44:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  400f46:	2b00      	cmp	r3, #0
  400f48:	d101      	bne.n	400f4e <xQueueGenericSendFromISR+0x42>
  400f4a:	2301      	movs	r3, #1
  400f4c:	e000      	b.n	400f50 <xQueueGenericSendFromISR+0x44>
  400f4e:	2300      	movs	r3, #0
  400f50:	2b00      	cmp	r3, #0
  400f52:	d10b      	bne.n	400f6c <xQueueGenericSendFromISR+0x60>
  400f54:	f04f 0380 	mov.w	r3, #128	; 0x80
  400f58:	b672      	cpsid	i
  400f5a:	f383 8811 	msr	BASEPRI, r3
  400f5e:	f3bf 8f6f 	isb	sy
  400f62:	f3bf 8f4f 	dsb	sy
  400f66:	b662      	cpsie	i
  400f68:	61bb      	str	r3, [r7, #24]
  400f6a:	e7fe      	b.n	400f6a <xQueueGenericSendFromISR+0x5e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  400f6c:	683b      	ldr	r3, [r7, #0]
  400f6e:	2b02      	cmp	r3, #2
  400f70:	d103      	bne.n	400f7a <xQueueGenericSendFromISR+0x6e>
  400f72:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  400f74:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  400f76:	2b01      	cmp	r3, #1
  400f78:	d101      	bne.n	400f7e <xQueueGenericSendFromISR+0x72>
  400f7a:	2301      	movs	r3, #1
  400f7c:	e000      	b.n	400f80 <xQueueGenericSendFromISR+0x74>
  400f7e:	2300      	movs	r3, #0
  400f80:	2b00      	cmp	r3, #0
  400f82:	d10b      	bne.n	400f9c <xQueueGenericSendFromISR+0x90>
  400f84:	f04f 0380 	mov.w	r3, #128	; 0x80
  400f88:	b672      	cpsid	i
  400f8a:	f383 8811 	msr	BASEPRI, r3
  400f8e:	f3bf 8f6f 	isb	sy
  400f92:	f3bf 8f4f 	dsb	sy
  400f96:	b662      	cpsie	i
  400f98:	61fb      	str	r3, [r7, #28]
  400f9a:	e7fe      	b.n	400f9a <xQueueGenericSendFromISR+0x8e>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
  400f9c:	4b32      	ldr	r3, [pc, #200]	; (401068 <xQueueGenericSendFromISR+0x15c>)
  400f9e:	4798      	blx	r3

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
  400fa0:	f3ef 8211 	mrs	r2, BASEPRI
  400fa4:	f04f 0380 	mov.w	r3, #128	; 0x80
  400fa8:	b672      	cpsid	i
  400faa:	f383 8811 	msr	BASEPRI, r3
  400fae:	f3bf 8f6f 	isb	sy
  400fb2:	f3bf 8f4f 	dsb	sy
  400fb6:	b662      	cpsie	i
  400fb8:	623a      	str	r2, [r7, #32]
  400fba:	613b      	str	r3, [r7, #16]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
  400fbc:	6a3b      	ldr	r3, [r7, #32]
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  400fbe:	62bb      	str	r3, [r7, #40]	; 0x28
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  400fc0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  400fc2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  400fc4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  400fc6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  400fc8:	429a      	cmp	r2, r3
  400fca:	d302      	bcc.n	400fd2 <xQueueGenericSendFromISR+0xc6>
  400fcc:	683b      	ldr	r3, [r7, #0]
  400fce:	2b02      	cmp	r3, #2
  400fd0:	d13e      	bne.n	401050 <xQueueGenericSendFromISR+0x144>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
  400fd2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  400fd4:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
  400fd8:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  400fdc:	683a      	ldr	r2, [r7, #0]
  400fde:	68b9      	ldr	r1, [r7, #8]
  400fe0:	6b38      	ldr	r0, [r7, #48]	; 0x30
  400fe2:	4b22      	ldr	r3, [pc, #136]	; (40106c <xQueueGenericSendFromISR+0x160>)
  400fe4:	4798      	blx	r3

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
  400fe6:	f997 3027 	ldrsb.w	r3, [r7, #39]	; 0x27
  400fea:	f1b3 3fff 	cmp.w	r3, #4294967295
  400fee:	d124      	bne.n	40103a <xQueueGenericSendFromISR+0x12e>
			{
				#if ( configUSE_QUEUE_SETS == 1 )
				{
					if( pxQueue->pxQueueSetContainer != NULL )
  400ff0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  400ff2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  400ff4:	2b00      	cmp	r3, #0
  400ff6:	d00d      	beq.n	401014 <xQueueGenericSendFromISR+0x108>
					{
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
  400ff8:	6839      	ldr	r1, [r7, #0]
  400ffa:	6b38      	ldr	r0, [r7, #48]	; 0x30
  400ffc:	4b1c      	ldr	r3, [pc, #112]	; (401070 <xQueueGenericSendFromISR+0x164>)
  400ffe:	4798      	blx	r3
  401000:	4603      	mov	r3, r0
  401002:	2b00      	cmp	r3, #0
  401004:	d021      	beq.n	40104a <xQueueGenericSendFromISR+0x13e>
						{
							/* The queue is a member of a queue set, and posting
							to the queue set caused a higher priority task to
							unblock.  A context switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
  401006:	687b      	ldr	r3, [r7, #4]
  401008:	2b00      	cmp	r3, #0
  40100a:	d01e      	beq.n	40104a <xQueueGenericSendFromISR+0x13e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
  40100c:	687b      	ldr	r3, [r7, #4]
  40100e:	2201      	movs	r2, #1
  401010:	601a      	str	r2, [r3, #0]
  401012:	e01a      	b.n	40104a <xQueueGenericSendFromISR+0x13e>
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else
					{
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  401014:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401016:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  401018:	2b00      	cmp	r3, #0
  40101a:	d016      	beq.n	40104a <xQueueGenericSendFromISR+0x13e>
						{
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  40101c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40101e:	3324      	adds	r3, #36	; 0x24
  401020:	4618      	mov	r0, r3
  401022:	4b14      	ldr	r3, [pc, #80]	; (401074 <xQueueGenericSendFromISR+0x168>)
  401024:	4798      	blx	r3
  401026:	4603      	mov	r3, r0
  401028:	2b00      	cmp	r3, #0
  40102a:	d00e      	beq.n	40104a <xQueueGenericSendFromISR+0x13e>
							{
								/* The task waiting has a higher priority so
								record that a context switch is required. */
								if( pxHigherPriorityTaskWoken != NULL )
  40102c:	687b      	ldr	r3, [r7, #4]
  40102e:	2b00      	cmp	r3, #0
  401030:	d00b      	beq.n	40104a <xQueueGenericSendFromISR+0x13e>
								{
									*pxHigherPriorityTaskWoken = pdTRUE;
  401032:	687b      	ldr	r3, [r7, #4]
  401034:	2201      	movs	r2, #1
  401036:	601a      	str	r2, [r3, #0]
  401038:	e007      	b.n	40104a <xQueueGenericSendFromISR+0x13e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
  40103a:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  40103e:	3301      	adds	r3, #1
  401040:	b2db      	uxtb	r3, r3
  401042:	b25a      	sxtb	r2, r3
  401044:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401046:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			}

			xReturn = pdPASS;
  40104a:	2301      	movs	r3, #1
  40104c:	637b      	str	r3, [r7, #52]	; 0x34
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
  40104e:	e001      	b.n	401054 <xQueueGenericSendFromISR+0x148>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
  401050:	2300      	movs	r3, #0
  401052:	637b      	str	r3, [r7, #52]	; 0x34
  401054:	6abb      	ldr	r3, [r7, #40]	; 0x28
  401056:	62fb      	str	r3, [r7, #44]	; 0x2c
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
  401058:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40105a:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  40105e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
  401060:	4618      	mov	r0, r3
  401062:	3738      	adds	r7, #56	; 0x38
  401064:	46bd      	mov	sp, r7
  401066:	bd80      	pop	{r7, pc}
  401068:	0040068d 	.word	0x0040068d
  40106c:	004013f5 	.word	0x004013f5
  401070:	00401775 	.word	0x00401775
  401074:	00402171 	.word	0x00402171

00401078 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
  401078:	b580      	push	{r7, lr}
  40107a:	b08e      	sub	sp, #56	; 0x38
  40107c:	af00      	add	r7, sp, #0
  40107e:	60f8      	str	r0, [r7, #12]
  401080:	60b9      	str	r1, [r7, #8]
  401082:	607a      	str	r2, [r7, #4]
  401084:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE;
  401086:	2300      	movs	r3, #0
  401088:	637b      	str	r3, [r7, #52]	; 0x34
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  40108a:	68fb      	ldr	r3, [r7, #12]
  40108c:	633b      	str	r3, [r7, #48]	; 0x30

	configASSERT( pxQueue );
  40108e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401090:	2b00      	cmp	r3, #0
  401092:	d10b      	bne.n	4010ac <xQueueGenericReceive+0x34>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
  401094:	f04f 0380 	mov.w	r3, #128	; 0x80
  401098:	b672      	cpsid	i
  40109a:	f383 8811 	msr	BASEPRI, r3
  40109e:	f3bf 8f6f 	isb	sy
  4010a2:	f3bf 8f4f 	dsb	sy
  4010a6:	b662      	cpsie	i
  4010a8:	61fb      	str	r3, [r7, #28]
  4010aa:	e7fe      	b.n	4010aa <xQueueGenericReceive+0x32>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  4010ac:	68bb      	ldr	r3, [r7, #8]
  4010ae:	2b00      	cmp	r3, #0
  4010b0:	d103      	bne.n	4010ba <xQueueGenericReceive+0x42>
  4010b2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  4010b4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4010b6:	2b00      	cmp	r3, #0
  4010b8:	d101      	bne.n	4010be <xQueueGenericReceive+0x46>
  4010ba:	2301      	movs	r3, #1
  4010bc:	e000      	b.n	4010c0 <xQueueGenericReceive+0x48>
  4010be:	2300      	movs	r3, #0
  4010c0:	2b00      	cmp	r3, #0
  4010c2:	d10b      	bne.n	4010dc <xQueueGenericReceive+0x64>
  4010c4:	f04f 0380 	mov.w	r3, #128	; 0x80
  4010c8:	b672      	cpsid	i
  4010ca:	f383 8811 	msr	BASEPRI, r3
  4010ce:	f3bf 8f6f 	isb	sy
  4010d2:	f3bf 8f4f 	dsb	sy
  4010d6:	b662      	cpsie	i
  4010d8:	623b      	str	r3, [r7, #32]
  4010da:	e7fe      	b.n	4010da <xQueueGenericReceive+0x62>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
  4010dc:	4b71      	ldr	r3, [pc, #452]	; (4012a4 <xQueueGenericReceive+0x22c>)
  4010de:	4798      	blx	r3
  4010e0:	4603      	mov	r3, r0
  4010e2:	2b00      	cmp	r3, #0
  4010e4:	d102      	bne.n	4010ec <xQueueGenericReceive+0x74>
  4010e6:	687b      	ldr	r3, [r7, #4]
  4010e8:	2b00      	cmp	r3, #0
  4010ea:	d101      	bne.n	4010f0 <xQueueGenericReceive+0x78>
  4010ec:	2301      	movs	r3, #1
  4010ee:	e000      	b.n	4010f2 <xQueueGenericReceive+0x7a>
  4010f0:	2300      	movs	r3, #0
  4010f2:	2b00      	cmp	r3, #0
  4010f4:	d10b      	bne.n	40110e <xQueueGenericReceive+0x96>
  4010f6:	f04f 0380 	mov.w	r3, #128	; 0x80
  4010fa:	b672      	cpsid	i
  4010fc:	f383 8811 	msr	BASEPRI, r3
  401100:	f3bf 8f6f 	isb	sy
  401104:	f3bf 8f4f 	dsb	sy
  401108:	b662      	cpsie	i
  40110a:	627b      	str	r3, [r7, #36]	; 0x24
  40110c:	e7fe      	b.n	40110c <xQueueGenericReceive+0x94>
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
  40110e:	4b66      	ldr	r3, [pc, #408]	; (4012a8 <xQueueGenericReceive+0x230>)
  401110:	4798      	blx	r3
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  401112:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401114:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  401116:	62fb      	str	r3, [r7, #44]	; 0x2c

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  401118:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40111a:	2b00      	cmp	r3, #0
  40111c:	d046      	beq.n	4011ac <xQueueGenericReceive+0x134>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
  40111e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401120:	68db      	ldr	r3, [r3, #12]
  401122:	62bb      	str	r3, [r7, #40]	; 0x28

				prvCopyDataFromQueue( pxQueue, pvBuffer );
  401124:	68b9      	ldr	r1, [r7, #8]
  401126:	6b38      	ldr	r0, [r7, #48]	; 0x30
  401128:	4b60      	ldr	r3, [pc, #384]	; (4012ac <xQueueGenericReceive+0x234>)
  40112a:	4798      	blx	r3

				if( xJustPeeking == pdFALSE )
  40112c:	683b      	ldr	r3, [r7, #0]
  40112e:	2b00      	cmp	r3, #0
  401130:	d121      	bne.n	401176 <xQueueGenericReceive+0xfe>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
  401132:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401134:	1e5a      	subs	r2, r3, #1
  401136:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401138:	639a      	str	r2, [r3, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  40113a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40113c:	681b      	ldr	r3, [r3, #0]
  40113e:	2b00      	cmp	r3, #0
  401140:	d104      	bne.n	40114c <xQueueGenericReceive+0xd4>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
  401142:	4b5b      	ldr	r3, [pc, #364]	; (4012b0 <xQueueGenericReceive+0x238>)
  401144:	4798      	blx	r3
  401146:	4602      	mov	r2, r0
  401148:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40114a:	605a      	str	r2, [r3, #4]
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  40114c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40114e:	691b      	ldr	r3, [r3, #16]
  401150:	2b00      	cmp	r3, #0
  401152:	d027      	beq.n	4011a4 <xQueueGenericReceive+0x12c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  401154:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401156:	3310      	adds	r3, #16
  401158:	4618      	mov	r0, r3
  40115a:	4b56      	ldr	r3, [pc, #344]	; (4012b4 <xQueueGenericReceive+0x23c>)
  40115c:	4798      	blx	r3
  40115e:	4603      	mov	r3, r0
  401160:	2b00      	cmp	r3, #0
  401162:	d01f      	beq.n	4011a4 <xQueueGenericReceive+0x12c>
						{
							queueYIELD_IF_USING_PREEMPTION();
  401164:	4b54      	ldr	r3, [pc, #336]	; (4012b8 <xQueueGenericReceive+0x240>)
  401166:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  40116a:	601a      	str	r2, [r3, #0]
  40116c:	f3bf 8f4f 	dsb	sy
  401170:	f3bf 8f6f 	isb	sy
  401174:	e016      	b.n	4011a4 <xQueueGenericReceive+0x12c>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
  401176:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401178:	6aba      	ldr	r2, [r7, #40]	; 0x28
  40117a:	60da      	str	r2, [r3, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  40117c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40117e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  401180:	2b00      	cmp	r3, #0
  401182:	d00f      	beq.n	4011a4 <xQueueGenericReceive+0x12c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  401184:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401186:	3324      	adds	r3, #36	; 0x24
  401188:	4618      	mov	r0, r3
  40118a:	4b4a      	ldr	r3, [pc, #296]	; (4012b4 <xQueueGenericReceive+0x23c>)
  40118c:	4798      	blx	r3
  40118e:	4603      	mov	r3, r0
  401190:	2b00      	cmp	r3, #0
  401192:	d007      	beq.n	4011a4 <xQueueGenericReceive+0x12c>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
  401194:	4b48      	ldr	r3, [pc, #288]	; (4012b8 <xQueueGenericReceive+0x240>)
  401196:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  40119a:	601a      	str	r2, [r3, #0]
  40119c:	f3bf 8f4f 	dsb	sy
  4011a0:	f3bf 8f6f 	isb	sy
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
  4011a4:	4b45      	ldr	r3, [pc, #276]	; (4012bc <xQueueGenericReceive+0x244>)
  4011a6:	4798      	blx	r3
				return pdPASS;
  4011a8:	2301      	movs	r3, #1
  4011aa:	e077      	b.n	40129c <xQueueGenericReceive+0x224>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
  4011ac:	687b      	ldr	r3, [r7, #4]
  4011ae:	2b00      	cmp	r3, #0
  4011b0:	d103      	bne.n	4011ba <xQueueGenericReceive+0x142>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  4011b2:	4b42      	ldr	r3, [pc, #264]	; (4012bc <xQueueGenericReceive+0x244>)
  4011b4:	4798      	blx	r3
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
  4011b6:	2300      	movs	r3, #0
  4011b8:	e070      	b.n	40129c <xQueueGenericReceive+0x224>
				}
				else if( xEntryTimeSet == pdFALSE )
  4011ba:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  4011bc:	2b00      	cmp	r3, #0
  4011be:	d106      	bne.n	4011ce <xQueueGenericReceive+0x156>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  4011c0:	f107 0314 	add.w	r3, r7, #20
  4011c4:	4618      	mov	r0, r3
  4011c6:	4b3e      	ldr	r3, [pc, #248]	; (4012c0 <xQueueGenericReceive+0x248>)
  4011c8:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
  4011ca:	2301      	movs	r3, #1
  4011cc:	637b      	str	r3, [r7, #52]	; 0x34
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
  4011ce:	4b3b      	ldr	r3, [pc, #236]	; (4012bc <xQueueGenericReceive+0x244>)
  4011d0:	4798      	blx	r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  4011d2:	4b3c      	ldr	r3, [pc, #240]	; (4012c4 <xQueueGenericReceive+0x24c>)
  4011d4:	4798      	blx	r3
		prvLockQueue( pxQueue );
  4011d6:	4b34      	ldr	r3, [pc, #208]	; (4012a8 <xQueueGenericReceive+0x230>)
  4011d8:	4798      	blx	r3
  4011da:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  4011dc:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
  4011e0:	b25b      	sxtb	r3, r3
  4011e2:	f1b3 3fff 	cmp.w	r3, #4294967295
  4011e6:	d103      	bne.n	4011f0 <xQueueGenericReceive+0x178>
  4011e8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  4011ea:	2200      	movs	r2, #0
  4011ec:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  4011f0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  4011f2:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
  4011f6:	b25b      	sxtb	r3, r3
  4011f8:	f1b3 3fff 	cmp.w	r3, #4294967295
  4011fc:	d103      	bne.n	401206 <xQueueGenericReceive+0x18e>
  4011fe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401200:	2200      	movs	r2, #0
  401202:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
  401206:	4b2d      	ldr	r3, [pc, #180]	; (4012bc <xQueueGenericReceive+0x244>)
  401208:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  40120a:	1d3a      	adds	r2, r7, #4
  40120c:	f107 0314 	add.w	r3, r7, #20
  401210:	4611      	mov	r1, r2
  401212:	4618      	mov	r0, r3
  401214:	4b2c      	ldr	r3, [pc, #176]	; (4012c8 <xQueueGenericReceive+0x250>)
  401216:	4798      	blx	r3
  401218:	4603      	mov	r3, r0
  40121a:	2b00      	cmp	r3, #0
  40121c:	d131      	bne.n	401282 <xQueueGenericReceive+0x20a>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  40121e:	6b38      	ldr	r0, [r7, #48]	; 0x30
  401220:	4b2a      	ldr	r3, [pc, #168]	; (4012cc <xQueueGenericReceive+0x254>)
  401222:	4798      	blx	r3
  401224:	4603      	mov	r3, r0
  401226:	2b00      	cmp	r3, #0
  401228:	d025      	beq.n	401276 <xQueueGenericReceive+0x1fe>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  40122a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40122c:	681b      	ldr	r3, [r3, #0]
  40122e:	2b00      	cmp	r3, #0
  401230:	d108      	bne.n	401244 <xQueueGenericReceive+0x1cc>
					{
						taskENTER_CRITICAL();
  401232:	4b1d      	ldr	r3, [pc, #116]	; (4012a8 <xQueueGenericReceive+0x230>)
  401234:	4798      	blx	r3
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
  401236:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401238:	685b      	ldr	r3, [r3, #4]
  40123a:	4618      	mov	r0, r3
  40123c:	4b24      	ldr	r3, [pc, #144]	; (4012d0 <xQueueGenericReceive+0x258>)
  40123e:	4798      	blx	r3
						}
						taskEXIT_CRITICAL();
  401240:	4b1e      	ldr	r3, [pc, #120]	; (4012bc <xQueueGenericReceive+0x244>)
  401242:	4798      	blx	r3
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  401244:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401246:	3324      	adds	r3, #36	; 0x24
  401248:	687a      	ldr	r2, [r7, #4]
  40124a:	4611      	mov	r1, r2
  40124c:	4618      	mov	r0, r3
  40124e:	4b21      	ldr	r3, [pc, #132]	; (4012d4 <xQueueGenericReceive+0x25c>)
  401250:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
  401252:	6b38      	ldr	r0, [r7, #48]	; 0x30
  401254:	4b20      	ldr	r3, [pc, #128]	; (4012d8 <xQueueGenericReceive+0x260>)
  401256:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
  401258:	4b20      	ldr	r3, [pc, #128]	; (4012dc <xQueueGenericReceive+0x264>)
  40125a:	4798      	blx	r3
  40125c:	4603      	mov	r3, r0
  40125e:	2b00      	cmp	r3, #0
  401260:	f47f af55 	bne.w	40110e <xQueueGenericReceive+0x96>
				{
					portYIELD_WITHIN_API();
  401264:	4b14      	ldr	r3, [pc, #80]	; (4012b8 <xQueueGenericReceive+0x240>)
  401266:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  40126a:	601a      	str	r2, [r3, #0]
  40126c:	f3bf 8f4f 	dsb	sy
  401270:	f3bf 8f6f 	isb	sy
  401274:	e74b      	b.n	40110e <xQueueGenericReceive+0x96>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  401276:	6b38      	ldr	r0, [r7, #48]	; 0x30
  401278:	4b17      	ldr	r3, [pc, #92]	; (4012d8 <xQueueGenericReceive+0x260>)
  40127a:	4798      	blx	r3
				( void ) xTaskResumeAll();
  40127c:	4b17      	ldr	r3, [pc, #92]	; (4012dc <xQueueGenericReceive+0x264>)
  40127e:	4798      	blx	r3
  401280:	e745      	b.n	40110e <xQueueGenericReceive+0x96>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
  401282:	6b38      	ldr	r0, [r7, #48]	; 0x30
  401284:	4b14      	ldr	r3, [pc, #80]	; (4012d8 <xQueueGenericReceive+0x260>)
  401286:	4798      	blx	r3
			( void ) xTaskResumeAll();
  401288:	4b14      	ldr	r3, [pc, #80]	; (4012dc <xQueueGenericReceive+0x264>)
  40128a:	4798      	blx	r3

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  40128c:	6b38      	ldr	r0, [r7, #48]	; 0x30
  40128e:	4b0f      	ldr	r3, [pc, #60]	; (4012cc <xQueueGenericReceive+0x254>)
  401290:	4798      	blx	r3
  401292:	4603      	mov	r3, r0
  401294:	2b00      	cmp	r3, #0
  401296:	f43f af3a 	beq.w	40110e <xQueueGenericReceive+0x96>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
  40129a:	2300      	movs	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
  40129c:	4618      	mov	r0, r3
  40129e:	3738      	adds	r7, #56	; 0x38
  4012a0:	46bd      	mov	sp, r7
  4012a2:	bd80      	pop	{r7, pc}
  4012a4:	0040252d 	.word	0x0040252d
  4012a8:	004004e9 	.word	0x004004e9
  4012ac:	004014d1 	.word	0x004014d1
  4012b0:	00402775 	.word	0x00402775
  4012b4:	00402171 	.word	0x00402171
  4012b8:	e000ed04 	.word	0xe000ed04
  4012bc:	0040054d 	.word	0x0040054d
  4012c0:	00402241 	.word	0x00402241
  4012c4:	00401c89 	.word	0x00401c89
  4012c8:	0040228d 	.word	0x0040228d
  4012cc:	004015f5 	.word	0x004015f5
  4012d0:	00402569 	.word	0x00402569
  4012d4:	004020bd 	.word	0x004020bd
  4012d8:	00401521 	.word	0x00401521
  4012dc:	00401ca5 	.word	0x00401ca5

004012e0 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
  4012e0:	b580      	push	{r7, lr}
  4012e2:	b08e      	sub	sp, #56	; 0x38
  4012e4:	af00      	add	r7, sp, #0
  4012e6:	60f8      	str	r0, [r7, #12]
  4012e8:	60b9      	str	r1, [r7, #8]
  4012ea:	607a      	str	r2, [r7, #4]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  4012ec:	68fb      	ldr	r3, [r7, #12]
  4012ee:	633b      	str	r3, [r7, #48]	; 0x30

	configASSERT( pxQueue );
  4012f0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  4012f2:	2b00      	cmp	r3, #0
  4012f4:	d10b      	bne.n	40130e <xQueueReceiveFromISR+0x2e>
  4012f6:	f04f 0380 	mov.w	r3, #128	; 0x80
  4012fa:	b672      	cpsid	i
  4012fc:	f383 8811 	msr	BASEPRI, r3
  401300:	f3bf 8f6f 	isb	sy
  401304:	f3bf 8f4f 	dsb	sy
  401308:	b662      	cpsie	i
  40130a:	617b      	str	r3, [r7, #20]
  40130c:	e7fe      	b.n	40130c <xQueueReceiveFromISR+0x2c>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  40130e:	68bb      	ldr	r3, [r7, #8]
  401310:	2b00      	cmp	r3, #0
  401312:	d103      	bne.n	40131c <xQueueReceiveFromISR+0x3c>
  401314:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401316:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  401318:	2b00      	cmp	r3, #0
  40131a:	d101      	bne.n	401320 <xQueueReceiveFromISR+0x40>
  40131c:	2301      	movs	r3, #1
  40131e:	e000      	b.n	401322 <xQueueReceiveFromISR+0x42>
  401320:	2300      	movs	r3, #0
  401322:	2b00      	cmp	r3, #0
  401324:	d10b      	bne.n	40133e <xQueueReceiveFromISR+0x5e>
  401326:	f04f 0380 	mov.w	r3, #128	; 0x80
  40132a:	b672      	cpsid	i
  40132c:	f383 8811 	msr	BASEPRI, r3
  401330:	f3bf 8f6f 	isb	sy
  401334:	f3bf 8f4f 	dsb	sy
  401338:	b662      	cpsie	i
  40133a:	61bb      	str	r3, [r7, #24]
  40133c:	e7fe      	b.n	40133c <xQueueReceiveFromISR+0x5c>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
  40133e:	4b2a      	ldr	r3, [pc, #168]	; (4013e8 <xQueueReceiveFromISR+0x108>)
  401340:	4798      	blx	r3

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
  401342:	f3ef 8211 	mrs	r2, BASEPRI
  401346:	f04f 0380 	mov.w	r3, #128	; 0x80
  40134a:	b672      	cpsid	i
  40134c:	f383 8811 	msr	BASEPRI, r3
  401350:	f3bf 8f6f 	isb	sy
  401354:	f3bf 8f4f 	dsb	sy
  401358:	b662      	cpsie	i
  40135a:	61fa      	str	r2, [r7, #28]
  40135c:	613b      	str	r3, [r7, #16]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
  40135e:	69fb      	ldr	r3, [r7, #28]

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  401360:	62bb      	str	r3, [r7, #40]	; 0x28
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  401362:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401364:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  401366:	627b      	str	r3, [r7, #36]	; 0x24

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  401368:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40136a:	2b00      	cmp	r3, #0
  40136c:	d02f      	beq.n	4013ce <xQueueReceiveFromISR+0xee>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
  40136e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401370:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
  401374:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
  401378:	68b9      	ldr	r1, [r7, #8]
  40137a:	6b38      	ldr	r0, [r7, #48]	; 0x30
  40137c:	4b1b      	ldr	r3, [pc, #108]	; (4013ec <xQueueReceiveFromISR+0x10c>)
  40137e:	4798      	blx	r3
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
  401380:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401382:	1e5a      	subs	r2, r3, #1
  401384:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401386:	639a      	str	r2, [r3, #56]	; 0x38

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
  401388:	f997 3023 	ldrsb.w	r3, [r7, #35]	; 0x23
  40138c:	f1b3 3fff 	cmp.w	r3, #4294967295
  401390:	d112      	bne.n	4013b8 <xQueueReceiveFromISR+0xd8>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  401392:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401394:	691b      	ldr	r3, [r3, #16]
  401396:	2b00      	cmp	r3, #0
  401398:	d016      	beq.n	4013c8 <xQueueReceiveFromISR+0xe8>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  40139a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40139c:	3310      	adds	r3, #16
  40139e:	4618      	mov	r0, r3
  4013a0:	4b13      	ldr	r3, [pc, #76]	; (4013f0 <xQueueReceiveFromISR+0x110>)
  4013a2:	4798      	blx	r3
  4013a4:	4603      	mov	r3, r0
  4013a6:	2b00      	cmp	r3, #0
  4013a8:	d00e      	beq.n	4013c8 <xQueueReceiveFromISR+0xe8>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
  4013aa:	687b      	ldr	r3, [r7, #4]
  4013ac:	2b00      	cmp	r3, #0
  4013ae:	d00b      	beq.n	4013c8 <xQueueReceiveFromISR+0xe8>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
  4013b0:	687b      	ldr	r3, [r7, #4]
  4013b2:	2201      	movs	r2, #1
  4013b4:	601a      	str	r2, [r3, #0]
  4013b6:	e007      	b.n	4013c8 <xQueueReceiveFromISR+0xe8>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
  4013b8:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  4013bc:	3301      	adds	r3, #1
  4013be:	b2db      	uxtb	r3, r3
  4013c0:	b25a      	sxtb	r2, r3
  4013c2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  4013c4:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
			}

			xReturn = pdPASS;
  4013c8:	2301      	movs	r3, #1
  4013ca:	637b      	str	r3, [r7, #52]	; 0x34
  4013cc:	e001      	b.n	4013d2 <xQueueReceiveFromISR+0xf2>
		}
		else
		{
			xReturn = pdFAIL;
  4013ce:	2300      	movs	r3, #0
  4013d0:	637b      	str	r3, [r7, #52]	; 0x34
  4013d2:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4013d4:	62fb      	str	r3, [r7, #44]	; 0x2c
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
  4013d6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4013d8:	f383 8811 	msr	BASEPRI, r3
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  4013dc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
  4013de:	4618      	mov	r0, r3
  4013e0:	3738      	adds	r7, #56	; 0x38
  4013e2:	46bd      	mov	sp, r7
  4013e4:	bd80      	pop	{r7, pc}
  4013e6:	bf00      	nop
  4013e8:	0040068d 	.word	0x0040068d
  4013ec:	004014d1 	.word	0x004014d1
  4013f0:	00402171 	.word	0x00402171

004013f4 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
  4013f4:	b580      	push	{r7, lr}
  4013f6:	b086      	sub	sp, #24
  4013f8:	af00      	add	r7, sp, #0
  4013fa:	60f8      	str	r0, [r7, #12]
  4013fc:	60b9      	str	r1, [r7, #8]
  4013fe:	607a      	str	r2, [r7, #4]
BaseType_t xReturn = pdFALSE;
  401400:	2300      	movs	r3, #0
  401402:	617b      	str	r3, [r7, #20]
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  401404:	68fb      	ldr	r3, [r7, #12]
  401406:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  401408:	613b      	str	r3, [r7, #16]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
  40140a:	68fb      	ldr	r3, [r7, #12]
  40140c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  40140e:	2b00      	cmp	r3, #0
  401410:	d10d      	bne.n	40142e <prvCopyDataToQueue+0x3a>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  401412:	68fb      	ldr	r3, [r7, #12]
  401414:	681b      	ldr	r3, [r3, #0]
  401416:	2b00      	cmp	r3, #0
  401418:	d14d      	bne.n	4014b6 <prvCopyDataToQueue+0xc2>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
  40141a:	68fb      	ldr	r3, [r7, #12]
  40141c:	685b      	ldr	r3, [r3, #4]
  40141e:	4618      	mov	r0, r3
  401420:	4b29      	ldr	r3, [pc, #164]	; (4014c8 <prvCopyDataToQueue+0xd4>)
  401422:	4798      	blx	r3
  401424:	6178      	str	r0, [r7, #20]
				pxQueue->pxMutexHolder = NULL;
  401426:	68fb      	ldr	r3, [r7, #12]
  401428:	2200      	movs	r2, #0
  40142a:	605a      	str	r2, [r3, #4]
  40142c:	e043      	b.n	4014b6 <prvCopyDataToQueue+0xc2>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
  40142e:	687b      	ldr	r3, [r7, #4]
  401430:	2b00      	cmp	r3, #0
  401432:	d119      	bne.n	401468 <prvCopyDataToQueue+0x74>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
  401434:	68fb      	ldr	r3, [r7, #12]
  401436:	6898      	ldr	r0, [r3, #8]
  401438:	68fb      	ldr	r3, [r7, #12]
  40143a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  40143c:	461a      	mov	r2, r3
  40143e:	68b9      	ldr	r1, [r7, #8]
  401440:	4b22      	ldr	r3, [pc, #136]	; (4014cc <prvCopyDataToQueue+0xd8>)
  401442:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  401444:	68fb      	ldr	r3, [r7, #12]
  401446:	689a      	ldr	r2, [r3, #8]
  401448:	68fb      	ldr	r3, [r7, #12]
  40144a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  40144c:	441a      	add	r2, r3
  40144e:	68fb      	ldr	r3, [r7, #12]
  401450:	609a      	str	r2, [r3, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  401452:	68fb      	ldr	r3, [r7, #12]
  401454:	689a      	ldr	r2, [r3, #8]
  401456:	68fb      	ldr	r3, [r7, #12]
  401458:	685b      	ldr	r3, [r3, #4]
  40145a:	429a      	cmp	r2, r3
  40145c:	d32b      	bcc.n	4014b6 <prvCopyDataToQueue+0xc2>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
  40145e:	68fb      	ldr	r3, [r7, #12]
  401460:	681a      	ldr	r2, [r3, #0]
  401462:	68fb      	ldr	r3, [r7, #12]
  401464:	609a      	str	r2, [r3, #8]
  401466:	e026      	b.n	4014b6 <prvCopyDataToQueue+0xc2>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  401468:	68fb      	ldr	r3, [r7, #12]
  40146a:	68d8      	ldr	r0, [r3, #12]
  40146c:	68fb      	ldr	r3, [r7, #12]
  40146e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  401470:	461a      	mov	r2, r3
  401472:	68b9      	ldr	r1, [r7, #8]
  401474:	4b15      	ldr	r3, [pc, #84]	; (4014cc <prvCopyDataToQueue+0xd8>)
  401476:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
  401478:	68fb      	ldr	r3, [r7, #12]
  40147a:	68da      	ldr	r2, [r3, #12]
  40147c:	68fb      	ldr	r3, [r7, #12]
  40147e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  401480:	425b      	negs	r3, r3
  401482:	441a      	add	r2, r3
  401484:	68fb      	ldr	r3, [r7, #12]
  401486:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  401488:	68fb      	ldr	r3, [r7, #12]
  40148a:	68da      	ldr	r2, [r3, #12]
  40148c:	68fb      	ldr	r3, [r7, #12]
  40148e:	681b      	ldr	r3, [r3, #0]
  401490:	429a      	cmp	r2, r3
  401492:	d207      	bcs.n	4014a4 <prvCopyDataToQueue+0xb0>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
  401494:	68fb      	ldr	r3, [r7, #12]
  401496:	685a      	ldr	r2, [r3, #4]
  401498:	68fb      	ldr	r3, [r7, #12]
  40149a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  40149c:	425b      	negs	r3, r3
  40149e:	441a      	add	r2, r3
  4014a0:	68fb      	ldr	r3, [r7, #12]
  4014a2:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
  4014a4:	687b      	ldr	r3, [r7, #4]
  4014a6:	2b02      	cmp	r3, #2
  4014a8:	d105      	bne.n	4014b6 <prvCopyDataToQueue+0xc2>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  4014aa:	693b      	ldr	r3, [r7, #16]
  4014ac:	2b00      	cmp	r3, #0
  4014ae:	d002      	beq.n	4014b6 <prvCopyDataToQueue+0xc2>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
  4014b0:	693b      	ldr	r3, [r7, #16]
  4014b2:	3b01      	subs	r3, #1
  4014b4:	613b      	str	r3, [r7, #16]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
  4014b6:	693b      	ldr	r3, [r7, #16]
  4014b8:	1c5a      	adds	r2, r3, #1
  4014ba:	68fb      	ldr	r3, [r7, #12]
  4014bc:	639a      	str	r2, [r3, #56]	; 0x38

	return xReturn;
  4014be:	697b      	ldr	r3, [r7, #20]
}
  4014c0:	4618      	mov	r0, r3
  4014c2:	3718      	adds	r7, #24
  4014c4:	46bd      	mov	sp, r7
  4014c6:	bd80      	pop	{r7, pc}
  4014c8:	0040265d 	.word	0x0040265d
  4014cc:	00404d0d 	.word	0x00404d0d

004014d0 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
  4014d0:	b580      	push	{r7, lr}
  4014d2:	b082      	sub	sp, #8
  4014d4:	af00      	add	r7, sp, #0
  4014d6:	6078      	str	r0, [r7, #4]
  4014d8:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
  4014da:	687b      	ldr	r3, [r7, #4]
  4014dc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4014de:	2b00      	cmp	r3, #0
  4014e0:	d018      	beq.n	401514 <prvCopyDataFromQueue+0x44>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
  4014e2:	687b      	ldr	r3, [r7, #4]
  4014e4:	68da      	ldr	r2, [r3, #12]
  4014e6:	687b      	ldr	r3, [r7, #4]
  4014e8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4014ea:	441a      	add	r2, r3
  4014ec:	687b      	ldr	r3, [r7, #4]
  4014ee:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
  4014f0:	687b      	ldr	r3, [r7, #4]
  4014f2:	68da      	ldr	r2, [r3, #12]
  4014f4:	687b      	ldr	r3, [r7, #4]
  4014f6:	685b      	ldr	r3, [r3, #4]
  4014f8:	429a      	cmp	r2, r3
  4014fa:	d303      	bcc.n	401504 <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
  4014fc:	687b      	ldr	r3, [r7, #4]
  4014fe:	681a      	ldr	r2, [r3, #0]
  401500:	687b      	ldr	r3, [r7, #4]
  401502:	60da      	str	r2, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
  401504:	687b      	ldr	r3, [r7, #4]
  401506:	68d9      	ldr	r1, [r3, #12]
  401508:	687b      	ldr	r3, [r7, #4]
  40150a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  40150c:	461a      	mov	r2, r3
  40150e:	6838      	ldr	r0, [r7, #0]
  401510:	4b02      	ldr	r3, [pc, #8]	; (40151c <prvCopyDataFromQueue+0x4c>)
  401512:	4798      	blx	r3
	}
}
  401514:	bf00      	nop
  401516:	3708      	adds	r7, #8
  401518:	46bd      	mov	sp, r7
  40151a:	bd80      	pop	{r7, pc}
  40151c:	00404d0d 	.word	0x00404d0d

00401520 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
  401520:	b580      	push	{r7, lr}
  401522:	b084      	sub	sp, #16
  401524:	af00      	add	r7, sp, #0
  401526:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
  401528:	4b2d      	ldr	r3, [pc, #180]	; (4015e0 <prvUnlockQueue+0xc0>)
  40152a:	4798      	blx	r3
	{
		int8_t cTxLock = pxQueue->cTxLock;
  40152c:	687b      	ldr	r3, [r7, #4]
  40152e:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
  401532:	73fb      	strb	r3, [r7, #15]

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
  401534:	e01f      	b.n	401576 <prvUnlockQueue+0x56>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			#if ( configUSE_QUEUE_SETS == 1 )
			{
				if( pxQueue->pxQueueSetContainer != NULL )
  401536:	687b      	ldr	r3, [r7, #4]
  401538:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  40153a:	2b00      	cmp	r3, #0
  40153c:	d009      	beq.n	401552 <prvUnlockQueue+0x32>
				{
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
  40153e:	2100      	movs	r1, #0
  401540:	6878      	ldr	r0, [r7, #4]
  401542:	4b28      	ldr	r3, [pc, #160]	; (4015e4 <prvUnlockQueue+0xc4>)
  401544:	4798      	blx	r3
  401546:	4603      	mov	r3, r0
  401548:	2b00      	cmp	r3, #0
  40154a:	d010      	beq.n	40156e <prvUnlockQueue+0x4e>
					{
						/* The queue is a member of a queue set, and posting to
						the queue set caused a higher priority task to unblock.
						A context switch is required. */
						vTaskMissedYield();
  40154c:	4b26      	ldr	r3, [pc, #152]	; (4015e8 <prvUnlockQueue+0xc8>)
  40154e:	4798      	blx	r3
  401550:	e00d      	b.n	40156e <prvUnlockQueue+0x4e>
				else
				{
					/* Tasks that are removed from the event list will get
					added to the pending ready list as the scheduler is still
					suspended. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  401552:	687b      	ldr	r3, [r7, #4]
  401554:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  401556:	2b00      	cmp	r3, #0
  401558:	d012      	beq.n	401580 <prvUnlockQueue+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  40155a:	687b      	ldr	r3, [r7, #4]
  40155c:	3324      	adds	r3, #36	; 0x24
  40155e:	4618      	mov	r0, r3
  401560:	4b22      	ldr	r3, [pc, #136]	; (4015ec <prvUnlockQueue+0xcc>)
  401562:	4798      	blx	r3
  401564:	4603      	mov	r3, r0
  401566:	2b00      	cmp	r3, #0
  401568:	d001      	beq.n	40156e <prvUnlockQueue+0x4e>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							vTaskMissedYield();
  40156a:	4b1f      	ldr	r3, [pc, #124]	; (4015e8 <prvUnlockQueue+0xc8>)
  40156c:	4798      	blx	r3
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
  40156e:	7bfb      	ldrb	r3, [r7, #15]
  401570:	3b01      	subs	r3, #1
  401572:	b2db      	uxtb	r3, r3
  401574:	73fb      	strb	r3, [r7, #15]
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
  401576:	f997 300f 	ldrsb.w	r3, [r7, #15]
  40157a:	2b00      	cmp	r3, #0
  40157c:	dcdb      	bgt.n	401536 <prvUnlockQueue+0x16>
  40157e:	e000      	b.n	401582 <prvUnlockQueue+0x62>
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else
					{
						break;
  401580:	bf00      	nop
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
  401582:	687b      	ldr	r3, [r7, #4]
  401584:	22ff      	movs	r2, #255	; 0xff
  401586:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
  40158a:	4b19      	ldr	r3, [pc, #100]	; (4015f0 <prvUnlockQueue+0xd0>)
  40158c:	4798      	blx	r3

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
  40158e:	4b14      	ldr	r3, [pc, #80]	; (4015e0 <prvUnlockQueue+0xc0>)
  401590:	4798      	blx	r3
	{
		int8_t cRxLock = pxQueue->cRxLock;
  401592:	687b      	ldr	r3, [r7, #4]
  401594:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
  401598:	73bb      	strb	r3, [r7, #14]

		while( cRxLock > queueLOCKED_UNMODIFIED )
  40159a:	e011      	b.n	4015c0 <prvUnlockQueue+0xa0>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  40159c:	687b      	ldr	r3, [r7, #4]
  40159e:	691b      	ldr	r3, [r3, #16]
  4015a0:	2b00      	cmp	r3, #0
  4015a2:	d012      	beq.n	4015ca <prvUnlockQueue+0xaa>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  4015a4:	687b      	ldr	r3, [r7, #4]
  4015a6:	3310      	adds	r3, #16
  4015a8:	4618      	mov	r0, r3
  4015aa:	4b10      	ldr	r3, [pc, #64]	; (4015ec <prvUnlockQueue+0xcc>)
  4015ac:	4798      	blx	r3
  4015ae:	4603      	mov	r3, r0
  4015b0:	2b00      	cmp	r3, #0
  4015b2:	d001      	beq.n	4015b8 <prvUnlockQueue+0x98>
				{
					vTaskMissedYield();
  4015b4:	4b0c      	ldr	r3, [pc, #48]	; (4015e8 <prvUnlockQueue+0xc8>)
  4015b6:	4798      	blx	r3
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
  4015b8:	7bbb      	ldrb	r3, [r7, #14]
  4015ba:	3b01      	subs	r3, #1
  4015bc:	b2db      	uxtb	r3, r3
  4015be:	73bb      	strb	r3, [r7, #14]
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
  4015c0:	f997 300e 	ldrsb.w	r3, [r7, #14]
  4015c4:	2b00      	cmp	r3, #0
  4015c6:	dce9      	bgt.n	40159c <prvUnlockQueue+0x7c>
  4015c8:	e000      	b.n	4015cc <prvUnlockQueue+0xac>

				--cRxLock;
			}
			else
			{
				break;
  4015ca:	bf00      	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
  4015cc:	687b      	ldr	r3, [r7, #4]
  4015ce:	22ff      	movs	r2, #255	; 0xff
  4015d0:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
  4015d4:	4b06      	ldr	r3, [pc, #24]	; (4015f0 <prvUnlockQueue+0xd0>)
  4015d6:	4798      	blx	r3
}
  4015d8:	bf00      	nop
  4015da:	3710      	adds	r7, #16
  4015dc:	46bd      	mov	sp, r7
  4015de:	bd80      	pop	{r7, pc}
  4015e0:	004004e9 	.word	0x004004e9
  4015e4:	00401775 	.word	0x00401775
  4015e8:	0040235d 	.word	0x0040235d
  4015ec:	00402171 	.word	0x00402171
  4015f0:	0040054d 	.word	0x0040054d

004015f4 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
  4015f4:	b580      	push	{r7, lr}
  4015f6:	b084      	sub	sp, #16
  4015f8:	af00      	add	r7, sp, #0
  4015fa:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
  4015fc:	4b08      	ldr	r3, [pc, #32]	; (401620 <prvIsQueueEmpty+0x2c>)
  4015fe:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
  401600:	687b      	ldr	r3, [r7, #4]
  401602:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  401604:	2b00      	cmp	r3, #0
  401606:	d102      	bne.n	40160e <prvIsQueueEmpty+0x1a>
		{
			xReturn = pdTRUE;
  401608:	2301      	movs	r3, #1
  40160a:	60fb      	str	r3, [r7, #12]
  40160c:	e001      	b.n	401612 <prvIsQueueEmpty+0x1e>
		}
		else
		{
			xReturn = pdFALSE;
  40160e:	2300      	movs	r3, #0
  401610:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
  401612:	4b04      	ldr	r3, [pc, #16]	; (401624 <prvIsQueueEmpty+0x30>)
  401614:	4798      	blx	r3

	return xReturn;
  401616:	68fb      	ldr	r3, [r7, #12]
}
  401618:	4618      	mov	r0, r3
  40161a:	3710      	adds	r7, #16
  40161c:	46bd      	mov	sp, r7
  40161e:	bd80      	pop	{r7, pc}
  401620:	004004e9 	.word	0x004004e9
  401624:	0040054d 	.word	0x0040054d

00401628 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
  401628:	b580      	push	{r7, lr}
  40162a:	b084      	sub	sp, #16
  40162c:	af00      	add	r7, sp, #0
  40162e:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
  401630:	4b09      	ldr	r3, [pc, #36]	; (401658 <prvIsQueueFull+0x30>)
  401632:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
  401634:	687b      	ldr	r3, [r7, #4]
  401636:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  401638:	687b      	ldr	r3, [r7, #4]
  40163a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  40163c:	429a      	cmp	r2, r3
  40163e:	d102      	bne.n	401646 <prvIsQueueFull+0x1e>
		{
			xReturn = pdTRUE;
  401640:	2301      	movs	r3, #1
  401642:	60fb      	str	r3, [r7, #12]
  401644:	e001      	b.n	40164a <prvIsQueueFull+0x22>
		}
		else
		{
			xReturn = pdFALSE;
  401646:	2300      	movs	r3, #0
  401648:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
  40164a:	4b04      	ldr	r3, [pc, #16]	; (40165c <prvIsQueueFull+0x34>)
  40164c:	4798      	blx	r3

	return xReturn;
  40164e:	68fb      	ldr	r3, [r7, #12]
}
  401650:	4618      	mov	r0, r3
  401652:	3710      	adds	r7, #16
  401654:	46bd      	mov	sp, r7
  401656:	bd80      	pop	{r7, pc}
  401658:	004004e9 	.word	0x004004e9
  40165c:	0040054d 	.word	0x0040054d

00401660 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
  401660:	b480      	push	{r7}
  401662:	b085      	sub	sp, #20
  401664:	af00      	add	r7, sp, #0
  401666:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	configASSERT( xQueue );
  401668:	687b      	ldr	r3, [r7, #4]
  40166a:	2b00      	cmp	r3, #0
  40166c:	d10b      	bne.n	401686 <xQueueIsQueueFullFromISR+0x26>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
  40166e:	f04f 0380 	mov.w	r3, #128	; 0x80
  401672:	b672      	cpsid	i
  401674:	f383 8811 	msr	BASEPRI, r3
  401678:	f3bf 8f6f 	isb	sy
  40167c:	f3bf 8f4f 	dsb	sy
  401680:	b662      	cpsie	i
  401682:	60bb      	str	r3, [r7, #8]
  401684:	e7fe      	b.n	401684 <xQueueIsQueueFullFromISR+0x24>
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
  401686:	687b      	ldr	r3, [r7, #4]
  401688:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  40168a:	687b      	ldr	r3, [r7, #4]
  40168c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  40168e:	429a      	cmp	r2, r3
  401690:	d102      	bne.n	401698 <xQueueIsQueueFullFromISR+0x38>
	{
		xReturn = pdTRUE;
  401692:	2301      	movs	r3, #1
  401694:	60fb      	str	r3, [r7, #12]
  401696:	e001      	b.n	40169c <xQueueIsQueueFullFromISR+0x3c>
	}
	else
	{
		xReturn = pdFALSE;
  401698:	2300      	movs	r3, #0
  40169a:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
  40169c:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
  40169e:	4618      	mov	r0, r3
  4016a0:	3714      	adds	r7, #20
  4016a2:	46bd      	mov	sp, r7
  4016a4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4016a8:	4770      	bx	lr
  4016aa:	bf00      	nop

004016ac <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
  4016ac:	b480      	push	{r7}
  4016ae:	b085      	sub	sp, #20
  4016b0:	af00      	add	r7, sp, #0
  4016b2:	6078      	str	r0, [r7, #4]
  4016b4:	6039      	str	r1, [r7, #0]
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
  4016b6:	2300      	movs	r3, #0
  4016b8:	60fb      	str	r3, [r7, #12]
  4016ba:	e014      	b.n	4016e6 <vQueueAddToRegistry+0x3a>
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
  4016bc:	4a0e      	ldr	r2, [pc, #56]	; (4016f8 <vQueueAddToRegistry+0x4c>)
  4016be:	68fb      	ldr	r3, [r7, #12]
  4016c0:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
  4016c4:	2b00      	cmp	r3, #0
  4016c6:	d10b      	bne.n	4016e0 <vQueueAddToRegistry+0x34>
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
  4016c8:	490b      	ldr	r1, [pc, #44]	; (4016f8 <vQueueAddToRegistry+0x4c>)
  4016ca:	68fb      	ldr	r3, [r7, #12]
  4016cc:	683a      	ldr	r2, [r7, #0]
  4016ce:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
  4016d2:	4a09      	ldr	r2, [pc, #36]	; (4016f8 <vQueueAddToRegistry+0x4c>)
  4016d4:	68fb      	ldr	r3, [r7, #12]
  4016d6:	00db      	lsls	r3, r3, #3
  4016d8:	4413      	add	r3, r2
  4016da:	687a      	ldr	r2, [r7, #4]
  4016dc:	605a      	str	r2, [r3, #4]

				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
				break;
  4016de:	e005      	b.n	4016ec <vQueueAddToRegistry+0x40>
	{
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
  4016e0:	68fb      	ldr	r3, [r7, #12]
  4016e2:	3301      	adds	r3, #1
  4016e4:	60fb      	str	r3, [r7, #12]
  4016e6:	68fb      	ldr	r3, [r7, #12]
  4016e8:	2b07      	cmp	r3, #7
  4016ea:	d9e7      	bls.n	4016bc <vQueueAddToRegistry+0x10>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
  4016ec:	bf00      	nop
  4016ee:	3714      	adds	r7, #20
  4016f0:	46bd      	mov	sp, r7
  4016f2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4016f6:	4770      	bx	lr
  4016f8:	2040c47c 	.word	0x2040c47c

004016fc <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
  4016fc:	b580      	push	{r7, lr}
  4016fe:	b086      	sub	sp, #24
  401700:	af00      	add	r7, sp, #0
  401702:	60f8      	str	r0, [r7, #12]
  401704:	60b9      	str	r1, [r7, #8]
  401706:	607a      	str	r2, [r7, #4]
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  401708:	68fb      	ldr	r3, [r7, #12]
  40170a:	617b      	str	r3, [r7, #20]
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
  40170c:	4b15      	ldr	r3, [pc, #84]	; (401764 <vQueueWaitForMessageRestricted+0x68>)
  40170e:	4798      	blx	r3
  401710:	697b      	ldr	r3, [r7, #20]
  401712:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
  401716:	b25b      	sxtb	r3, r3
  401718:	f1b3 3fff 	cmp.w	r3, #4294967295
  40171c:	d103      	bne.n	401726 <vQueueWaitForMessageRestricted+0x2a>
  40171e:	697b      	ldr	r3, [r7, #20]
  401720:	2200      	movs	r2, #0
  401722:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  401726:	697b      	ldr	r3, [r7, #20]
  401728:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
  40172c:	b25b      	sxtb	r3, r3
  40172e:	f1b3 3fff 	cmp.w	r3, #4294967295
  401732:	d103      	bne.n	40173c <vQueueWaitForMessageRestricted+0x40>
  401734:	697b      	ldr	r3, [r7, #20]
  401736:	2200      	movs	r2, #0
  401738:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
  40173c:	4b0a      	ldr	r3, [pc, #40]	; (401768 <vQueueWaitForMessageRestricted+0x6c>)
  40173e:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
  401740:	697b      	ldr	r3, [r7, #20]
  401742:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  401744:	2b00      	cmp	r3, #0
  401746:	d106      	bne.n	401756 <vQueueWaitForMessageRestricted+0x5a>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
  401748:	697b      	ldr	r3, [r7, #20]
  40174a:	3324      	adds	r3, #36	; 0x24
  40174c:	687a      	ldr	r2, [r7, #4]
  40174e:	68b9      	ldr	r1, [r7, #8]
  401750:	4618      	mov	r0, r3
  401752:	4b06      	ldr	r3, [pc, #24]	; (40176c <vQueueWaitForMessageRestricted+0x70>)
  401754:	4798      	blx	r3
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
  401756:	6978      	ldr	r0, [r7, #20]
  401758:	4b05      	ldr	r3, [pc, #20]	; (401770 <vQueueWaitForMessageRestricted+0x74>)
  40175a:	4798      	blx	r3
	}
  40175c:	bf00      	nop
  40175e:	3718      	adds	r7, #24
  401760:	46bd      	mov	sp, r7
  401762:	bd80      	pop	{r7, pc}
  401764:	004004e9 	.word	0x004004e9
  401768:	0040054d 	.word	0x0040054d
  40176c:	00402111 	.word	0x00402111
  401770:	00401521 	.word	0x00401521

00401774 <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
	{
  401774:	b580      	push	{r7, lr}
  401776:	b088      	sub	sp, #32
  401778:	af00      	add	r7, sp, #0
  40177a:	6078      	str	r0, [r7, #4]
  40177c:	6039      	str	r1, [r7, #0]
	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
  40177e:	687b      	ldr	r3, [r7, #4]
  401780:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  401782:	61bb      	str	r3, [r7, #24]
	BaseType_t xReturn = pdFALSE;
  401784:	2300      	movs	r3, #0
  401786:	61fb      	str	r3, [r7, #28]

		/* This function must be called form a critical section. */

		configASSERT( pxQueueSetContainer );
  401788:	69bb      	ldr	r3, [r7, #24]
  40178a:	2b00      	cmp	r3, #0
  40178c:	d10b      	bne.n	4017a6 <prvNotifyQueueSetContainer+0x32>
  40178e:	f04f 0380 	mov.w	r3, #128	; 0x80
  401792:	b672      	cpsid	i
  401794:	f383 8811 	msr	BASEPRI, r3
  401798:	f3bf 8f6f 	isb	sy
  40179c:	f3bf 8f4f 	dsb	sy
  4017a0:	b662      	cpsie	i
  4017a2:	60fb      	str	r3, [r7, #12]
  4017a4:	e7fe      	b.n	4017a4 <prvNotifyQueueSetContainer+0x30>
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
  4017a6:	69bb      	ldr	r3, [r7, #24]
  4017a8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  4017aa:	69bb      	ldr	r3, [r7, #24]
  4017ac:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  4017ae:	429a      	cmp	r2, r3
  4017b0:	d30b      	bcc.n	4017ca <prvNotifyQueueSetContainer+0x56>
  4017b2:	f04f 0380 	mov.w	r3, #128	; 0x80
  4017b6:	b672      	cpsid	i
  4017b8:	f383 8811 	msr	BASEPRI, r3
  4017bc:	f3bf 8f6f 	isb	sy
  4017c0:	f3bf 8f4f 	dsb	sy
  4017c4:	b662      	cpsie	i
  4017c6:	613b      	str	r3, [r7, #16]
  4017c8:	e7fe      	b.n	4017c8 <prvNotifyQueueSetContainer+0x54>

		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
  4017ca:	69bb      	ldr	r3, [r7, #24]
  4017cc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  4017ce:	69bb      	ldr	r3, [r7, #24]
  4017d0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  4017d2:	429a      	cmp	r2, r3
  4017d4:	d225      	bcs.n	401822 <prvNotifyQueueSetContainer+0xae>
		{
			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
  4017d6:	69bb      	ldr	r3, [r7, #24]
  4017d8:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
  4017dc:	75fb      	strb	r3, [r7, #23]

			traceQUEUE_SEND( pxQueueSetContainer );

			/* The data copied is the handle of the queue that contains data. */
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
  4017de:	1d3b      	adds	r3, r7, #4
  4017e0:	683a      	ldr	r2, [r7, #0]
  4017e2:	4619      	mov	r1, r3
  4017e4:	69b8      	ldr	r0, [r7, #24]
  4017e6:	4b11      	ldr	r3, [pc, #68]	; (40182c <prvNotifyQueueSetContainer+0xb8>)
  4017e8:	4798      	blx	r3
  4017ea:	61f8      	str	r0, [r7, #28]

			if( cTxLock == queueUNLOCKED )
  4017ec:	f997 3017 	ldrsb.w	r3, [r7, #23]
  4017f0:	f1b3 3fff 	cmp.w	r3, #4294967295
  4017f4:	d10e      	bne.n	401814 <prvNotifyQueueSetContainer+0xa0>
			{
				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
  4017f6:	69bb      	ldr	r3, [r7, #24]
  4017f8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  4017fa:	2b00      	cmp	r3, #0
  4017fc:	d011      	beq.n	401822 <prvNotifyQueueSetContainer+0xae>
				{
					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
  4017fe:	69bb      	ldr	r3, [r7, #24]
  401800:	3324      	adds	r3, #36	; 0x24
  401802:	4618      	mov	r0, r3
  401804:	4b0a      	ldr	r3, [pc, #40]	; (401830 <prvNotifyQueueSetContainer+0xbc>)
  401806:	4798      	blx	r3
  401808:	4603      	mov	r3, r0
  40180a:	2b00      	cmp	r3, #0
  40180c:	d009      	beq.n	401822 <prvNotifyQueueSetContainer+0xae>
					{
						/* The task waiting has a higher priority. */
						xReturn = pdTRUE;
  40180e:	2301      	movs	r3, #1
  401810:	61fb      	str	r3, [r7, #28]
  401812:	e006      	b.n	401822 <prvNotifyQueueSetContainer+0xae>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
  401814:	7dfb      	ldrb	r3, [r7, #23]
  401816:	3301      	adds	r3, #1
  401818:	b2db      	uxtb	r3, r3
  40181a:	b25a      	sxtb	r2, r3
  40181c:	69bb      	ldr	r3, [r7, #24]
  40181e:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
  401822:	69fb      	ldr	r3, [r7, #28]
	}
  401824:	4618      	mov	r0, r3
  401826:	3720      	adds	r7, #32
  401828:	46bd      	mov	sp, r7
  40182a:	bd80      	pop	{r7, pc}
  40182c:	004013f5 	.word	0x004013f5
  401830:	00402171 	.word	0x00402171

00401834 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
  401834:	b590      	push	{r4, r7, lr}
  401836:	b08d      	sub	sp, #52	; 0x34
  401838:	af04      	add	r7, sp, #16
  40183a:	60f8      	str	r0, [r7, #12]
  40183c:	60b9      	str	r1, [r7, #8]
  40183e:	603b      	str	r3, [r7, #0]
  401840:	4613      	mov	r3, r2
  401842:	80fb      	strh	r3, [r7, #6]
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  401844:	88fb      	ldrh	r3, [r7, #6]
  401846:	009b      	lsls	r3, r3, #2
  401848:	4618      	mov	r0, r3
  40184a:	4b1b      	ldr	r3, [pc, #108]	; (4018b8 <xTaskCreate+0x84>)
  40184c:	4798      	blx	r3
  40184e:	6178      	str	r0, [r7, #20]

			if( pxStack != NULL )
  401850:	697b      	ldr	r3, [r7, #20]
  401852:	2b00      	cmp	r3, #0
  401854:	d00e      	beq.n	401874 <xTaskCreate+0x40>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
  401856:	2058      	movs	r0, #88	; 0x58
  401858:	4b17      	ldr	r3, [pc, #92]	; (4018b8 <xTaskCreate+0x84>)
  40185a:	4798      	blx	r3
  40185c:	61f8      	str	r0, [r7, #28]

				if( pxNewTCB != NULL )
  40185e:	69fb      	ldr	r3, [r7, #28]
  401860:	2b00      	cmp	r3, #0
  401862:	d003      	beq.n	40186c <xTaskCreate+0x38>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
  401864:	69fb      	ldr	r3, [r7, #28]
  401866:	697a      	ldr	r2, [r7, #20]
  401868:	631a      	str	r2, [r3, #48]	; 0x30
  40186a:	e005      	b.n	401878 <xTaskCreate+0x44>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
  40186c:	6978      	ldr	r0, [r7, #20]
  40186e:	4b13      	ldr	r3, [pc, #76]	; (4018bc <xTaskCreate+0x88>)
  401870:	4798      	blx	r3
  401872:	e001      	b.n	401878 <xTaskCreate+0x44>
				}
			}
			else
			{
				pxNewTCB = NULL;
  401874:	2300      	movs	r3, #0
  401876:	61fb      	str	r3, [r7, #28]
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
  401878:	69fb      	ldr	r3, [r7, #28]
  40187a:	2b00      	cmp	r3, #0
  40187c:	d013      	beq.n	4018a6 <xTaskCreate+0x72>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
  40187e:	88fa      	ldrh	r2, [r7, #6]
  401880:	2300      	movs	r3, #0
  401882:	9303      	str	r3, [sp, #12]
  401884:	69fb      	ldr	r3, [r7, #28]
  401886:	9302      	str	r3, [sp, #8]
  401888:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40188a:	9301      	str	r3, [sp, #4]
  40188c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40188e:	9300      	str	r3, [sp, #0]
  401890:	683b      	ldr	r3, [r7, #0]
  401892:	68b9      	ldr	r1, [r7, #8]
  401894:	68f8      	ldr	r0, [r7, #12]
  401896:	4c0a      	ldr	r4, [pc, #40]	; (4018c0 <xTaskCreate+0x8c>)
  401898:	47a0      	blx	r4
			prvAddNewTaskToReadyList( pxNewTCB );
  40189a:	69f8      	ldr	r0, [r7, #28]
  40189c:	4b09      	ldr	r3, [pc, #36]	; (4018c4 <xTaskCreate+0x90>)
  40189e:	4798      	blx	r3
			xReturn = pdPASS;
  4018a0:	2301      	movs	r3, #1
  4018a2:	61bb      	str	r3, [r7, #24]
  4018a4:	e002      	b.n	4018ac <xTaskCreate+0x78>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
  4018a6:	f04f 33ff 	mov.w	r3, #4294967295
  4018aa:	61bb      	str	r3, [r7, #24]
		}

		return xReturn;
  4018ac:	69bb      	ldr	r3, [r7, #24]
	}
  4018ae:	4618      	mov	r0, r3
  4018b0:	3724      	adds	r7, #36	; 0x24
  4018b2:	46bd      	mov	sp, r7
  4018b4:	bd90      	pop	{r4, r7, pc}
  4018b6:	bf00      	nop
  4018b8:	00400711 	.word	0x00400711
  4018bc:	004008bd 	.word	0x004008bd
  4018c0:	004018c9 	.word	0x004018c9
  4018c4:	004019e5 	.word	0x004019e5

004018c8 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
  4018c8:	b580      	push	{r7, lr}
  4018ca:	b088      	sub	sp, #32
  4018cc:	af00      	add	r7, sp, #0
  4018ce:	60f8      	str	r0, [r7, #12]
  4018d0:	60b9      	str	r1, [r7, #8]
  4018d2:	607a      	str	r2, [r7, #4]
  4018d4:	603b      	str	r3, [r7, #0]

	/* Avoid dependency on memset() if it is not required. */
	#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
  4018d6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  4018d8:	6b18      	ldr	r0, [r3, #48]	; 0x30
  4018da:	687b      	ldr	r3, [r7, #4]
  4018dc:	009b      	lsls	r3, r3, #2
  4018de:	461a      	mov	r2, r3
  4018e0:	21a5      	movs	r1, #165	; 0xa5
  4018e2:	4b3d      	ldr	r3, [pc, #244]	; (4019d8 <prvInitialiseNewTask+0x110>)
  4018e4:	4798      	blx	r3
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
  4018e6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  4018e8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  4018ea:	6879      	ldr	r1, [r7, #4]
  4018ec:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
  4018f0:	440b      	add	r3, r1
  4018f2:	009b      	lsls	r3, r3, #2
  4018f4:	4413      	add	r3, r2
  4018f6:	61bb      	str	r3, [r7, #24]
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
  4018f8:	69bb      	ldr	r3, [r7, #24]
  4018fa:	f023 0307 	bic.w	r3, r3, #7
  4018fe:	61bb      	str	r3, [r7, #24]

		/* Check the alignment of the calculated top of stack is correct. */
		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
  401900:	69bb      	ldr	r3, [r7, #24]
  401902:	f003 0307 	and.w	r3, r3, #7
  401906:	2b00      	cmp	r3, #0
  401908:	d00b      	beq.n	401922 <prvInitialiseNewTask+0x5a>
  40190a:	f04f 0380 	mov.w	r3, #128	; 0x80
  40190e:	b672      	cpsid	i
  401910:	f383 8811 	msr	BASEPRI, r3
  401914:	f3bf 8f6f 	isb	sy
  401918:	f3bf 8f4f 	dsb	sy
  40191c:	b662      	cpsie	i
  40191e:	617b      	str	r3, [r7, #20]
  401920:	e7fe      	b.n	401920 <prvInitialiseNewTask+0x58>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
  401922:	2300      	movs	r3, #0
  401924:	61fb      	str	r3, [r7, #28]
  401926:	e012      	b.n	40194e <prvInitialiseNewTask+0x86>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
  401928:	68ba      	ldr	r2, [r7, #8]
  40192a:	69fb      	ldr	r3, [r7, #28]
  40192c:	4413      	add	r3, r2
  40192e:	7819      	ldrb	r1, [r3, #0]
  401930:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  401932:	69fb      	ldr	r3, [r7, #28]
  401934:	4413      	add	r3, r2
  401936:	3334      	adds	r3, #52	; 0x34
  401938:	460a      	mov	r2, r1
  40193a:	701a      	strb	r2, [r3, #0]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
  40193c:	68ba      	ldr	r2, [r7, #8]
  40193e:	69fb      	ldr	r3, [r7, #28]
  401940:	4413      	add	r3, r2
  401942:	781b      	ldrb	r3, [r3, #0]
  401944:	2b00      	cmp	r3, #0
  401946:	d006      	beq.n	401956 <prvInitialiseNewTask+0x8e>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
  401948:	69fb      	ldr	r3, [r7, #28]
  40194a:	3301      	adds	r3, #1
  40194c:	61fb      	str	r3, [r7, #28]
  40194e:	69fb      	ldr	r3, [r7, #28]
  401950:	2b09      	cmp	r3, #9
  401952:	d9e9      	bls.n	401928 <prvInitialiseNewTask+0x60>
  401954:	e000      	b.n	401958 <prvInitialiseNewTask+0x90>
		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
		{
			break;
  401956:	bf00      	nop
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
  401958:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40195a:	2200      	movs	r2, #0
  40195c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
  401960:	6abb      	ldr	r3, [r7, #40]	; 0x28
  401962:	2b04      	cmp	r3, #4
  401964:	d901      	bls.n	40196a <prvInitialiseNewTask+0xa2>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
  401966:	2304      	movs	r3, #4
  401968:	62bb      	str	r3, [r7, #40]	; 0x28
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
  40196a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40196c:	6aba      	ldr	r2, [r7, #40]	; 0x28
  40196e:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
  401970:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401972:	6aba      	ldr	r2, [r7, #40]	; 0x28
  401974:	649a      	str	r2, [r3, #72]	; 0x48
		pxNewTCB->uxMutexesHeld = 0;
  401976:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401978:	2200      	movs	r2, #0
  40197a:	64da      	str	r2, [r3, #76]	; 0x4c
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
  40197c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40197e:	3304      	adds	r3, #4
  401980:	4618      	mov	r0, r3
  401982:	4b16      	ldr	r3, [pc, #88]	; (4019dc <prvInitialiseNewTask+0x114>)
  401984:	4798      	blx	r3
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
  401986:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401988:	3318      	adds	r3, #24
  40198a:	4618      	mov	r0, r3
  40198c:	4b13      	ldr	r3, [pc, #76]	; (4019dc <prvInitialiseNewTask+0x114>)
  40198e:	4798      	blx	r3

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
  401990:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  401992:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  401994:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  401996:	6abb      	ldr	r3, [r7, #40]	; 0x28
  401998:	f1c3 0205 	rsb	r2, r3, #5
  40199c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40199e:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
  4019a0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  4019a2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  4019a4:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
  4019a6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  4019a8:	2200      	movs	r2, #0
  4019aa:	651a      	str	r2, [r3, #80]	; 0x50
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  4019ac:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  4019ae:	2200      	movs	r2, #0
  4019b0:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
  4019b4:	683a      	ldr	r2, [r7, #0]
  4019b6:	68f9      	ldr	r1, [r7, #12]
  4019b8:	69b8      	ldr	r0, [r7, #24]
  4019ba:	4b09      	ldr	r3, [pc, #36]	; (4019e0 <prvInitialiseNewTask+0x118>)
  4019bc:	4798      	blx	r3
  4019be:	4602      	mov	r2, r0
  4019c0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  4019c2:	601a      	str	r2, [r3, #0]
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
  4019c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4019c6:	2b00      	cmp	r3, #0
  4019c8:	d002      	beq.n	4019d0 <prvInitialiseNewTask+0x108>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
  4019ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4019cc:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  4019ce:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
  4019d0:	bf00      	nop
  4019d2:	3720      	adds	r7, #32
  4019d4:	46bd      	mov	sp, r7
  4019d6:	bd80      	pop	{r7, pc}
  4019d8:	00404e41 	.word	0x00404e41
  4019dc:	004001dd 	.word	0x004001dd
  4019e0:	00400309 	.word	0x00400309

004019e4 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
  4019e4:	b580      	push	{r7, lr}
  4019e6:	b082      	sub	sp, #8
  4019e8:	af00      	add	r7, sp, #0
  4019ea:	6078      	str	r0, [r7, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
  4019ec:	4b2d      	ldr	r3, [pc, #180]	; (401aa4 <prvAddNewTaskToReadyList+0xc0>)
  4019ee:	4798      	blx	r3
	{
		uxCurrentNumberOfTasks++;
  4019f0:	4b2d      	ldr	r3, [pc, #180]	; (401aa8 <prvAddNewTaskToReadyList+0xc4>)
  4019f2:	681b      	ldr	r3, [r3, #0]
  4019f4:	3301      	adds	r3, #1
  4019f6:	4a2c      	ldr	r2, [pc, #176]	; (401aa8 <prvAddNewTaskToReadyList+0xc4>)
  4019f8:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
  4019fa:	4b2c      	ldr	r3, [pc, #176]	; (401aac <prvAddNewTaskToReadyList+0xc8>)
  4019fc:	681b      	ldr	r3, [r3, #0]
  4019fe:	2b00      	cmp	r3, #0
  401a00:	d109      	bne.n	401a16 <prvAddNewTaskToReadyList+0x32>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
  401a02:	4a2a      	ldr	r2, [pc, #168]	; (401aac <prvAddNewTaskToReadyList+0xc8>)
  401a04:	687b      	ldr	r3, [r7, #4]
  401a06:	6013      	str	r3, [r2, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
  401a08:	4b27      	ldr	r3, [pc, #156]	; (401aa8 <prvAddNewTaskToReadyList+0xc4>)
  401a0a:	681b      	ldr	r3, [r3, #0]
  401a0c:	2b01      	cmp	r3, #1
  401a0e:	d110      	bne.n	401a32 <prvAddNewTaskToReadyList+0x4e>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
  401a10:	4b27      	ldr	r3, [pc, #156]	; (401ab0 <prvAddNewTaskToReadyList+0xcc>)
  401a12:	4798      	blx	r3
  401a14:	e00d      	b.n	401a32 <prvAddNewTaskToReadyList+0x4e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
  401a16:	4b27      	ldr	r3, [pc, #156]	; (401ab4 <prvAddNewTaskToReadyList+0xd0>)
  401a18:	681b      	ldr	r3, [r3, #0]
  401a1a:	2b00      	cmp	r3, #0
  401a1c:	d109      	bne.n	401a32 <prvAddNewTaskToReadyList+0x4e>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
  401a1e:	4b23      	ldr	r3, [pc, #140]	; (401aac <prvAddNewTaskToReadyList+0xc8>)
  401a20:	681b      	ldr	r3, [r3, #0]
  401a22:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  401a24:	687b      	ldr	r3, [r7, #4]
  401a26:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  401a28:	429a      	cmp	r2, r3
  401a2a:	d802      	bhi.n	401a32 <prvAddNewTaskToReadyList+0x4e>
				{
					pxCurrentTCB = pxNewTCB;
  401a2c:	4a1f      	ldr	r2, [pc, #124]	; (401aac <prvAddNewTaskToReadyList+0xc8>)
  401a2e:	687b      	ldr	r3, [r7, #4]
  401a30:	6013      	str	r3, [r2, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
  401a32:	4b21      	ldr	r3, [pc, #132]	; (401ab8 <prvAddNewTaskToReadyList+0xd4>)
  401a34:	681b      	ldr	r3, [r3, #0]
  401a36:	3301      	adds	r3, #1
  401a38:	4a1f      	ldr	r2, [pc, #124]	; (401ab8 <prvAddNewTaskToReadyList+0xd4>)
  401a3a:	6013      	str	r3, [r2, #0]

		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			/* Add a counter into the TCB for tracing only. */
			pxNewTCB->uxTCBNumber = uxTaskNumber;
  401a3c:	4b1e      	ldr	r3, [pc, #120]	; (401ab8 <prvAddNewTaskToReadyList+0xd4>)
  401a3e:	681a      	ldr	r2, [r3, #0]
  401a40:	687b      	ldr	r3, [r7, #4]
  401a42:	641a      	str	r2, [r3, #64]	; 0x40
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
  401a44:	687b      	ldr	r3, [r7, #4]
  401a46:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  401a48:	2201      	movs	r2, #1
  401a4a:	409a      	lsls	r2, r3
  401a4c:	4b1b      	ldr	r3, [pc, #108]	; (401abc <prvAddNewTaskToReadyList+0xd8>)
  401a4e:	681b      	ldr	r3, [r3, #0]
  401a50:	4313      	orrs	r3, r2
  401a52:	4a1a      	ldr	r2, [pc, #104]	; (401abc <prvAddNewTaskToReadyList+0xd8>)
  401a54:	6013      	str	r3, [r2, #0]
  401a56:	687b      	ldr	r3, [r7, #4]
  401a58:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  401a5a:	4613      	mov	r3, r2
  401a5c:	009b      	lsls	r3, r3, #2
  401a5e:	4413      	add	r3, r2
  401a60:	009b      	lsls	r3, r3, #2
  401a62:	4a17      	ldr	r2, [pc, #92]	; (401ac0 <prvAddNewTaskToReadyList+0xdc>)
  401a64:	441a      	add	r2, r3
  401a66:	687b      	ldr	r3, [r7, #4]
  401a68:	3304      	adds	r3, #4
  401a6a:	4619      	mov	r1, r3
  401a6c:	4610      	mov	r0, r2
  401a6e:	4b15      	ldr	r3, [pc, #84]	; (401ac4 <prvAddNewTaskToReadyList+0xe0>)
  401a70:	4798      	blx	r3

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
  401a72:	4b15      	ldr	r3, [pc, #84]	; (401ac8 <prvAddNewTaskToReadyList+0xe4>)
  401a74:	4798      	blx	r3

	if( xSchedulerRunning != pdFALSE )
  401a76:	4b0f      	ldr	r3, [pc, #60]	; (401ab4 <prvAddNewTaskToReadyList+0xd0>)
  401a78:	681b      	ldr	r3, [r3, #0]
  401a7a:	2b00      	cmp	r3, #0
  401a7c:	d00e      	beq.n	401a9c <prvAddNewTaskToReadyList+0xb8>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
  401a7e:	4b0b      	ldr	r3, [pc, #44]	; (401aac <prvAddNewTaskToReadyList+0xc8>)
  401a80:	681b      	ldr	r3, [r3, #0]
  401a82:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  401a84:	687b      	ldr	r3, [r7, #4]
  401a86:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  401a88:	429a      	cmp	r2, r3
  401a8a:	d207      	bcs.n	401a9c <prvAddNewTaskToReadyList+0xb8>
		{
			taskYIELD_IF_USING_PREEMPTION();
  401a8c:	4b0f      	ldr	r3, [pc, #60]	; (401acc <prvAddNewTaskToReadyList+0xe8>)
  401a8e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  401a92:	601a      	str	r2, [r3, #0]
  401a94:	f3bf 8f4f 	dsb	sy
  401a98:	f3bf 8f6f 	isb	sy
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
  401a9c:	bf00      	nop
  401a9e:	3708      	adds	r7, #8
  401aa0:	46bd      	mov	sp, r7
  401aa2:	bd80      	pop	{r7, pc}
  401aa4:	004004e9 	.word	0x004004e9
  401aa8:	2040c1d4 	.word	0x2040c1d4
  401aac:	2040c0fc 	.word	0x2040c0fc
  401ab0:	004023a9 	.word	0x004023a9
  401ab4:	2040c1e0 	.word	0x2040c1e0
  401ab8:	2040c1f0 	.word	0x2040c1f0
  401abc:	2040c1dc 	.word	0x2040c1dc
  401ac0:	2040c100 	.word	0x2040c100
  401ac4:	004001f9 	.word	0x004001f9
  401ac8:	0040054d 	.word	0x0040054d
  401acc:	e000ed04 	.word	0xe000ed04

00401ad0 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
  401ad0:	b580      	push	{r7, lr}
  401ad2:	b08a      	sub	sp, #40	; 0x28
  401ad4:	af00      	add	r7, sp, #0
  401ad6:	6078      	str	r0, [r7, #4]
  401ad8:	6039      	str	r1, [r7, #0]
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
  401ada:	2300      	movs	r3, #0
  401adc:	627b      	str	r3, [r7, #36]	; 0x24

		configASSERT( pxPreviousWakeTime );
  401ade:	687b      	ldr	r3, [r7, #4]
  401ae0:	2b00      	cmp	r3, #0
  401ae2:	d10b      	bne.n	401afc <vTaskDelayUntil+0x2c>
  401ae4:	f04f 0380 	mov.w	r3, #128	; 0x80
  401ae8:	b672      	cpsid	i
  401aea:	f383 8811 	msr	BASEPRI, r3
  401aee:	f3bf 8f6f 	isb	sy
  401af2:	f3bf 8f4f 	dsb	sy
  401af6:	b662      	cpsie	i
  401af8:	60fb      	str	r3, [r7, #12]
  401afa:	e7fe      	b.n	401afa <vTaskDelayUntil+0x2a>
		configASSERT( ( xTimeIncrement > 0U ) );
  401afc:	683b      	ldr	r3, [r7, #0]
  401afe:	2b00      	cmp	r3, #0
  401b00:	d10b      	bne.n	401b1a <vTaskDelayUntil+0x4a>
  401b02:	f04f 0380 	mov.w	r3, #128	; 0x80
  401b06:	b672      	cpsid	i
  401b08:	f383 8811 	msr	BASEPRI, r3
  401b0c:	f3bf 8f6f 	isb	sy
  401b10:	f3bf 8f4f 	dsb	sy
  401b14:	b662      	cpsie	i
  401b16:	613b      	str	r3, [r7, #16]
  401b18:	e7fe      	b.n	401b18 <vTaskDelayUntil+0x48>
		configASSERT( uxSchedulerSuspended == 0 );
  401b1a:	4b2a      	ldr	r3, [pc, #168]	; (401bc4 <vTaskDelayUntil+0xf4>)
  401b1c:	681b      	ldr	r3, [r3, #0]
  401b1e:	2b00      	cmp	r3, #0
  401b20:	d00b      	beq.n	401b3a <vTaskDelayUntil+0x6a>
  401b22:	f04f 0380 	mov.w	r3, #128	; 0x80
  401b26:	b672      	cpsid	i
  401b28:	f383 8811 	msr	BASEPRI, r3
  401b2c:	f3bf 8f6f 	isb	sy
  401b30:	f3bf 8f4f 	dsb	sy
  401b34:	b662      	cpsie	i
  401b36:	617b      	str	r3, [r7, #20]
  401b38:	e7fe      	b.n	401b38 <vTaskDelayUntil+0x68>

		vTaskSuspendAll();
  401b3a:	4b23      	ldr	r3, [pc, #140]	; (401bc8 <vTaskDelayUntil+0xf8>)
  401b3c:	4798      	blx	r3
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
  401b3e:	4b23      	ldr	r3, [pc, #140]	; (401bcc <vTaskDelayUntil+0xfc>)
  401b40:	681b      	ldr	r3, [r3, #0]
  401b42:	623b      	str	r3, [r7, #32]

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
  401b44:	687b      	ldr	r3, [r7, #4]
  401b46:	681a      	ldr	r2, [r3, #0]
  401b48:	683b      	ldr	r3, [r7, #0]
  401b4a:	4413      	add	r3, r2
  401b4c:	61fb      	str	r3, [r7, #28]

			if( xConstTickCount < *pxPreviousWakeTime )
  401b4e:	687b      	ldr	r3, [r7, #4]
  401b50:	681a      	ldr	r2, [r3, #0]
  401b52:	6a3b      	ldr	r3, [r7, #32]
  401b54:	429a      	cmp	r2, r3
  401b56:	d90b      	bls.n	401b70 <vTaskDelayUntil+0xa0>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
  401b58:	687b      	ldr	r3, [r7, #4]
  401b5a:	681a      	ldr	r2, [r3, #0]
  401b5c:	69fb      	ldr	r3, [r7, #28]
  401b5e:	429a      	cmp	r2, r3
  401b60:	d911      	bls.n	401b86 <vTaskDelayUntil+0xb6>
  401b62:	69fa      	ldr	r2, [r7, #28]
  401b64:	6a3b      	ldr	r3, [r7, #32]
  401b66:	429a      	cmp	r2, r3
  401b68:	d90d      	bls.n	401b86 <vTaskDelayUntil+0xb6>
				{
					xShouldDelay = pdTRUE;
  401b6a:	2301      	movs	r3, #1
  401b6c:	627b      	str	r3, [r7, #36]	; 0x24
  401b6e:	e00a      	b.n	401b86 <vTaskDelayUntil+0xb6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
  401b70:	687b      	ldr	r3, [r7, #4]
  401b72:	681a      	ldr	r2, [r3, #0]
  401b74:	69fb      	ldr	r3, [r7, #28]
  401b76:	429a      	cmp	r2, r3
  401b78:	d803      	bhi.n	401b82 <vTaskDelayUntil+0xb2>
  401b7a:	69fa      	ldr	r2, [r7, #28]
  401b7c:	6a3b      	ldr	r3, [r7, #32]
  401b7e:	429a      	cmp	r2, r3
  401b80:	d901      	bls.n	401b86 <vTaskDelayUntil+0xb6>
				{
					xShouldDelay = pdTRUE;
  401b82:	2301      	movs	r3, #1
  401b84:	627b      	str	r3, [r7, #36]	; 0x24
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
  401b86:	687b      	ldr	r3, [r7, #4]
  401b88:	69fa      	ldr	r2, [r7, #28]
  401b8a:	601a      	str	r2, [r3, #0]

			if( xShouldDelay != pdFALSE )
  401b8c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401b8e:	2b00      	cmp	r3, #0
  401b90:	d006      	beq.n	401ba0 <vTaskDelayUntil+0xd0>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
  401b92:	69fa      	ldr	r2, [r7, #28]
  401b94:	6a3b      	ldr	r3, [r7, #32]
  401b96:	1ad3      	subs	r3, r2, r3
  401b98:	2100      	movs	r1, #0
  401b9a:	4618      	mov	r0, r3
  401b9c:	4b0c      	ldr	r3, [pc, #48]	; (401bd0 <vTaskDelayUntil+0x100>)
  401b9e:	4798      	blx	r3
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
  401ba0:	4b0c      	ldr	r3, [pc, #48]	; (401bd4 <vTaskDelayUntil+0x104>)
  401ba2:	4798      	blx	r3
  401ba4:	61b8      	str	r0, [r7, #24]

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
  401ba6:	69bb      	ldr	r3, [r7, #24]
  401ba8:	2b00      	cmp	r3, #0
  401baa:	d107      	bne.n	401bbc <vTaskDelayUntil+0xec>
		{
			portYIELD_WITHIN_API();
  401bac:	4b0a      	ldr	r3, [pc, #40]	; (401bd8 <vTaskDelayUntil+0x108>)
  401bae:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  401bb2:	601a      	str	r2, [r3, #0]
  401bb4:	f3bf 8f4f 	dsb	sy
  401bb8:	f3bf 8f6f 	isb	sy
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  401bbc:	bf00      	nop
  401bbe:	3728      	adds	r7, #40	; 0x28
  401bc0:	46bd      	mov	sp, r7
  401bc2:	bd80      	pop	{r7, pc}
  401bc4:	2040c1fc 	.word	0x2040c1fc
  401bc8:	00401c89 	.word	0x00401c89
  401bcc:	2040c1d8 	.word	0x2040c1d8
  401bd0:	0040279d 	.word	0x0040279d
  401bd4:	00401ca5 	.word	0x00401ca5
  401bd8:	e000ed04 	.word	0xe000ed04

00401bdc <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
  401bdc:	b590      	push	{r4, r7, lr}
  401bde:	b087      	sub	sp, #28
  401be0:	af02      	add	r7, sp, #8
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
  401be2:	4b20      	ldr	r3, [pc, #128]	; (401c64 <vTaskStartScheduler+0x88>)
  401be4:	9301      	str	r3, [sp, #4]
  401be6:	2300      	movs	r3, #0
  401be8:	9300      	str	r3, [sp, #0]
  401bea:	2300      	movs	r3, #0
  401bec:	2282      	movs	r2, #130	; 0x82
  401bee:	491e      	ldr	r1, [pc, #120]	; (401c68 <vTaskStartScheduler+0x8c>)
  401bf0:	481e      	ldr	r0, [pc, #120]	; (401c6c <vTaskStartScheduler+0x90>)
  401bf2:	4c1f      	ldr	r4, [pc, #124]	; (401c70 <vTaskStartScheduler+0x94>)
  401bf4:	47a0      	blx	r4
  401bf6:	60f8      	str	r0, [r7, #12]
	}
	#endif /* configSUPPORT_STATIC_ALLOCATION */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
  401bf8:	68fb      	ldr	r3, [r7, #12]
  401bfa:	2b01      	cmp	r3, #1
  401bfc:	d102      	bne.n	401c04 <vTaskStartScheduler+0x28>
		{
			xReturn = xTimerCreateTimerTask();
  401bfe:	4b1d      	ldr	r3, [pc, #116]	; (401c74 <vTaskStartScheduler+0x98>)
  401c00:	4798      	blx	r3
  401c02:	60f8      	str	r0, [r7, #12]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
  401c04:	68fb      	ldr	r3, [r7, #12]
  401c06:	2b01      	cmp	r3, #1
  401c08:	d117      	bne.n	401c3a <vTaskStartScheduler+0x5e>
  401c0a:	f04f 0380 	mov.w	r3, #128	; 0x80
  401c0e:	b672      	cpsid	i
  401c10:	f383 8811 	msr	BASEPRI, r3
  401c14:	f3bf 8f6f 	isb	sy
  401c18:	f3bf 8f4f 	dsb	sy
  401c1c:	b662      	cpsie	i
  401c1e:	607b      	str	r3, [r7, #4]
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
  401c20:	4b15      	ldr	r3, [pc, #84]	; (401c78 <vTaskStartScheduler+0x9c>)
  401c22:	f04f 32ff 	mov.w	r2, #4294967295
  401c26:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
  401c28:	4b14      	ldr	r3, [pc, #80]	; (401c7c <vTaskStartScheduler+0xa0>)
  401c2a:	2201      	movs	r2, #1
  401c2c:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
  401c2e:	4b14      	ldr	r3, [pc, #80]	; (401c80 <vTaskStartScheduler+0xa4>)
  401c30:	2200      	movs	r2, #0
  401c32:	601a      	str	r2, [r3, #0]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
  401c34:	4b13      	ldr	r3, [pc, #76]	; (401c84 <vTaskStartScheduler+0xa8>)
  401c36:	4798      	blx	r3
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
  401c38:	e00f      	b.n	401c5a <vTaskStartScheduler+0x7e>
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
  401c3a:	68fb      	ldr	r3, [r7, #12]
  401c3c:	f1b3 3fff 	cmp.w	r3, #4294967295
  401c40:	d10b      	bne.n	401c5a <vTaskStartScheduler+0x7e>
  401c42:	f04f 0380 	mov.w	r3, #128	; 0x80
  401c46:	b672      	cpsid	i
  401c48:	f383 8811 	msr	BASEPRI, r3
  401c4c:	f3bf 8f6f 	isb	sy
  401c50:	f3bf 8f4f 	dsb	sy
  401c54:	b662      	cpsie	i
  401c56:	60bb      	str	r3, [r7, #8]
  401c58:	e7fe      	b.n	401c58 <vTaskStartScheduler+0x7c>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
  401c5a:	bf00      	nop
  401c5c:	3714      	adds	r7, #20
  401c5e:	46bd      	mov	sp, r7
  401c60:	bd90      	pop	{r4, r7, pc}
  401c62:	bf00      	nop
  401c64:	2040c1f8 	.word	0x2040c1f8
  401c68:	0040aba8 	.word	0x0040aba8
  401c6c:	00402375 	.word	0x00402375
  401c70:	00401835 	.word	0x00401835
  401c74:	00402875 	.word	0x00402875
  401c78:	2040c1f4 	.word	0x2040c1f4
  401c7c:	2040c1e0 	.word	0x2040c1e0
  401c80:	2040c1d8 	.word	0x2040c1d8
  401c84:	00400409 	.word	0x00400409

00401c88 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
  401c88:	b480      	push	{r7}
  401c8a:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
  401c8c:	4b04      	ldr	r3, [pc, #16]	; (401ca0 <vTaskSuspendAll+0x18>)
  401c8e:	681b      	ldr	r3, [r3, #0]
  401c90:	3301      	adds	r3, #1
  401c92:	4a03      	ldr	r2, [pc, #12]	; (401ca0 <vTaskSuspendAll+0x18>)
  401c94:	6013      	str	r3, [r2, #0]
}
  401c96:	bf00      	nop
  401c98:	46bd      	mov	sp, r7
  401c9a:	f85d 7b04 	ldr.w	r7, [sp], #4
  401c9e:	4770      	bx	lr
  401ca0:	2040c1fc 	.word	0x2040c1fc

00401ca4 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
  401ca4:	b580      	push	{r7, lr}
  401ca6:	b084      	sub	sp, #16
  401ca8:	af00      	add	r7, sp, #0
TCB_t *pxTCB = NULL;
  401caa:	2300      	movs	r3, #0
  401cac:	60fb      	str	r3, [r7, #12]
BaseType_t xAlreadyYielded = pdFALSE;
  401cae:	2300      	movs	r3, #0
  401cb0:	60bb      	str	r3, [r7, #8]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
  401cb2:	4b42      	ldr	r3, [pc, #264]	; (401dbc <xTaskResumeAll+0x118>)
  401cb4:	681b      	ldr	r3, [r3, #0]
  401cb6:	2b00      	cmp	r3, #0
  401cb8:	d10b      	bne.n	401cd2 <xTaskResumeAll+0x2e>
  401cba:	f04f 0380 	mov.w	r3, #128	; 0x80
  401cbe:	b672      	cpsid	i
  401cc0:	f383 8811 	msr	BASEPRI, r3
  401cc4:	f3bf 8f6f 	isb	sy
  401cc8:	f3bf 8f4f 	dsb	sy
  401ccc:	b662      	cpsie	i
  401cce:	603b      	str	r3, [r7, #0]
  401cd0:	e7fe      	b.n	401cd0 <xTaskResumeAll+0x2c>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
  401cd2:	4b3b      	ldr	r3, [pc, #236]	; (401dc0 <xTaskResumeAll+0x11c>)
  401cd4:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
  401cd6:	4b39      	ldr	r3, [pc, #228]	; (401dbc <xTaskResumeAll+0x118>)
  401cd8:	681b      	ldr	r3, [r3, #0]
  401cda:	3b01      	subs	r3, #1
  401cdc:	4a37      	ldr	r2, [pc, #220]	; (401dbc <xTaskResumeAll+0x118>)
  401cde:	6013      	str	r3, [r2, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  401ce0:	4b36      	ldr	r3, [pc, #216]	; (401dbc <xTaskResumeAll+0x118>)
  401ce2:	681b      	ldr	r3, [r3, #0]
  401ce4:	2b00      	cmp	r3, #0
  401ce6:	d161      	bne.n	401dac <xTaskResumeAll+0x108>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
  401ce8:	4b36      	ldr	r3, [pc, #216]	; (401dc4 <xTaskResumeAll+0x120>)
  401cea:	681b      	ldr	r3, [r3, #0]
  401cec:	2b00      	cmp	r3, #0
  401cee:	d05d      	beq.n	401dac <xTaskResumeAll+0x108>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  401cf0:	e02e      	b.n	401d50 <xTaskResumeAll+0xac>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
  401cf2:	4b35      	ldr	r3, [pc, #212]	; (401dc8 <xTaskResumeAll+0x124>)
  401cf4:	68db      	ldr	r3, [r3, #12]
  401cf6:	68db      	ldr	r3, [r3, #12]
  401cf8:	60fb      	str	r3, [r7, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  401cfa:	68fb      	ldr	r3, [r7, #12]
  401cfc:	3318      	adds	r3, #24
  401cfe:	4618      	mov	r0, r3
  401d00:	4b32      	ldr	r3, [pc, #200]	; (401dcc <xTaskResumeAll+0x128>)
  401d02:	4798      	blx	r3
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  401d04:	68fb      	ldr	r3, [r7, #12]
  401d06:	3304      	adds	r3, #4
  401d08:	4618      	mov	r0, r3
  401d0a:	4b30      	ldr	r3, [pc, #192]	; (401dcc <xTaskResumeAll+0x128>)
  401d0c:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
  401d0e:	68fb      	ldr	r3, [r7, #12]
  401d10:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  401d12:	2201      	movs	r2, #1
  401d14:	409a      	lsls	r2, r3
  401d16:	4b2e      	ldr	r3, [pc, #184]	; (401dd0 <xTaskResumeAll+0x12c>)
  401d18:	681b      	ldr	r3, [r3, #0]
  401d1a:	4313      	orrs	r3, r2
  401d1c:	4a2c      	ldr	r2, [pc, #176]	; (401dd0 <xTaskResumeAll+0x12c>)
  401d1e:	6013      	str	r3, [r2, #0]
  401d20:	68fb      	ldr	r3, [r7, #12]
  401d22:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  401d24:	4613      	mov	r3, r2
  401d26:	009b      	lsls	r3, r3, #2
  401d28:	4413      	add	r3, r2
  401d2a:	009b      	lsls	r3, r3, #2
  401d2c:	4a29      	ldr	r2, [pc, #164]	; (401dd4 <xTaskResumeAll+0x130>)
  401d2e:	441a      	add	r2, r3
  401d30:	68fb      	ldr	r3, [r7, #12]
  401d32:	3304      	adds	r3, #4
  401d34:	4619      	mov	r1, r3
  401d36:	4610      	mov	r0, r2
  401d38:	4b27      	ldr	r3, [pc, #156]	; (401dd8 <xTaskResumeAll+0x134>)
  401d3a:	4798      	blx	r3

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  401d3c:	68fb      	ldr	r3, [r7, #12]
  401d3e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  401d40:	4b26      	ldr	r3, [pc, #152]	; (401ddc <xTaskResumeAll+0x138>)
  401d42:	681b      	ldr	r3, [r3, #0]
  401d44:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  401d46:	429a      	cmp	r2, r3
  401d48:	d302      	bcc.n	401d50 <xTaskResumeAll+0xac>
					{
						xYieldPending = pdTRUE;
  401d4a:	4b25      	ldr	r3, [pc, #148]	; (401de0 <xTaskResumeAll+0x13c>)
  401d4c:	2201      	movs	r2, #1
  401d4e:	601a      	str	r2, [r3, #0]
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  401d50:	4b1d      	ldr	r3, [pc, #116]	; (401dc8 <xTaskResumeAll+0x124>)
  401d52:	681b      	ldr	r3, [r3, #0]
  401d54:	2b00      	cmp	r3, #0
  401d56:	d1cc      	bne.n	401cf2 <xTaskResumeAll+0x4e>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
  401d58:	68fb      	ldr	r3, [r7, #12]
  401d5a:	2b00      	cmp	r3, #0
  401d5c:	d001      	beq.n	401d62 <xTaskResumeAll+0xbe>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
  401d5e:	4b21      	ldr	r3, [pc, #132]	; (401de4 <xTaskResumeAll+0x140>)
  401d60:	4798      	blx	r3
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
  401d62:	4b21      	ldr	r3, [pc, #132]	; (401de8 <xTaskResumeAll+0x144>)
  401d64:	681b      	ldr	r3, [r3, #0]
  401d66:	607b      	str	r3, [r7, #4]

					if( uxPendedCounts > ( UBaseType_t ) 0U )
  401d68:	687b      	ldr	r3, [r7, #4]
  401d6a:	2b00      	cmp	r3, #0
  401d6c:	d010      	beq.n	401d90 <xTaskResumeAll+0xec>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
  401d6e:	4b1f      	ldr	r3, [pc, #124]	; (401dec <xTaskResumeAll+0x148>)
  401d70:	4798      	blx	r3
  401d72:	4603      	mov	r3, r0
  401d74:	2b00      	cmp	r3, #0
  401d76:	d002      	beq.n	401d7e <xTaskResumeAll+0xda>
							{
								xYieldPending = pdTRUE;
  401d78:	4b19      	ldr	r3, [pc, #100]	; (401de0 <xTaskResumeAll+0x13c>)
  401d7a:	2201      	movs	r2, #1
  401d7c:	601a      	str	r2, [r3, #0]
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
  401d7e:	687b      	ldr	r3, [r7, #4]
  401d80:	3b01      	subs	r3, #1
  401d82:	607b      	str	r3, [r7, #4]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
  401d84:	687b      	ldr	r3, [r7, #4]
  401d86:	2b00      	cmp	r3, #0
  401d88:	d1f1      	bne.n	401d6e <xTaskResumeAll+0xca>

						uxPendedTicks = 0;
  401d8a:	4b17      	ldr	r3, [pc, #92]	; (401de8 <xTaskResumeAll+0x144>)
  401d8c:	2200      	movs	r2, #0
  401d8e:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
  401d90:	4b13      	ldr	r3, [pc, #76]	; (401de0 <xTaskResumeAll+0x13c>)
  401d92:	681b      	ldr	r3, [r3, #0]
  401d94:	2b00      	cmp	r3, #0
  401d96:	d009      	beq.n	401dac <xTaskResumeAll+0x108>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
  401d98:	2301      	movs	r3, #1
  401d9a:	60bb      	str	r3, [r7, #8]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
  401d9c:	4b14      	ldr	r3, [pc, #80]	; (401df0 <xTaskResumeAll+0x14c>)
  401d9e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  401da2:	601a      	str	r2, [r3, #0]
  401da4:	f3bf 8f4f 	dsb	sy
  401da8:	f3bf 8f6f 	isb	sy
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
  401dac:	4b11      	ldr	r3, [pc, #68]	; (401df4 <xTaskResumeAll+0x150>)
  401dae:	4798      	blx	r3

	return xAlreadyYielded;
  401db0:	68bb      	ldr	r3, [r7, #8]
}
  401db2:	4618      	mov	r0, r3
  401db4:	3710      	adds	r7, #16
  401db6:	46bd      	mov	sp, r7
  401db8:	bd80      	pop	{r7, pc}
  401dba:	bf00      	nop
  401dbc:	2040c1fc 	.word	0x2040c1fc
  401dc0:	004004e9 	.word	0x004004e9
  401dc4:	2040c1d4 	.word	0x2040c1d4
  401dc8:	2040c194 	.word	0x2040c194
  401dcc:	004002b5 	.word	0x004002b5
  401dd0:	2040c1dc 	.word	0x2040c1dc
  401dd4:	2040c100 	.word	0x2040c100
  401dd8:	004001f9 	.word	0x004001f9
  401ddc:	2040c0fc 	.word	0x2040c0fc
  401de0:	2040c1e8 	.word	0x2040c1e8
  401de4:	004024e1 	.word	0x004024e1
  401de8:	2040c1e4 	.word	0x2040c1e4
  401dec:	00401e19 	.word	0x00401e19
  401df0:	e000ed04 	.word	0xe000ed04
  401df4:	0040054d 	.word	0x0040054d

00401df8 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
  401df8:	b480      	push	{r7}
  401dfa:	b083      	sub	sp, #12
  401dfc:	af00      	add	r7, sp, #0
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
  401dfe:	4b05      	ldr	r3, [pc, #20]	; (401e14 <xTaskGetTickCount+0x1c>)
  401e00:	681b      	ldr	r3, [r3, #0]
  401e02:	607b      	str	r3, [r7, #4]
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
  401e04:	687b      	ldr	r3, [r7, #4]
}
  401e06:	4618      	mov	r0, r3
  401e08:	370c      	adds	r7, #12
  401e0a:	46bd      	mov	sp, r7
  401e0c:	f85d 7b04 	ldr.w	r7, [sp], #4
  401e10:	4770      	bx	lr
  401e12:	bf00      	nop
  401e14:	2040c1d8 	.word	0x2040c1d8

00401e18 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
  401e18:	b580      	push	{r7, lr}
  401e1a:	b086      	sub	sp, #24
  401e1c:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
  401e1e:	2300      	movs	r3, #0
  401e20:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  401e22:	4b55      	ldr	r3, [pc, #340]	; (401f78 <xTaskIncrementTick+0x160>)
  401e24:	681b      	ldr	r3, [r3, #0]
  401e26:	2b00      	cmp	r3, #0
  401e28:	f040 8094 	bne.w	401f54 <xTaskIncrementTick+0x13c>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
  401e2c:	4b53      	ldr	r3, [pc, #332]	; (401f7c <xTaskIncrementTick+0x164>)
  401e2e:	681b      	ldr	r3, [r3, #0]
  401e30:	3301      	adds	r3, #1
  401e32:	613b      	str	r3, [r7, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
  401e34:	4a51      	ldr	r2, [pc, #324]	; (401f7c <xTaskIncrementTick+0x164>)
  401e36:	693b      	ldr	r3, [r7, #16]
  401e38:	6013      	str	r3, [r2, #0]

		if( xConstTickCount == ( TickType_t ) 0U )
  401e3a:	693b      	ldr	r3, [r7, #16]
  401e3c:	2b00      	cmp	r3, #0
  401e3e:	d121      	bne.n	401e84 <xTaskIncrementTick+0x6c>
		{
			taskSWITCH_DELAYED_LISTS();
  401e40:	4b4f      	ldr	r3, [pc, #316]	; (401f80 <xTaskIncrementTick+0x168>)
  401e42:	681b      	ldr	r3, [r3, #0]
  401e44:	681b      	ldr	r3, [r3, #0]
  401e46:	2b00      	cmp	r3, #0
  401e48:	d00b      	beq.n	401e62 <xTaskIncrementTick+0x4a>
  401e4a:	f04f 0380 	mov.w	r3, #128	; 0x80
  401e4e:	b672      	cpsid	i
  401e50:	f383 8811 	msr	BASEPRI, r3
  401e54:	f3bf 8f6f 	isb	sy
  401e58:	f3bf 8f4f 	dsb	sy
  401e5c:	b662      	cpsie	i
  401e5e:	603b      	str	r3, [r7, #0]
  401e60:	e7fe      	b.n	401e60 <xTaskIncrementTick+0x48>
  401e62:	4b47      	ldr	r3, [pc, #284]	; (401f80 <xTaskIncrementTick+0x168>)
  401e64:	681b      	ldr	r3, [r3, #0]
  401e66:	60fb      	str	r3, [r7, #12]
  401e68:	4b46      	ldr	r3, [pc, #280]	; (401f84 <xTaskIncrementTick+0x16c>)
  401e6a:	681b      	ldr	r3, [r3, #0]
  401e6c:	4a44      	ldr	r2, [pc, #272]	; (401f80 <xTaskIncrementTick+0x168>)
  401e6e:	6013      	str	r3, [r2, #0]
  401e70:	4a44      	ldr	r2, [pc, #272]	; (401f84 <xTaskIncrementTick+0x16c>)
  401e72:	68fb      	ldr	r3, [r7, #12]
  401e74:	6013      	str	r3, [r2, #0]
  401e76:	4b44      	ldr	r3, [pc, #272]	; (401f88 <xTaskIncrementTick+0x170>)
  401e78:	681b      	ldr	r3, [r3, #0]
  401e7a:	3301      	adds	r3, #1
  401e7c:	4a42      	ldr	r2, [pc, #264]	; (401f88 <xTaskIncrementTick+0x170>)
  401e7e:	6013      	str	r3, [r2, #0]
  401e80:	4b42      	ldr	r3, [pc, #264]	; (401f8c <xTaskIncrementTick+0x174>)
  401e82:	4798      	blx	r3

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
  401e84:	4b42      	ldr	r3, [pc, #264]	; (401f90 <xTaskIncrementTick+0x178>)
  401e86:	681b      	ldr	r3, [r3, #0]
  401e88:	693a      	ldr	r2, [r7, #16]
  401e8a:	429a      	cmp	r2, r3
  401e8c:	d34d      	bcc.n	401f2a <xTaskIncrementTick+0x112>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  401e8e:	4b3c      	ldr	r3, [pc, #240]	; (401f80 <xTaskIncrementTick+0x168>)
  401e90:	681b      	ldr	r3, [r3, #0]
  401e92:	681b      	ldr	r3, [r3, #0]
  401e94:	2b00      	cmp	r3, #0
  401e96:	d101      	bne.n	401e9c <xTaskIncrementTick+0x84>
  401e98:	2301      	movs	r3, #1
  401e9a:	e000      	b.n	401e9e <xTaskIncrementTick+0x86>
  401e9c:	2300      	movs	r3, #0
  401e9e:	2b00      	cmp	r3, #0
  401ea0:	d004      	beq.n	401eac <xTaskIncrementTick+0x94>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  401ea2:	4b3b      	ldr	r3, [pc, #236]	; (401f90 <xTaskIncrementTick+0x178>)
  401ea4:	f04f 32ff 	mov.w	r2, #4294967295
  401ea8:	601a      	str	r2, [r3, #0]
					break;
  401eaa:	e03e      	b.n	401f2a <xTaskIncrementTick+0x112>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  401eac:	4b34      	ldr	r3, [pc, #208]	; (401f80 <xTaskIncrementTick+0x168>)
  401eae:	681b      	ldr	r3, [r3, #0]
  401eb0:	68db      	ldr	r3, [r3, #12]
  401eb2:	68db      	ldr	r3, [r3, #12]
  401eb4:	60bb      	str	r3, [r7, #8]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
  401eb6:	68bb      	ldr	r3, [r7, #8]
  401eb8:	685b      	ldr	r3, [r3, #4]
  401eba:	607b      	str	r3, [r7, #4]

					if( xConstTickCount < xItemValue )
  401ebc:	693a      	ldr	r2, [r7, #16]
  401ebe:	687b      	ldr	r3, [r7, #4]
  401ec0:	429a      	cmp	r2, r3
  401ec2:	d203      	bcs.n	401ecc <xTaskIncrementTick+0xb4>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
  401ec4:	4a32      	ldr	r2, [pc, #200]	; (401f90 <xTaskIncrementTick+0x178>)
  401ec6:	687b      	ldr	r3, [r7, #4]
  401ec8:	6013      	str	r3, [r2, #0]
						break;
  401eca:	e02e      	b.n	401f2a <xTaskIncrementTick+0x112>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  401ecc:	68bb      	ldr	r3, [r7, #8]
  401ece:	3304      	adds	r3, #4
  401ed0:	4618      	mov	r0, r3
  401ed2:	4b30      	ldr	r3, [pc, #192]	; (401f94 <xTaskIncrementTick+0x17c>)
  401ed4:	4798      	blx	r3

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  401ed6:	68bb      	ldr	r3, [r7, #8]
  401ed8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  401eda:	2b00      	cmp	r3, #0
  401edc:	d004      	beq.n	401ee8 <xTaskIncrementTick+0xd0>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  401ede:	68bb      	ldr	r3, [r7, #8]
  401ee0:	3318      	adds	r3, #24
  401ee2:	4618      	mov	r0, r3
  401ee4:	4b2b      	ldr	r3, [pc, #172]	; (401f94 <xTaskIncrementTick+0x17c>)
  401ee6:	4798      	blx	r3
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
  401ee8:	68bb      	ldr	r3, [r7, #8]
  401eea:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  401eec:	2201      	movs	r2, #1
  401eee:	409a      	lsls	r2, r3
  401ef0:	4b29      	ldr	r3, [pc, #164]	; (401f98 <xTaskIncrementTick+0x180>)
  401ef2:	681b      	ldr	r3, [r3, #0]
  401ef4:	4313      	orrs	r3, r2
  401ef6:	4a28      	ldr	r2, [pc, #160]	; (401f98 <xTaskIncrementTick+0x180>)
  401ef8:	6013      	str	r3, [r2, #0]
  401efa:	68bb      	ldr	r3, [r7, #8]
  401efc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  401efe:	4613      	mov	r3, r2
  401f00:	009b      	lsls	r3, r3, #2
  401f02:	4413      	add	r3, r2
  401f04:	009b      	lsls	r3, r3, #2
  401f06:	4a25      	ldr	r2, [pc, #148]	; (401f9c <xTaskIncrementTick+0x184>)
  401f08:	441a      	add	r2, r3
  401f0a:	68bb      	ldr	r3, [r7, #8]
  401f0c:	3304      	adds	r3, #4
  401f0e:	4619      	mov	r1, r3
  401f10:	4610      	mov	r0, r2
  401f12:	4b23      	ldr	r3, [pc, #140]	; (401fa0 <xTaskIncrementTick+0x188>)
  401f14:	4798      	blx	r3
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  401f16:	68bb      	ldr	r3, [r7, #8]
  401f18:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  401f1a:	4b22      	ldr	r3, [pc, #136]	; (401fa4 <xTaskIncrementTick+0x18c>)
  401f1c:	681b      	ldr	r3, [r3, #0]
  401f1e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  401f20:	429a      	cmp	r2, r3
  401f22:	d3b4      	bcc.n	401e8e <xTaskIncrementTick+0x76>
						{
							xSwitchRequired = pdTRUE;
  401f24:	2301      	movs	r3, #1
  401f26:	617b      	str	r3, [r7, #20]
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
  401f28:	e7b1      	b.n	401e8e <xTaskIncrementTick+0x76>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
  401f2a:	4b1e      	ldr	r3, [pc, #120]	; (401fa4 <xTaskIncrementTick+0x18c>)
  401f2c:	681b      	ldr	r3, [r3, #0]
  401f2e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  401f30:	491a      	ldr	r1, [pc, #104]	; (401f9c <xTaskIncrementTick+0x184>)
  401f32:	4613      	mov	r3, r2
  401f34:	009b      	lsls	r3, r3, #2
  401f36:	4413      	add	r3, r2
  401f38:	009b      	lsls	r3, r3, #2
  401f3a:	440b      	add	r3, r1
  401f3c:	681b      	ldr	r3, [r3, #0]
  401f3e:	2b01      	cmp	r3, #1
  401f40:	d901      	bls.n	401f46 <xTaskIncrementTick+0x12e>
			{
				xSwitchRequired = pdTRUE;
  401f42:	2301      	movs	r3, #1
  401f44:	617b      	str	r3, [r7, #20]

		#if ( configUSE_TICK_HOOK == 1 )
		{
			/* Guard against the tick hook being called when the pended tick
			count is being unwound (when the scheduler is being unlocked). */
			if( uxPendedTicks == ( UBaseType_t ) 0U )
  401f46:	4b18      	ldr	r3, [pc, #96]	; (401fa8 <xTaskIncrementTick+0x190>)
  401f48:	681b      	ldr	r3, [r3, #0]
  401f4a:	2b00      	cmp	r3, #0
  401f4c:	d109      	bne.n	401f62 <xTaskIncrementTick+0x14a>
			{
				vApplicationTickHook();
  401f4e:	4b17      	ldr	r3, [pc, #92]	; (401fac <xTaskIncrementTick+0x194>)
  401f50:	4798      	blx	r3
  401f52:	e006      	b.n	401f62 <xTaskIncrementTick+0x14a>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
  401f54:	4b14      	ldr	r3, [pc, #80]	; (401fa8 <xTaskIncrementTick+0x190>)
  401f56:	681b      	ldr	r3, [r3, #0]
  401f58:	3301      	adds	r3, #1
  401f5a:	4a13      	ldr	r2, [pc, #76]	; (401fa8 <xTaskIncrementTick+0x190>)
  401f5c:	6013      	str	r3, [r2, #0]

		/* The tick hook gets called at regular intervals, even if the
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			vApplicationTickHook();
  401f5e:	4b13      	ldr	r3, [pc, #76]	; (401fac <xTaskIncrementTick+0x194>)
  401f60:	4798      	blx	r3
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
  401f62:	4b13      	ldr	r3, [pc, #76]	; (401fb0 <xTaskIncrementTick+0x198>)
  401f64:	681b      	ldr	r3, [r3, #0]
  401f66:	2b00      	cmp	r3, #0
  401f68:	d001      	beq.n	401f6e <xTaskIncrementTick+0x156>
		{
			xSwitchRequired = pdTRUE;
  401f6a:	2301      	movs	r3, #1
  401f6c:	617b      	str	r3, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
  401f6e:	697b      	ldr	r3, [r7, #20]
}
  401f70:	4618      	mov	r0, r3
  401f72:	3718      	adds	r7, #24
  401f74:	46bd      	mov	sp, r7
  401f76:	bd80      	pop	{r7, pc}
  401f78:	2040c1fc 	.word	0x2040c1fc
  401f7c:	2040c1d8 	.word	0x2040c1d8
  401f80:	2040c18c 	.word	0x2040c18c
  401f84:	2040c190 	.word	0x2040c190
  401f88:	2040c1ec 	.word	0x2040c1ec
  401f8c:	004024e1 	.word	0x004024e1
  401f90:	2040c1f4 	.word	0x2040c1f4
  401f94:	004002b5 	.word	0x004002b5
  401f98:	2040c1dc 	.word	0x2040c1dc
  401f9c:	2040c100 	.word	0x2040c100
  401fa0:	004001f9 	.word	0x004001f9
  401fa4:	2040c0fc 	.word	0x2040c0fc
  401fa8:	2040c1e4 	.word	0x2040c1e4
  401fac:	004043a5 	.word	0x004043a5
  401fb0:	2040c1e8 	.word	0x2040c1e8

00401fb4 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
  401fb4:	b580      	push	{r7, lr}
  401fb6:	b088      	sub	sp, #32
  401fb8:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
  401fba:	4b3a      	ldr	r3, [pc, #232]	; (4020a4 <vTaskSwitchContext+0xf0>)
  401fbc:	681b      	ldr	r3, [r3, #0]
  401fbe:	2b00      	cmp	r3, #0
  401fc0:	d003      	beq.n	401fca <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
  401fc2:	4b39      	ldr	r3, [pc, #228]	; (4020a8 <vTaskSwitchContext+0xf4>)
  401fc4:	2201      	movs	r2, #1
  401fc6:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
  401fc8:	e067      	b.n	40209a <vTaskSwitchContext+0xe6>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
  401fca:	4b37      	ldr	r3, [pc, #220]	; (4020a8 <vTaskSwitchContext+0xf4>)
  401fcc:	2200      	movs	r2, #0
  401fce:	601a      	str	r2, [r3, #0]
				ulTaskSwitchedInTime = ulTotalRunTime;
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();
  401fd0:	4b36      	ldr	r3, [pc, #216]	; (4020ac <vTaskSwitchContext+0xf8>)
  401fd2:	681b      	ldr	r3, [r3, #0]
  401fd4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  401fd6:	61fb      	str	r3, [r7, #28]
  401fd8:	f04f 33a5 	mov.w	r3, #2779096485	; 0xa5a5a5a5
  401fdc:	61bb      	str	r3, [r7, #24]
  401fde:	69fb      	ldr	r3, [r7, #28]
  401fe0:	681a      	ldr	r2, [r3, #0]
  401fe2:	69bb      	ldr	r3, [r7, #24]
  401fe4:	429a      	cmp	r2, r3
  401fe6:	d111      	bne.n	40200c <vTaskSwitchContext+0x58>
  401fe8:	69fb      	ldr	r3, [r7, #28]
  401fea:	3304      	adds	r3, #4
  401fec:	681a      	ldr	r2, [r3, #0]
  401fee:	69bb      	ldr	r3, [r7, #24]
  401ff0:	429a      	cmp	r2, r3
  401ff2:	d10b      	bne.n	40200c <vTaskSwitchContext+0x58>
  401ff4:	69fb      	ldr	r3, [r7, #28]
  401ff6:	3308      	adds	r3, #8
  401ff8:	681a      	ldr	r2, [r3, #0]
  401ffa:	69bb      	ldr	r3, [r7, #24]
  401ffc:	429a      	cmp	r2, r3
  401ffe:	d105      	bne.n	40200c <vTaskSwitchContext+0x58>
  402000:	69fb      	ldr	r3, [r7, #28]
  402002:	330c      	adds	r3, #12
  402004:	681a      	ldr	r2, [r3, #0]
  402006:	69bb      	ldr	r3, [r7, #24]
  402008:	429a      	cmp	r2, r3
  40200a:	d008      	beq.n	40201e <vTaskSwitchContext+0x6a>
  40200c:	4b27      	ldr	r3, [pc, #156]	; (4020ac <vTaskSwitchContext+0xf8>)
  40200e:	681a      	ldr	r2, [r3, #0]
  402010:	4b26      	ldr	r3, [pc, #152]	; (4020ac <vTaskSwitchContext+0xf8>)
  402012:	681b      	ldr	r3, [r3, #0]
  402014:	3334      	adds	r3, #52	; 0x34
  402016:	4619      	mov	r1, r3
  402018:	4610      	mov	r0, r2
  40201a:	4b25      	ldr	r3, [pc, #148]	; (4020b0 <vTaskSwitchContext+0xfc>)
  40201c:	4798      	blx	r3

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
  40201e:	4b25      	ldr	r3, [pc, #148]	; (4020b4 <vTaskSwitchContext+0x100>)
  402020:	681b      	ldr	r3, [r3, #0]
  402022:	60bb      	str	r3, [r7, #8]
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
	{
	uint8_t ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
  402024:	68bb      	ldr	r3, [r7, #8]
  402026:	fab3 f383 	clz	r3, r3
  40202a:	71fb      	strb	r3, [r7, #7]
		return ucReturn;
  40202c:	79fb      	ldrb	r3, [r7, #7]
  40202e:	f1c3 031f 	rsb	r3, r3, #31
  402032:	613b      	str	r3, [r7, #16]
  402034:	4920      	ldr	r1, [pc, #128]	; (4020b8 <vTaskSwitchContext+0x104>)
  402036:	693a      	ldr	r2, [r7, #16]
  402038:	4613      	mov	r3, r2
  40203a:	009b      	lsls	r3, r3, #2
  40203c:	4413      	add	r3, r2
  40203e:	009b      	lsls	r3, r3, #2
  402040:	440b      	add	r3, r1
  402042:	681b      	ldr	r3, [r3, #0]
  402044:	2b00      	cmp	r3, #0
  402046:	d10b      	bne.n	402060 <vTaskSwitchContext+0xac>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
  402048:	f04f 0380 	mov.w	r3, #128	; 0x80
  40204c:	b672      	cpsid	i
  40204e:	f383 8811 	msr	BASEPRI, r3
  402052:	f3bf 8f6f 	isb	sy
  402056:	f3bf 8f4f 	dsb	sy
  40205a:	b662      	cpsie	i
  40205c:	617b      	str	r3, [r7, #20]
  40205e:	e7fe      	b.n	40205e <vTaskSwitchContext+0xaa>
  402060:	693a      	ldr	r2, [r7, #16]
  402062:	4613      	mov	r3, r2
  402064:	009b      	lsls	r3, r3, #2
  402066:	4413      	add	r3, r2
  402068:	009b      	lsls	r3, r3, #2
  40206a:	4a13      	ldr	r2, [pc, #76]	; (4020b8 <vTaskSwitchContext+0x104>)
  40206c:	4413      	add	r3, r2
  40206e:	60fb      	str	r3, [r7, #12]
  402070:	68fb      	ldr	r3, [r7, #12]
  402072:	685b      	ldr	r3, [r3, #4]
  402074:	685a      	ldr	r2, [r3, #4]
  402076:	68fb      	ldr	r3, [r7, #12]
  402078:	605a      	str	r2, [r3, #4]
  40207a:	68fb      	ldr	r3, [r7, #12]
  40207c:	685a      	ldr	r2, [r3, #4]
  40207e:	68fb      	ldr	r3, [r7, #12]
  402080:	3308      	adds	r3, #8
  402082:	429a      	cmp	r2, r3
  402084:	d104      	bne.n	402090 <vTaskSwitchContext+0xdc>
  402086:	68fb      	ldr	r3, [r7, #12]
  402088:	685b      	ldr	r3, [r3, #4]
  40208a:	685a      	ldr	r2, [r3, #4]
  40208c:	68fb      	ldr	r3, [r7, #12]
  40208e:	605a      	str	r2, [r3, #4]
  402090:	68fb      	ldr	r3, [r7, #12]
  402092:	685b      	ldr	r3, [r3, #4]
  402094:	68db      	ldr	r3, [r3, #12]
  402096:	4a05      	ldr	r2, [pc, #20]	; (4020ac <vTaskSwitchContext+0xf8>)
  402098:	6013      	str	r3, [r2, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
  40209a:	bf00      	nop
  40209c:	3720      	adds	r7, #32
  40209e:	46bd      	mov	sp, r7
  4020a0:	bd80      	pop	{r7, pc}
  4020a2:	bf00      	nop
  4020a4:	2040c1fc 	.word	0x2040c1fc
  4020a8:	2040c1e8 	.word	0x2040c1e8
  4020ac:	2040c0fc 	.word	0x2040c0fc
  4020b0:	00404381 	.word	0x00404381
  4020b4:	2040c1dc 	.word	0x2040c1dc
  4020b8:	2040c100 	.word	0x2040c100

004020bc <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
  4020bc:	b580      	push	{r7, lr}
  4020be:	b084      	sub	sp, #16
  4020c0:	af00      	add	r7, sp, #0
  4020c2:	6078      	str	r0, [r7, #4]
  4020c4:	6039      	str	r1, [r7, #0]
	configASSERT( pxEventList );
  4020c6:	687b      	ldr	r3, [r7, #4]
  4020c8:	2b00      	cmp	r3, #0
  4020ca:	d10b      	bne.n	4020e4 <vTaskPlaceOnEventList+0x28>
  4020cc:	f04f 0380 	mov.w	r3, #128	; 0x80
  4020d0:	b672      	cpsid	i
  4020d2:	f383 8811 	msr	BASEPRI, r3
  4020d6:	f3bf 8f6f 	isb	sy
  4020da:	f3bf 8f4f 	dsb	sy
  4020de:	b662      	cpsie	i
  4020e0:	60fb      	str	r3, [r7, #12]
  4020e2:	e7fe      	b.n	4020e2 <vTaskPlaceOnEventList+0x26>

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  4020e4:	4b07      	ldr	r3, [pc, #28]	; (402104 <vTaskPlaceOnEventList+0x48>)
  4020e6:	681b      	ldr	r3, [r3, #0]
  4020e8:	3318      	adds	r3, #24
  4020ea:	4619      	mov	r1, r3
  4020ec:	6878      	ldr	r0, [r7, #4]
  4020ee:	4b06      	ldr	r3, [pc, #24]	; (402108 <vTaskPlaceOnEventList+0x4c>)
  4020f0:	4798      	blx	r3

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
  4020f2:	2101      	movs	r1, #1
  4020f4:	6838      	ldr	r0, [r7, #0]
  4020f6:	4b05      	ldr	r3, [pc, #20]	; (40210c <vTaskPlaceOnEventList+0x50>)
  4020f8:	4798      	blx	r3
}
  4020fa:	bf00      	nop
  4020fc:	3710      	adds	r7, #16
  4020fe:	46bd      	mov	sp, r7
  402100:	bd80      	pop	{r7, pc}
  402102:	bf00      	nop
  402104:	2040c0fc 	.word	0x2040c0fc
  402108:	00400241 	.word	0x00400241
  40210c:	0040279d 	.word	0x0040279d

00402110 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if( configUSE_TIMERS == 1 )

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
  402110:	b580      	push	{r7, lr}
  402112:	b086      	sub	sp, #24
  402114:	af00      	add	r7, sp, #0
  402116:	60f8      	str	r0, [r7, #12]
  402118:	60b9      	str	r1, [r7, #8]
  40211a:	607a      	str	r2, [r7, #4]
		configASSERT( pxEventList );
  40211c:	68fb      	ldr	r3, [r7, #12]
  40211e:	2b00      	cmp	r3, #0
  402120:	d10b      	bne.n	40213a <vTaskPlaceOnEventListRestricted+0x2a>
  402122:	f04f 0380 	mov.w	r3, #128	; 0x80
  402126:	b672      	cpsid	i
  402128:	f383 8811 	msr	BASEPRI, r3
  40212c:	f3bf 8f6f 	isb	sy
  402130:	f3bf 8f4f 	dsb	sy
  402134:	b662      	cpsie	i
  402136:	617b      	str	r3, [r7, #20]
  402138:	e7fe      	b.n	402138 <vTaskPlaceOnEventListRestricted+0x28>

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  40213a:	4b0a      	ldr	r3, [pc, #40]	; (402164 <vTaskPlaceOnEventListRestricted+0x54>)
  40213c:	681b      	ldr	r3, [r3, #0]
  40213e:	3318      	adds	r3, #24
  402140:	4619      	mov	r1, r3
  402142:	68f8      	ldr	r0, [r7, #12]
  402144:	4b08      	ldr	r3, [pc, #32]	; (402168 <vTaskPlaceOnEventListRestricted+0x58>)
  402146:	4798      	blx	r3

		/* If the task should block indefinitely then set the block time to a
		value that will be recognised as an indefinite delay inside the
		prvAddCurrentTaskToDelayedList() function. */
		if( xWaitIndefinitely != pdFALSE )
  402148:	687b      	ldr	r3, [r7, #4]
  40214a:	2b00      	cmp	r3, #0
  40214c:	d002      	beq.n	402154 <vTaskPlaceOnEventListRestricted+0x44>
		{
			xTicksToWait = portMAX_DELAY;
  40214e:	f04f 33ff 	mov.w	r3, #4294967295
  402152:	60bb      	str	r3, [r7, #8]
		}

		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
  402154:	6879      	ldr	r1, [r7, #4]
  402156:	68b8      	ldr	r0, [r7, #8]
  402158:	4b04      	ldr	r3, [pc, #16]	; (40216c <vTaskPlaceOnEventListRestricted+0x5c>)
  40215a:	4798      	blx	r3
	}
  40215c:	bf00      	nop
  40215e:	3718      	adds	r7, #24
  402160:	46bd      	mov	sp, r7
  402162:	bd80      	pop	{r7, pc}
  402164:	2040c0fc 	.word	0x2040c0fc
  402168:	004001f9 	.word	0x004001f9
  40216c:	0040279d 	.word	0x0040279d

00402170 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
  402170:	b580      	push	{r7, lr}
  402172:	b086      	sub	sp, #24
  402174:	af00      	add	r7, sp, #0
  402176:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
  402178:	687b      	ldr	r3, [r7, #4]
  40217a:	68db      	ldr	r3, [r3, #12]
  40217c:	68db      	ldr	r3, [r3, #12]
  40217e:	613b      	str	r3, [r7, #16]
	configASSERT( pxUnblockedTCB );
  402180:	693b      	ldr	r3, [r7, #16]
  402182:	2b00      	cmp	r3, #0
  402184:	d10b      	bne.n	40219e <xTaskRemoveFromEventList+0x2e>
  402186:	f04f 0380 	mov.w	r3, #128	; 0x80
  40218a:	b672      	cpsid	i
  40218c:	f383 8811 	msr	BASEPRI, r3
  402190:	f3bf 8f6f 	isb	sy
  402194:	f3bf 8f4f 	dsb	sy
  402198:	b662      	cpsie	i
  40219a:	60fb      	str	r3, [r7, #12]
  40219c:	e7fe      	b.n	40219c <xTaskRemoveFromEventList+0x2c>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
  40219e:	693b      	ldr	r3, [r7, #16]
  4021a0:	3318      	adds	r3, #24
  4021a2:	4618      	mov	r0, r3
  4021a4:	4b1e      	ldr	r3, [pc, #120]	; (402220 <xTaskRemoveFromEventList+0xb0>)
  4021a6:	4798      	blx	r3

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  4021a8:	4b1e      	ldr	r3, [pc, #120]	; (402224 <xTaskRemoveFromEventList+0xb4>)
  4021aa:	681b      	ldr	r3, [r3, #0]
  4021ac:	2b00      	cmp	r3, #0
  4021ae:	d11c      	bne.n	4021ea <xTaskRemoveFromEventList+0x7a>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
  4021b0:	693b      	ldr	r3, [r7, #16]
  4021b2:	3304      	adds	r3, #4
  4021b4:	4618      	mov	r0, r3
  4021b6:	4b1a      	ldr	r3, [pc, #104]	; (402220 <xTaskRemoveFromEventList+0xb0>)
  4021b8:	4798      	blx	r3
		prvAddTaskToReadyList( pxUnblockedTCB );
  4021ba:	693b      	ldr	r3, [r7, #16]
  4021bc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4021be:	2201      	movs	r2, #1
  4021c0:	409a      	lsls	r2, r3
  4021c2:	4b19      	ldr	r3, [pc, #100]	; (402228 <xTaskRemoveFromEventList+0xb8>)
  4021c4:	681b      	ldr	r3, [r3, #0]
  4021c6:	4313      	orrs	r3, r2
  4021c8:	4a17      	ldr	r2, [pc, #92]	; (402228 <xTaskRemoveFromEventList+0xb8>)
  4021ca:	6013      	str	r3, [r2, #0]
  4021cc:	693b      	ldr	r3, [r7, #16]
  4021ce:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4021d0:	4613      	mov	r3, r2
  4021d2:	009b      	lsls	r3, r3, #2
  4021d4:	4413      	add	r3, r2
  4021d6:	009b      	lsls	r3, r3, #2
  4021d8:	4a14      	ldr	r2, [pc, #80]	; (40222c <xTaskRemoveFromEventList+0xbc>)
  4021da:	441a      	add	r2, r3
  4021dc:	693b      	ldr	r3, [r7, #16]
  4021de:	3304      	adds	r3, #4
  4021e0:	4619      	mov	r1, r3
  4021e2:	4610      	mov	r0, r2
  4021e4:	4b12      	ldr	r3, [pc, #72]	; (402230 <xTaskRemoveFromEventList+0xc0>)
  4021e6:	4798      	blx	r3
  4021e8:	e005      	b.n	4021f6 <xTaskRemoveFromEventList+0x86>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  4021ea:	693b      	ldr	r3, [r7, #16]
  4021ec:	3318      	adds	r3, #24
  4021ee:	4619      	mov	r1, r3
  4021f0:	4810      	ldr	r0, [pc, #64]	; (402234 <xTaskRemoveFromEventList+0xc4>)
  4021f2:	4b0f      	ldr	r3, [pc, #60]	; (402230 <xTaskRemoveFromEventList+0xc0>)
  4021f4:	4798      	blx	r3
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
  4021f6:	693b      	ldr	r3, [r7, #16]
  4021f8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4021fa:	4b0f      	ldr	r3, [pc, #60]	; (402238 <xTaskRemoveFromEventList+0xc8>)
  4021fc:	681b      	ldr	r3, [r3, #0]
  4021fe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402200:	429a      	cmp	r2, r3
  402202:	d905      	bls.n	402210 <xTaskRemoveFromEventList+0xa0>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
  402204:	2301      	movs	r3, #1
  402206:	617b      	str	r3, [r7, #20]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
  402208:	4b0c      	ldr	r3, [pc, #48]	; (40223c <xTaskRemoveFromEventList+0xcc>)
  40220a:	2201      	movs	r2, #1
  40220c:	601a      	str	r2, [r3, #0]
  40220e:	e001      	b.n	402214 <xTaskRemoveFromEventList+0xa4>
	}
	else
	{
		xReturn = pdFALSE;
  402210:	2300      	movs	r3, #0
  402212:	617b      	str	r3, [r7, #20]
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
  402214:	697b      	ldr	r3, [r7, #20]
}
  402216:	4618      	mov	r0, r3
  402218:	3718      	adds	r7, #24
  40221a:	46bd      	mov	sp, r7
  40221c:	bd80      	pop	{r7, pc}
  40221e:	bf00      	nop
  402220:	004002b5 	.word	0x004002b5
  402224:	2040c1fc 	.word	0x2040c1fc
  402228:	2040c1dc 	.word	0x2040c1dc
  40222c:	2040c100 	.word	0x2040c100
  402230:	004001f9 	.word	0x004001f9
  402234:	2040c194 	.word	0x2040c194
  402238:	2040c0fc 	.word	0x2040c0fc
  40223c:	2040c1e8 	.word	0x2040c1e8

00402240 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
  402240:	b480      	push	{r7}
  402242:	b085      	sub	sp, #20
  402244:	af00      	add	r7, sp, #0
  402246:	6078      	str	r0, [r7, #4]
	configASSERT( pxTimeOut );
  402248:	687b      	ldr	r3, [r7, #4]
  40224a:	2b00      	cmp	r3, #0
  40224c:	d10b      	bne.n	402266 <vTaskSetTimeOutState+0x26>
  40224e:	f04f 0380 	mov.w	r3, #128	; 0x80
  402252:	b672      	cpsid	i
  402254:	f383 8811 	msr	BASEPRI, r3
  402258:	f3bf 8f6f 	isb	sy
  40225c:	f3bf 8f4f 	dsb	sy
  402260:	b662      	cpsie	i
  402262:	60fb      	str	r3, [r7, #12]
  402264:	e7fe      	b.n	402264 <vTaskSetTimeOutState+0x24>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  402266:	4b07      	ldr	r3, [pc, #28]	; (402284 <vTaskSetTimeOutState+0x44>)
  402268:	681a      	ldr	r2, [r3, #0]
  40226a:	687b      	ldr	r3, [r7, #4]
  40226c:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  40226e:	4b06      	ldr	r3, [pc, #24]	; (402288 <vTaskSetTimeOutState+0x48>)
  402270:	681a      	ldr	r2, [r3, #0]
  402272:	687b      	ldr	r3, [r7, #4]
  402274:	605a      	str	r2, [r3, #4]
}
  402276:	bf00      	nop
  402278:	3714      	adds	r7, #20
  40227a:	46bd      	mov	sp, r7
  40227c:	f85d 7b04 	ldr.w	r7, [sp], #4
  402280:	4770      	bx	lr
  402282:	bf00      	nop
  402284:	2040c1ec 	.word	0x2040c1ec
  402288:	2040c1d8 	.word	0x2040c1d8

0040228c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
  40228c:	b580      	push	{r7, lr}
  40228e:	b086      	sub	sp, #24
  402290:	af00      	add	r7, sp, #0
  402292:	6078      	str	r0, [r7, #4]
  402294:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
  402296:	687b      	ldr	r3, [r7, #4]
  402298:	2b00      	cmp	r3, #0
  40229a:	d10b      	bne.n	4022b4 <xTaskCheckForTimeOut+0x28>
  40229c:	f04f 0380 	mov.w	r3, #128	; 0x80
  4022a0:	b672      	cpsid	i
  4022a2:	f383 8811 	msr	BASEPRI, r3
  4022a6:	f3bf 8f6f 	isb	sy
  4022aa:	f3bf 8f4f 	dsb	sy
  4022ae:	b662      	cpsie	i
  4022b0:	60bb      	str	r3, [r7, #8]
  4022b2:	e7fe      	b.n	4022b2 <xTaskCheckForTimeOut+0x26>
	configASSERT( pxTicksToWait );
  4022b4:	683b      	ldr	r3, [r7, #0]
  4022b6:	2b00      	cmp	r3, #0
  4022b8:	d10b      	bne.n	4022d2 <xTaskCheckForTimeOut+0x46>
  4022ba:	f04f 0380 	mov.w	r3, #128	; 0x80
  4022be:	b672      	cpsid	i
  4022c0:	f383 8811 	msr	BASEPRI, r3
  4022c4:	f3bf 8f6f 	isb	sy
  4022c8:	f3bf 8f4f 	dsb	sy
  4022cc:	b662      	cpsie	i
  4022ce:	60fb      	str	r3, [r7, #12]
  4022d0:	e7fe      	b.n	4022d0 <xTaskCheckForTimeOut+0x44>

	taskENTER_CRITICAL();
  4022d2:	4b1d      	ldr	r3, [pc, #116]	; (402348 <xTaskCheckForTimeOut+0xbc>)
  4022d4:	4798      	blx	r3
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
  4022d6:	4b1d      	ldr	r3, [pc, #116]	; (40234c <xTaskCheckForTimeOut+0xc0>)
  4022d8:	681b      	ldr	r3, [r3, #0]
  4022da:	613b      	str	r3, [r7, #16]
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
  4022dc:	683b      	ldr	r3, [r7, #0]
  4022de:	681b      	ldr	r3, [r3, #0]
  4022e0:	f1b3 3fff 	cmp.w	r3, #4294967295
  4022e4:	d102      	bne.n	4022ec <xTaskCheckForTimeOut+0x60>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
  4022e6:	2300      	movs	r3, #0
  4022e8:	617b      	str	r3, [r7, #20]
  4022ea:	e026      	b.n	40233a <xTaskCheckForTimeOut+0xae>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
  4022ec:	687b      	ldr	r3, [r7, #4]
  4022ee:	681a      	ldr	r2, [r3, #0]
  4022f0:	4b17      	ldr	r3, [pc, #92]	; (402350 <xTaskCheckForTimeOut+0xc4>)
  4022f2:	681b      	ldr	r3, [r3, #0]
  4022f4:	429a      	cmp	r2, r3
  4022f6:	d007      	beq.n	402308 <xTaskCheckForTimeOut+0x7c>
  4022f8:	687b      	ldr	r3, [r7, #4]
  4022fa:	685a      	ldr	r2, [r3, #4]
  4022fc:	693b      	ldr	r3, [r7, #16]
  4022fe:	429a      	cmp	r2, r3
  402300:	d802      	bhi.n	402308 <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
  402302:	2301      	movs	r3, #1
  402304:	617b      	str	r3, [r7, #20]
  402306:	e018      	b.n	40233a <xTaskCheckForTimeOut+0xae>
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
  402308:	687b      	ldr	r3, [r7, #4]
  40230a:	685b      	ldr	r3, [r3, #4]
  40230c:	693a      	ldr	r2, [r7, #16]
  40230e:	1ad2      	subs	r2, r2, r3
  402310:	683b      	ldr	r3, [r7, #0]
  402312:	681b      	ldr	r3, [r3, #0]
  402314:	429a      	cmp	r2, r3
  402316:	d20e      	bcs.n	402336 <xTaskCheckForTimeOut+0xaa>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
  402318:	683b      	ldr	r3, [r7, #0]
  40231a:	681a      	ldr	r2, [r3, #0]
  40231c:	687b      	ldr	r3, [r7, #4]
  40231e:	6859      	ldr	r1, [r3, #4]
  402320:	693b      	ldr	r3, [r7, #16]
  402322:	1acb      	subs	r3, r1, r3
  402324:	441a      	add	r2, r3
  402326:	683b      	ldr	r3, [r7, #0]
  402328:	601a      	str	r2, [r3, #0]
			vTaskSetTimeOutState( pxTimeOut );
  40232a:	6878      	ldr	r0, [r7, #4]
  40232c:	4b09      	ldr	r3, [pc, #36]	; (402354 <xTaskCheckForTimeOut+0xc8>)
  40232e:	4798      	blx	r3
			xReturn = pdFALSE;
  402330:	2300      	movs	r3, #0
  402332:	617b      	str	r3, [r7, #20]
  402334:	e001      	b.n	40233a <xTaskCheckForTimeOut+0xae>
		}
		else
		{
			xReturn = pdTRUE;
  402336:	2301      	movs	r3, #1
  402338:	617b      	str	r3, [r7, #20]
		}
	}
	taskEXIT_CRITICAL();
  40233a:	4b07      	ldr	r3, [pc, #28]	; (402358 <xTaskCheckForTimeOut+0xcc>)
  40233c:	4798      	blx	r3

	return xReturn;
  40233e:	697b      	ldr	r3, [r7, #20]
}
  402340:	4618      	mov	r0, r3
  402342:	3718      	adds	r7, #24
  402344:	46bd      	mov	sp, r7
  402346:	bd80      	pop	{r7, pc}
  402348:	004004e9 	.word	0x004004e9
  40234c:	2040c1d8 	.word	0x2040c1d8
  402350:	2040c1ec 	.word	0x2040c1ec
  402354:	00402241 	.word	0x00402241
  402358:	0040054d 	.word	0x0040054d

0040235c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
  40235c:	b480      	push	{r7}
  40235e:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
  402360:	4b03      	ldr	r3, [pc, #12]	; (402370 <vTaskMissedYield+0x14>)
  402362:	2201      	movs	r2, #1
  402364:	601a      	str	r2, [r3, #0]
}
  402366:	bf00      	nop
  402368:	46bd      	mov	sp, r7
  40236a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40236e:	4770      	bx	lr
  402370:	2040c1e8 	.word	0x2040c1e8

00402374 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
  402374:	b580      	push	{r7, lr}
  402376:	b082      	sub	sp, #8
  402378:	af00      	add	r7, sp, #0
  40237a:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
  40237c:	4b07      	ldr	r3, [pc, #28]	; (40239c <prvIdleTask+0x28>)
  40237e:	4798      	blx	r3

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
  402380:	4b07      	ldr	r3, [pc, #28]	; (4023a0 <prvIdleTask+0x2c>)
  402382:	681b      	ldr	r3, [r3, #0]
  402384:	2b01      	cmp	r3, #1
  402386:	d9f9      	bls.n	40237c <prvIdleTask+0x8>
			{
				taskYIELD();
  402388:	4b06      	ldr	r3, [pc, #24]	; (4023a4 <prvIdleTask+0x30>)
  40238a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  40238e:	601a      	str	r2, [r3, #0]
  402390:	f3bf 8f4f 	dsb	sy
  402394:	f3bf 8f6f 	isb	sy
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
  402398:	e7f0      	b.n	40237c <prvIdleTask+0x8>
  40239a:	bf00      	nop
  40239c:	0040242d 	.word	0x0040242d
  4023a0:	2040c100 	.word	0x2040c100
  4023a4:	e000ed04 	.word	0xe000ed04

004023a8 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
  4023a8:	b580      	push	{r7, lr}
  4023aa:	b082      	sub	sp, #8
  4023ac:	af00      	add	r7, sp, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
  4023ae:	2300      	movs	r3, #0
  4023b0:	607b      	str	r3, [r7, #4]
  4023b2:	e00c      	b.n	4023ce <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
  4023b4:	687a      	ldr	r2, [r7, #4]
  4023b6:	4613      	mov	r3, r2
  4023b8:	009b      	lsls	r3, r3, #2
  4023ba:	4413      	add	r3, r2
  4023bc:	009b      	lsls	r3, r3, #2
  4023be:	4a12      	ldr	r2, [pc, #72]	; (402408 <prvInitialiseTaskLists+0x60>)
  4023c0:	4413      	add	r3, r2
  4023c2:	4618      	mov	r0, r3
  4023c4:	4b11      	ldr	r3, [pc, #68]	; (40240c <prvInitialiseTaskLists+0x64>)
  4023c6:	4798      	blx	r3

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
  4023c8:	687b      	ldr	r3, [r7, #4]
  4023ca:	3301      	adds	r3, #1
  4023cc:	607b      	str	r3, [r7, #4]
  4023ce:	687b      	ldr	r3, [r7, #4]
  4023d0:	2b04      	cmp	r3, #4
  4023d2:	d9ef      	bls.n	4023b4 <prvInitialiseTaskLists+0xc>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
  4023d4:	480e      	ldr	r0, [pc, #56]	; (402410 <prvInitialiseTaskLists+0x68>)
  4023d6:	4b0d      	ldr	r3, [pc, #52]	; (40240c <prvInitialiseTaskLists+0x64>)
  4023d8:	4798      	blx	r3
	vListInitialise( &xDelayedTaskList2 );
  4023da:	480e      	ldr	r0, [pc, #56]	; (402414 <prvInitialiseTaskLists+0x6c>)
  4023dc:	4b0b      	ldr	r3, [pc, #44]	; (40240c <prvInitialiseTaskLists+0x64>)
  4023de:	4798      	blx	r3
	vListInitialise( &xPendingReadyList );
  4023e0:	480d      	ldr	r0, [pc, #52]	; (402418 <prvInitialiseTaskLists+0x70>)
  4023e2:	4b0a      	ldr	r3, [pc, #40]	; (40240c <prvInitialiseTaskLists+0x64>)
  4023e4:	4798      	blx	r3

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
  4023e6:	480d      	ldr	r0, [pc, #52]	; (40241c <prvInitialiseTaskLists+0x74>)
  4023e8:	4b08      	ldr	r3, [pc, #32]	; (40240c <prvInitialiseTaskLists+0x64>)
  4023ea:	4798      	blx	r3
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
  4023ec:	480c      	ldr	r0, [pc, #48]	; (402420 <prvInitialiseTaskLists+0x78>)
  4023ee:	4b07      	ldr	r3, [pc, #28]	; (40240c <prvInitialiseTaskLists+0x64>)
  4023f0:	4798      	blx	r3
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
  4023f2:	4b0c      	ldr	r3, [pc, #48]	; (402424 <prvInitialiseTaskLists+0x7c>)
  4023f4:	4a06      	ldr	r2, [pc, #24]	; (402410 <prvInitialiseTaskLists+0x68>)
  4023f6:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  4023f8:	4b0b      	ldr	r3, [pc, #44]	; (402428 <prvInitialiseTaskLists+0x80>)
  4023fa:	4a06      	ldr	r2, [pc, #24]	; (402414 <prvInitialiseTaskLists+0x6c>)
  4023fc:	601a      	str	r2, [r3, #0]
}
  4023fe:	bf00      	nop
  402400:	3708      	adds	r7, #8
  402402:	46bd      	mov	sp, r7
  402404:	bd80      	pop	{r7, pc}
  402406:	bf00      	nop
  402408:	2040c100 	.word	0x2040c100
  40240c:	0040019d 	.word	0x0040019d
  402410:	2040c164 	.word	0x2040c164
  402414:	2040c178 	.word	0x2040c178
  402418:	2040c194 	.word	0x2040c194
  40241c:	2040c1a8 	.word	0x2040c1a8
  402420:	2040c1c0 	.word	0x2040c1c0
  402424:	2040c18c 	.word	0x2040c18c
  402428:	2040c190 	.word	0x2040c190

0040242c <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
  40242c:	b580      	push	{r7, lr}
  40242e:	b082      	sub	sp, #8
  402430:	af00      	add	r7, sp, #0
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
  402432:	e028      	b.n	402486 <prvCheckTasksWaitingTermination+0x5a>
		{
			vTaskSuspendAll();
  402434:	4b18      	ldr	r3, [pc, #96]	; (402498 <prvCheckTasksWaitingTermination+0x6c>)
  402436:	4798      	blx	r3
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
  402438:	4b18      	ldr	r3, [pc, #96]	; (40249c <prvCheckTasksWaitingTermination+0x70>)
  40243a:	681b      	ldr	r3, [r3, #0]
  40243c:	2b00      	cmp	r3, #0
  40243e:	bf0c      	ite	eq
  402440:	2301      	moveq	r3, #1
  402442:	2300      	movne	r3, #0
  402444:	b2db      	uxtb	r3, r3
  402446:	607b      	str	r3, [r7, #4]
			}
			( void ) xTaskResumeAll();
  402448:	4b15      	ldr	r3, [pc, #84]	; (4024a0 <prvCheckTasksWaitingTermination+0x74>)
  40244a:	4798      	blx	r3

			if( xListIsEmpty == pdFALSE )
  40244c:	687b      	ldr	r3, [r7, #4]
  40244e:	2b00      	cmp	r3, #0
  402450:	d119      	bne.n	402486 <prvCheckTasksWaitingTermination+0x5a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
  402452:	4b14      	ldr	r3, [pc, #80]	; (4024a4 <prvCheckTasksWaitingTermination+0x78>)
  402454:	4798      	blx	r3
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
  402456:	4b11      	ldr	r3, [pc, #68]	; (40249c <prvCheckTasksWaitingTermination+0x70>)
  402458:	68db      	ldr	r3, [r3, #12]
  40245a:	68db      	ldr	r3, [r3, #12]
  40245c:	603b      	str	r3, [r7, #0]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  40245e:	683b      	ldr	r3, [r7, #0]
  402460:	3304      	adds	r3, #4
  402462:	4618      	mov	r0, r3
  402464:	4b10      	ldr	r3, [pc, #64]	; (4024a8 <prvCheckTasksWaitingTermination+0x7c>)
  402466:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
  402468:	4b10      	ldr	r3, [pc, #64]	; (4024ac <prvCheckTasksWaitingTermination+0x80>)
  40246a:	681b      	ldr	r3, [r3, #0]
  40246c:	3b01      	subs	r3, #1
  40246e:	4a0f      	ldr	r2, [pc, #60]	; (4024ac <prvCheckTasksWaitingTermination+0x80>)
  402470:	6013      	str	r3, [r2, #0]
					--uxDeletedTasksWaitingCleanUp;
  402472:	4b0f      	ldr	r3, [pc, #60]	; (4024b0 <prvCheckTasksWaitingTermination+0x84>)
  402474:	681b      	ldr	r3, [r3, #0]
  402476:	3b01      	subs	r3, #1
  402478:	4a0d      	ldr	r2, [pc, #52]	; (4024b0 <prvCheckTasksWaitingTermination+0x84>)
  40247a:	6013      	str	r3, [r2, #0]
				}
				taskEXIT_CRITICAL();
  40247c:	4b0d      	ldr	r3, [pc, #52]	; (4024b4 <prvCheckTasksWaitingTermination+0x88>)
  40247e:	4798      	blx	r3

				prvDeleteTCB( pxTCB );
  402480:	6838      	ldr	r0, [r7, #0]
  402482:	4b0d      	ldr	r3, [pc, #52]	; (4024b8 <prvCheckTasksWaitingTermination+0x8c>)
  402484:	4798      	blx	r3
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
  402486:	4b0a      	ldr	r3, [pc, #40]	; (4024b0 <prvCheckTasksWaitingTermination+0x84>)
  402488:	681b      	ldr	r3, [r3, #0]
  40248a:	2b00      	cmp	r3, #0
  40248c:	d1d2      	bne.n	402434 <prvCheckTasksWaitingTermination+0x8>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
  40248e:	bf00      	nop
  402490:	3708      	adds	r7, #8
  402492:	46bd      	mov	sp, r7
  402494:	bd80      	pop	{r7, pc}
  402496:	bf00      	nop
  402498:	00401c89 	.word	0x00401c89
  40249c:	2040c1a8 	.word	0x2040c1a8
  4024a0:	00401ca5 	.word	0x00401ca5
  4024a4:	004004e9 	.word	0x004004e9
  4024a8:	004002b5 	.word	0x004002b5
  4024ac:	2040c1d4 	.word	0x2040c1d4
  4024b0:	2040c1bc 	.word	0x2040c1bc
  4024b4:	0040054d 	.word	0x0040054d
  4024b8:	004024bd 	.word	0x004024bd

004024bc <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
  4024bc:	b580      	push	{r7, lr}
  4024be:	b082      	sub	sp, #8
  4024c0:	af00      	add	r7, sp, #0
  4024c2:	6078      	str	r0, [r7, #4]

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
  4024c4:	687b      	ldr	r3, [r7, #4]
  4024c6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4024c8:	4618      	mov	r0, r3
  4024ca:	4b04      	ldr	r3, [pc, #16]	; (4024dc <prvDeleteTCB+0x20>)
  4024cc:	4798      	blx	r3
			vPortFree( pxTCB );
  4024ce:	6878      	ldr	r0, [r7, #4]
  4024d0:	4b02      	ldr	r3, [pc, #8]	; (4024dc <prvDeleteTCB+0x20>)
  4024d2:	4798      	blx	r3
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
  4024d4:	bf00      	nop
  4024d6:	3708      	adds	r7, #8
  4024d8:	46bd      	mov	sp, r7
  4024da:	bd80      	pop	{r7, pc}
  4024dc:	004008bd 	.word	0x004008bd

004024e0 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
  4024e0:	b480      	push	{r7}
  4024e2:	b083      	sub	sp, #12
  4024e4:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  4024e6:	4b0f      	ldr	r3, [pc, #60]	; (402524 <prvResetNextTaskUnblockTime+0x44>)
  4024e8:	681b      	ldr	r3, [r3, #0]
  4024ea:	681b      	ldr	r3, [r3, #0]
  4024ec:	2b00      	cmp	r3, #0
  4024ee:	d101      	bne.n	4024f4 <prvResetNextTaskUnblockTime+0x14>
  4024f0:	2301      	movs	r3, #1
  4024f2:	e000      	b.n	4024f6 <prvResetNextTaskUnblockTime+0x16>
  4024f4:	2300      	movs	r3, #0
  4024f6:	2b00      	cmp	r3, #0
  4024f8:	d004      	beq.n	402504 <prvResetNextTaskUnblockTime+0x24>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
  4024fa:	4b0b      	ldr	r3, [pc, #44]	; (402528 <prvResetNextTaskUnblockTime+0x48>)
  4024fc:	f04f 32ff 	mov.w	r2, #4294967295
  402500:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
  402502:	e008      	b.n	402516 <prvResetNextTaskUnblockTime+0x36>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  402504:	4b07      	ldr	r3, [pc, #28]	; (402524 <prvResetNextTaskUnblockTime+0x44>)
  402506:	681b      	ldr	r3, [r3, #0]
  402508:	68db      	ldr	r3, [r3, #12]
  40250a:	68db      	ldr	r3, [r3, #12]
  40250c:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
  40250e:	687b      	ldr	r3, [r7, #4]
  402510:	685b      	ldr	r3, [r3, #4]
  402512:	4a05      	ldr	r2, [pc, #20]	; (402528 <prvResetNextTaskUnblockTime+0x48>)
  402514:	6013      	str	r3, [r2, #0]
	}
}
  402516:	bf00      	nop
  402518:	370c      	adds	r7, #12
  40251a:	46bd      	mov	sp, r7
  40251c:	f85d 7b04 	ldr.w	r7, [sp], #4
  402520:	4770      	bx	lr
  402522:	bf00      	nop
  402524:	2040c18c 	.word	0x2040c18c
  402528:	2040c1f4 	.word	0x2040c1f4

0040252c <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
  40252c:	b480      	push	{r7}
  40252e:	b083      	sub	sp, #12
  402530:	af00      	add	r7, sp, #0
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
  402532:	4b0b      	ldr	r3, [pc, #44]	; (402560 <xTaskGetSchedulerState+0x34>)
  402534:	681b      	ldr	r3, [r3, #0]
  402536:	2b00      	cmp	r3, #0
  402538:	d102      	bne.n	402540 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
  40253a:	2301      	movs	r3, #1
  40253c:	607b      	str	r3, [r7, #4]
  40253e:	e008      	b.n	402552 <xTaskGetSchedulerState+0x26>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  402540:	4b08      	ldr	r3, [pc, #32]	; (402564 <xTaskGetSchedulerState+0x38>)
  402542:	681b      	ldr	r3, [r3, #0]
  402544:	2b00      	cmp	r3, #0
  402546:	d102      	bne.n	40254e <xTaskGetSchedulerState+0x22>
			{
				xReturn = taskSCHEDULER_RUNNING;
  402548:	2302      	movs	r3, #2
  40254a:	607b      	str	r3, [r7, #4]
  40254c:	e001      	b.n	402552 <xTaskGetSchedulerState+0x26>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
  40254e:	2300      	movs	r3, #0
  402550:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
  402552:	687b      	ldr	r3, [r7, #4]
	}
  402554:	4618      	mov	r0, r3
  402556:	370c      	adds	r7, #12
  402558:	46bd      	mov	sp, r7
  40255a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40255e:	4770      	bx	lr
  402560:	2040c1e0 	.word	0x2040c1e0
  402564:	2040c1fc 	.word	0x2040c1fc

00402568 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
  402568:	b580      	push	{r7, lr}
  40256a:	b084      	sub	sp, #16
  40256c:	af00      	add	r7, sp, #0
  40256e:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
  402570:	687b      	ldr	r3, [r7, #4]
  402572:	60fb      	str	r3, [r7, #12]

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
  402574:	687b      	ldr	r3, [r7, #4]
  402576:	2b00      	cmp	r3, #0
  402578:	d062      	beq.n	402640 <vTaskPriorityInherit+0xd8>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
  40257a:	68fb      	ldr	r3, [r7, #12]
  40257c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  40257e:	4b32      	ldr	r3, [pc, #200]	; (402648 <vTaskPriorityInherit+0xe0>)
  402580:	681b      	ldr	r3, [r3, #0]
  402582:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402584:	429a      	cmp	r2, r3
  402586:	d25b      	bcs.n	402640 <vTaskPriorityInherit+0xd8>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
  402588:	68fb      	ldr	r3, [r7, #12]
  40258a:	699b      	ldr	r3, [r3, #24]
  40258c:	2b00      	cmp	r3, #0
  40258e:	db06      	blt.n	40259e <vTaskPriorityInherit+0x36>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  402590:	4b2d      	ldr	r3, [pc, #180]	; (402648 <vTaskPriorityInherit+0xe0>)
  402592:	681b      	ldr	r3, [r3, #0]
  402594:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402596:	f1c3 0205 	rsb	r2, r3, #5
  40259a:	68fb      	ldr	r3, [r7, #12]
  40259c:	619a      	str	r2, [r3, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
  40259e:	68fb      	ldr	r3, [r7, #12]
  4025a0:	6959      	ldr	r1, [r3, #20]
  4025a2:	68fb      	ldr	r3, [r7, #12]
  4025a4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4025a6:	4613      	mov	r3, r2
  4025a8:	009b      	lsls	r3, r3, #2
  4025aa:	4413      	add	r3, r2
  4025ac:	009b      	lsls	r3, r3, #2
  4025ae:	4a27      	ldr	r2, [pc, #156]	; (40264c <vTaskPriorityInherit+0xe4>)
  4025b0:	4413      	add	r3, r2
  4025b2:	4299      	cmp	r1, r3
  4025b4:	d101      	bne.n	4025ba <vTaskPriorityInherit+0x52>
  4025b6:	2301      	movs	r3, #1
  4025b8:	e000      	b.n	4025bc <vTaskPriorityInherit+0x54>
  4025ba:	2300      	movs	r3, #0
  4025bc:	2b00      	cmp	r3, #0
  4025be:	d03a      	beq.n	402636 <vTaskPriorityInherit+0xce>
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  4025c0:	68fb      	ldr	r3, [r7, #12]
  4025c2:	3304      	adds	r3, #4
  4025c4:	4618      	mov	r0, r3
  4025c6:	4b22      	ldr	r3, [pc, #136]	; (402650 <vTaskPriorityInherit+0xe8>)
  4025c8:	4798      	blx	r3
  4025ca:	4603      	mov	r3, r0
  4025cc:	2b00      	cmp	r3, #0
  4025ce:	d115      	bne.n	4025fc <vTaskPriorityInherit+0x94>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  4025d0:	68fb      	ldr	r3, [r7, #12]
  4025d2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4025d4:	491d      	ldr	r1, [pc, #116]	; (40264c <vTaskPriorityInherit+0xe4>)
  4025d6:	4613      	mov	r3, r2
  4025d8:	009b      	lsls	r3, r3, #2
  4025da:	4413      	add	r3, r2
  4025dc:	009b      	lsls	r3, r3, #2
  4025de:	440b      	add	r3, r1
  4025e0:	681b      	ldr	r3, [r3, #0]
  4025e2:	2b00      	cmp	r3, #0
  4025e4:	d10a      	bne.n	4025fc <vTaskPriorityInherit+0x94>
  4025e6:	68fb      	ldr	r3, [r7, #12]
  4025e8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4025ea:	2201      	movs	r2, #1
  4025ec:	fa02 f303 	lsl.w	r3, r2, r3
  4025f0:	43da      	mvns	r2, r3
  4025f2:	4b18      	ldr	r3, [pc, #96]	; (402654 <vTaskPriorityInherit+0xec>)
  4025f4:	681b      	ldr	r3, [r3, #0]
  4025f6:	4013      	ands	r3, r2
  4025f8:	4a16      	ldr	r2, [pc, #88]	; (402654 <vTaskPriorityInherit+0xec>)
  4025fa:	6013      	str	r3, [r2, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  4025fc:	4b12      	ldr	r3, [pc, #72]	; (402648 <vTaskPriorityInherit+0xe0>)
  4025fe:	681b      	ldr	r3, [r3, #0]
  402600:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402602:	68fb      	ldr	r3, [r7, #12]
  402604:	62da      	str	r2, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
  402606:	68fb      	ldr	r3, [r7, #12]
  402608:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40260a:	2201      	movs	r2, #1
  40260c:	409a      	lsls	r2, r3
  40260e:	4b11      	ldr	r3, [pc, #68]	; (402654 <vTaskPriorityInherit+0xec>)
  402610:	681b      	ldr	r3, [r3, #0]
  402612:	4313      	orrs	r3, r2
  402614:	4a0f      	ldr	r2, [pc, #60]	; (402654 <vTaskPriorityInherit+0xec>)
  402616:	6013      	str	r3, [r2, #0]
  402618:	68fb      	ldr	r3, [r7, #12]
  40261a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  40261c:	4613      	mov	r3, r2
  40261e:	009b      	lsls	r3, r3, #2
  402620:	4413      	add	r3, r2
  402622:	009b      	lsls	r3, r3, #2
  402624:	4a09      	ldr	r2, [pc, #36]	; (40264c <vTaskPriorityInherit+0xe4>)
  402626:	441a      	add	r2, r3
  402628:	68fb      	ldr	r3, [r7, #12]
  40262a:	3304      	adds	r3, #4
  40262c:	4619      	mov	r1, r3
  40262e:	4610      	mov	r0, r2
  402630:	4b09      	ldr	r3, [pc, #36]	; (402658 <vTaskPriorityInherit+0xf0>)
  402632:	4798      	blx	r3
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  402634:	e004      	b.n	402640 <vTaskPriorityInherit+0xd8>
					prvAddTaskToReadyList( pxTCB );
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  402636:	4b04      	ldr	r3, [pc, #16]	; (402648 <vTaskPriorityInherit+0xe0>)
  402638:	681b      	ldr	r3, [r3, #0]
  40263a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  40263c:	68fb      	ldr	r3, [r7, #12]
  40263e:	62da      	str	r2, [r3, #44]	; 0x2c
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  402640:	bf00      	nop
  402642:	3710      	adds	r7, #16
  402644:	46bd      	mov	sp, r7
  402646:	bd80      	pop	{r7, pc}
  402648:	2040c0fc 	.word	0x2040c0fc
  40264c:	2040c100 	.word	0x2040c100
  402650:	004002b5 	.word	0x004002b5
  402654:	2040c1dc 	.word	0x2040c1dc
  402658:	004001f9 	.word	0x004001f9

0040265c <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
  40265c:	b580      	push	{r7, lr}
  40265e:	b086      	sub	sp, #24
  402660:	af00      	add	r7, sp, #0
  402662:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
  402664:	687b      	ldr	r3, [r7, #4]
  402666:	613b      	str	r3, [r7, #16]
	BaseType_t xReturn = pdFALSE;
  402668:	2300      	movs	r3, #0
  40266a:	617b      	str	r3, [r7, #20]

		if( pxMutexHolder != NULL )
  40266c:	687b      	ldr	r3, [r7, #4]
  40266e:	2b00      	cmp	r3, #0
  402670:	d070      	beq.n	402754 <xTaskPriorityDisinherit+0xf8>
		{
			/* A task can only have an inherited priority if it holds the mutex.
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
  402672:	4b3b      	ldr	r3, [pc, #236]	; (402760 <xTaskPriorityDisinherit+0x104>)
  402674:	681b      	ldr	r3, [r3, #0]
  402676:	693a      	ldr	r2, [r7, #16]
  402678:	429a      	cmp	r2, r3
  40267a:	d00b      	beq.n	402694 <xTaskPriorityDisinherit+0x38>
  40267c:	f04f 0380 	mov.w	r3, #128	; 0x80
  402680:	b672      	cpsid	i
  402682:	f383 8811 	msr	BASEPRI, r3
  402686:	f3bf 8f6f 	isb	sy
  40268a:	f3bf 8f4f 	dsb	sy
  40268e:	b662      	cpsie	i
  402690:	60bb      	str	r3, [r7, #8]
  402692:	e7fe      	b.n	402692 <xTaskPriorityDisinherit+0x36>

			configASSERT( pxTCB->uxMutexesHeld );
  402694:	693b      	ldr	r3, [r7, #16]
  402696:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  402698:	2b00      	cmp	r3, #0
  40269a:	d10b      	bne.n	4026b4 <xTaskPriorityDisinherit+0x58>
  40269c:	f04f 0380 	mov.w	r3, #128	; 0x80
  4026a0:	b672      	cpsid	i
  4026a2:	f383 8811 	msr	BASEPRI, r3
  4026a6:	f3bf 8f6f 	isb	sy
  4026aa:	f3bf 8f4f 	dsb	sy
  4026ae:	b662      	cpsie	i
  4026b0:	60fb      	str	r3, [r7, #12]
  4026b2:	e7fe      	b.n	4026b2 <xTaskPriorityDisinherit+0x56>
			( pxTCB->uxMutexesHeld )--;
  4026b4:	693b      	ldr	r3, [r7, #16]
  4026b6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  4026b8:	1e5a      	subs	r2, r3, #1
  4026ba:	693b      	ldr	r3, [r7, #16]
  4026bc:	64da      	str	r2, [r3, #76]	; 0x4c

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
  4026be:	693b      	ldr	r3, [r7, #16]
  4026c0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4026c2:	693b      	ldr	r3, [r7, #16]
  4026c4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  4026c6:	429a      	cmp	r2, r3
  4026c8:	d044      	beq.n	402754 <xTaskPriorityDisinherit+0xf8>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
  4026ca:	693b      	ldr	r3, [r7, #16]
  4026cc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  4026ce:	2b00      	cmp	r3, #0
  4026d0:	d140      	bne.n	402754 <xTaskPriorityDisinherit+0xf8>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  4026d2:	693b      	ldr	r3, [r7, #16]
  4026d4:	3304      	adds	r3, #4
  4026d6:	4618      	mov	r0, r3
  4026d8:	4b22      	ldr	r3, [pc, #136]	; (402764 <xTaskPriorityDisinherit+0x108>)
  4026da:	4798      	blx	r3
  4026dc:	4603      	mov	r3, r0
  4026de:	2b00      	cmp	r3, #0
  4026e0:	d115      	bne.n	40270e <xTaskPriorityDisinherit+0xb2>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  4026e2:	693b      	ldr	r3, [r7, #16]
  4026e4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4026e6:	4920      	ldr	r1, [pc, #128]	; (402768 <xTaskPriorityDisinherit+0x10c>)
  4026e8:	4613      	mov	r3, r2
  4026ea:	009b      	lsls	r3, r3, #2
  4026ec:	4413      	add	r3, r2
  4026ee:	009b      	lsls	r3, r3, #2
  4026f0:	440b      	add	r3, r1
  4026f2:	681b      	ldr	r3, [r3, #0]
  4026f4:	2b00      	cmp	r3, #0
  4026f6:	d10a      	bne.n	40270e <xTaskPriorityDisinherit+0xb2>
  4026f8:	693b      	ldr	r3, [r7, #16]
  4026fa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4026fc:	2201      	movs	r2, #1
  4026fe:	fa02 f303 	lsl.w	r3, r2, r3
  402702:	43da      	mvns	r2, r3
  402704:	4b19      	ldr	r3, [pc, #100]	; (40276c <xTaskPriorityDisinherit+0x110>)
  402706:	681b      	ldr	r3, [r3, #0]
  402708:	4013      	ands	r3, r2
  40270a:	4a18      	ldr	r2, [pc, #96]	; (40276c <xTaskPriorityDisinherit+0x110>)
  40270c:	6013      	str	r3, [r2, #0]
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
  40270e:	693b      	ldr	r3, [r7, #16]
  402710:	6c9a      	ldr	r2, [r3, #72]	; 0x48
  402712:	693b      	ldr	r3, [r7, #16]
  402714:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  402716:	693b      	ldr	r3, [r7, #16]
  402718:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40271a:	f1c3 0205 	rsb	r2, r3, #5
  40271e:	693b      	ldr	r3, [r7, #16]
  402720:	619a      	str	r2, [r3, #24]
					prvAddTaskToReadyList( pxTCB );
  402722:	693b      	ldr	r3, [r7, #16]
  402724:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402726:	2201      	movs	r2, #1
  402728:	409a      	lsls	r2, r3
  40272a:	4b10      	ldr	r3, [pc, #64]	; (40276c <xTaskPriorityDisinherit+0x110>)
  40272c:	681b      	ldr	r3, [r3, #0]
  40272e:	4313      	orrs	r3, r2
  402730:	4a0e      	ldr	r2, [pc, #56]	; (40276c <xTaskPriorityDisinherit+0x110>)
  402732:	6013      	str	r3, [r2, #0]
  402734:	693b      	ldr	r3, [r7, #16]
  402736:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402738:	4613      	mov	r3, r2
  40273a:	009b      	lsls	r3, r3, #2
  40273c:	4413      	add	r3, r2
  40273e:	009b      	lsls	r3, r3, #2
  402740:	4a09      	ldr	r2, [pc, #36]	; (402768 <xTaskPriorityDisinherit+0x10c>)
  402742:	441a      	add	r2, r3
  402744:	693b      	ldr	r3, [r7, #16]
  402746:	3304      	adds	r3, #4
  402748:	4619      	mov	r1, r3
  40274a:	4610      	mov	r0, r2
  40274c:	4b08      	ldr	r3, [pc, #32]	; (402770 <xTaskPriorityDisinherit+0x114>)
  40274e:	4798      	blx	r3
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
  402750:	2301      	movs	r3, #1
  402752:	617b      	str	r3, [r7, #20]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
  402754:	697b      	ldr	r3, [r7, #20]
	}
  402756:	4618      	mov	r0, r3
  402758:	3718      	adds	r7, #24
  40275a:	46bd      	mov	sp, r7
  40275c:	bd80      	pop	{r7, pc}
  40275e:	bf00      	nop
  402760:	2040c0fc 	.word	0x2040c0fc
  402764:	004002b5 	.word	0x004002b5
  402768:	2040c100 	.word	0x2040c100
  40276c:	2040c1dc 	.word	0x2040c1dc
  402770:	004001f9 	.word	0x004001f9

00402774 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
  402774:	b480      	push	{r7}
  402776:	af00      	add	r7, sp, #0
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
  402778:	4b07      	ldr	r3, [pc, #28]	; (402798 <pvTaskIncrementMutexHeldCount+0x24>)
  40277a:	681b      	ldr	r3, [r3, #0]
  40277c:	2b00      	cmp	r3, #0
  40277e:	d004      	beq.n	40278a <pvTaskIncrementMutexHeldCount+0x16>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
  402780:	4b05      	ldr	r3, [pc, #20]	; (402798 <pvTaskIncrementMutexHeldCount+0x24>)
  402782:	681b      	ldr	r3, [r3, #0]
  402784:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  402786:	3201      	adds	r2, #1
  402788:	64da      	str	r2, [r3, #76]	; 0x4c
		}

		return pxCurrentTCB;
  40278a:	4b03      	ldr	r3, [pc, #12]	; (402798 <pvTaskIncrementMutexHeldCount+0x24>)
  40278c:	681b      	ldr	r3, [r3, #0]
	}
  40278e:	4618      	mov	r0, r3
  402790:	46bd      	mov	sp, r7
  402792:	f85d 7b04 	ldr.w	r7, [sp], #4
  402796:	4770      	bx	lr
  402798:	2040c0fc 	.word	0x2040c0fc

0040279c <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
  40279c:	b580      	push	{r7, lr}
  40279e:	b084      	sub	sp, #16
  4027a0:	af00      	add	r7, sp, #0
  4027a2:	6078      	str	r0, [r7, #4]
  4027a4:	6039      	str	r1, [r7, #0]
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
  4027a6:	4b29      	ldr	r3, [pc, #164]	; (40284c <prvAddCurrentTaskToDelayedList+0xb0>)
  4027a8:	681b      	ldr	r3, [r3, #0]
  4027aa:	60fb      	str	r3, [r7, #12]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  4027ac:	4b28      	ldr	r3, [pc, #160]	; (402850 <prvAddCurrentTaskToDelayedList+0xb4>)
  4027ae:	681b      	ldr	r3, [r3, #0]
  4027b0:	3304      	adds	r3, #4
  4027b2:	4618      	mov	r0, r3
  4027b4:	4b27      	ldr	r3, [pc, #156]	; (402854 <prvAddCurrentTaskToDelayedList+0xb8>)
  4027b6:	4798      	blx	r3
  4027b8:	4603      	mov	r3, r0
  4027ba:	2b00      	cmp	r3, #0
  4027bc:	d10b      	bne.n	4027d6 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
  4027be:	4b24      	ldr	r3, [pc, #144]	; (402850 <prvAddCurrentTaskToDelayedList+0xb4>)
  4027c0:	681b      	ldr	r3, [r3, #0]
  4027c2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4027c4:	2201      	movs	r2, #1
  4027c6:	fa02 f303 	lsl.w	r3, r2, r3
  4027ca:	43da      	mvns	r2, r3
  4027cc:	4b22      	ldr	r3, [pc, #136]	; (402858 <prvAddCurrentTaskToDelayedList+0xbc>)
  4027ce:	681b      	ldr	r3, [r3, #0]
  4027d0:	4013      	ands	r3, r2
  4027d2:	4a21      	ldr	r2, [pc, #132]	; (402858 <prvAddCurrentTaskToDelayedList+0xbc>)
  4027d4:	6013      	str	r3, [r2, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
  4027d6:	687b      	ldr	r3, [r7, #4]
  4027d8:	f1b3 3fff 	cmp.w	r3, #4294967295
  4027dc:	d10a      	bne.n	4027f4 <prvAddCurrentTaskToDelayedList+0x58>
  4027de:	683b      	ldr	r3, [r7, #0]
  4027e0:	2b00      	cmp	r3, #0
  4027e2:	d007      	beq.n	4027f4 <prvAddCurrentTaskToDelayedList+0x58>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
  4027e4:	4b1a      	ldr	r3, [pc, #104]	; (402850 <prvAddCurrentTaskToDelayedList+0xb4>)
  4027e6:	681b      	ldr	r3, [r3, #0]
  4027e8:	3304      	adds	r3, #4
  4027ea:	4619      	mov	r1, r3
  4027ec:	481b      	ldr	r0, [pc, #108]	; (40285c <prvAddCurrentTaskToDelayedList+0xc0>)
  4027ee:	4b1c      	ldr	r3, [pc, #112]	; (402860 <prvAddCurrentTaskToDelayedList+0xc4>)
  4027f0:	4798      	blx	r3

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
  4027f2:	e026      	b.n	402842 <prvAddCurrentTaskToDelayedList+0xa6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
  4027f4:	68fa      	ldr	r2, [r7, #12]
  4027f6:	687b      	ldr	r3, [r7, #4]
  4027f8:	4413      	add	r3, r2
  4027fa:	60bb      	str	r3, [r7, #8]

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
  4027fc:	4b14      	ldr	r3, [pc, #80]	; (402850 <prvAddCurrentTaskToDelayedList+0xb4>)
  4027fe:	681b      	ldr	r3, [r3, #0]
  402800:	68ba      	ldr	r2, [r7, #8]
  402802:	605a      	str	r2, [r3, #4]

			if( xTimeToWake < xConstTickCount )
  402804:	68ba      	ldr	r2, [r7, #8]
  402806:	68fb      	ldr	r3, [r7, #12]
  402808:	429a      	cmp	r2, r3
  40280a:	d209      	bcs.n	402820 <prvAddCurrentTaskToDelayedList+0x84>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
  40280c:	4b15      	ldr	r3, [pc, #84]	; (402864 <prvAddCurrentTaskToDelayedList+0xc8>)
  40280e:	681a      	ldr	r2, [r3, #0]
  402810:	4b0f      	ldr	r3, [pc, #60]	; (402850 <prvAddCurrentTaskToDelayedList+0xb4>)
  402812:	681b      	ldr	r3, [r3, #0]
  402814:	3304      	adds	r3, #4
  402816:	4619      	mov	r1, r3
  402818:	4610      	mov	r0, r2
  40281a:	4b13      	ldr	r3, [pc, #76]	; (402868 <prvAddCurrentTaskToDelayedList+0xcc>)
  40281c:	4798      	blx	r3

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
  40281e:	e010      	b.n	402842 <prvAddCurrentTaskToDelayedList+0xa6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
  402820:	4b12      	ldr	r3, [pc, #72]	; (40286c <prvAddCurrentTaskToDelayedList+0xd0>)
  402822:	681a      	ldr	r2, [r3, #0]
  402824:	4b0a      	ldr	r3, [pc, #40]	; (402850 <prvAddCurrentTaskToDelayedList+0xb4>)
  402826:	681b      	ldr	r3, [r3, #0]
  402828:	3304      	adds	r3, #4
  40282a:	4619      	mov	r1, r3
  40282c:	4610      	mov	r0, r2
  40282e:	4b0e      	ldr	r3, [pc, #56]	; (402868 <prvAddCurrentTaskToDelayedList+0xcc>)
  402830:	4798      	blx	r3

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
  402832:	4b0f      	ldr	r3, [pc, #60]	; (402870 <prvAddCurrentTaskToDelayedList+0xd4>)
  402834:	681b      	ldr	r3, [r3, #0]
  402836:	68ba      	ldr	r2, [r7, #8]
  402838:	429a      	cmp	r2, r3
  40283a:	d202      	bcs.n	402842 <prvAddCurrentTaskToDelayedList+0xa6>
				{
					xNextTaskUnblockTime = xTimeToWake;
  40283c:	4a0c      	ldr	r2, [pc, #48]	; (402870 <prvAddCurrentTaskToDelayedList+0xd4>)
  40283e:	68bb      	ldr	r3, [r7, #8]
  402840:	6013      	str	r3, [r2, #0]

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
  402842:	bf00      	nop
  402844:	3710      	adds	r7, #16
  402846:	46bd      	mov	sp, r7
  402848:	bd80      	pop	{r7, pc}
  40284a:	bf00      	nop
  40284c:	2040c1d8 	.word	0x2040c1d8
  402850:	2040c0fc 	.word	0x2040c0fc
  402854:	004002b5 	.word	0x004002b5
  402858:	2040c1dc 	.word	0x2040c1dc
  40285c:	2040c1c0 	.word	0x2040c1c0
  402860:	004001f9 	.word	0x004001f9
  402864:	2040c190 	.word	0x2040c190
  402868:	00400241 	.word	0x00400241
  40286c:	2040c18c 	.word	0x2040c18c
  402870:	2040c1f4 	.word	0x2040c1f4

00402874 <xTimerCreateTimerTask>:
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
  402874:	b590      	push	{r4, r7, lr}
  402876:	b085      	sub	sp, #20
  402878:	af02      	add	r7, sp, #8
BaseType_t xReturn = pdFAIL;
  40287a:	2300      	movs	r3, #0
  40287c:	607b      	str	r3, [r7, #4]

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
  40287e:	4b13      	ldr	r3, [pc, #76]	; (4028cc <xTimerCreateTimerTask+0x58>)
  402880:	4798      	blx	r3

	if( xTimerQueue != NULL )
  402882:	4b13      	ldr	r3, [pc, #76]	; (4028d0 <xTimerCreateTimerTask+0x5c>)
  402884:	681b      	ldr	r3, [r3, #0]
  402886:	2b00      	cmp	r3, #0
  402888:	d00b      	beq.n	4028a2 <xTimerCreateTimerTask+0x2e>
				xReturn = pdPASS;
			}
		}
		#else
		{
			xReturn = xTaskCreate(	prvTimerTask,
  40288a:	4b12      	ldr	r3, [pc, #72]	; (4028d4 <xTimerCreateTimerTask+0x60>)
  40288c:	9301      	str	r3, [sp, #4]
  40288e:	2304      	movs	r3, #4
  402890:	9300      	str	r3, [sp, #0]
  402892:	2300      	movs	r3, #0
  402894:	f44f 7282 	mov.w	r2, #260	; 0x104
  402898:	490f      	ldr	r1, [pc, #60]	; (4028d8 <xTimerCreateTimerTask+0x64>)
  40289a:	4810      	ldr	r0, [pc, #64]	; (4028dc <xTimerCreateTimerTask+0x68>)
  40289c:	4c10      	ldr	r4, [pc, #64]	; (4028e0 <xTimerCreateTimerTask+0x6c>)
  40289e:	47a0      	blx	r4
  4028a0:	6078      	str	r0, [r7, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
  4028a2:	687b      	ldr	r3, [r7, #4]
  4028a4:	2b00      	cmp	r3, #0
  4028a6:	d10b      	bne.n	4028c0 <xTimerCreateTimerTask+0x4c>
  4028a8:	f04f 0380 	mov.w	r3, #128	; 0x80
  4028ac:	b672      	cpsid	i
  4028ae:	f383 8811 	msr	BASEPRI, r3
  4028b2:	f3bf 8f6f 	isb	sy
  4028b6:	f3bf 8f4f 	dsb	sy
  4028ba:	b662      	cpsie	i
  4028bc:	603b      	str	r3, [r7, #0]
  4028be:	e7fe      	b.n	4028be <xTimerCreateTimerTask+0x4a>
	return xReturn;
  4028c0:	687b      	ldr	r3, [r7, #4]
}
  4028c2:	4618      	mov	r0, r3
  4028c4:	370c      	adds	r7, #12
  4028c6:	46bd      	mov	sp, r7
  4028c8:	bd90      	pop	{r4, r7, pc}
  4028ca:	bf00      	nop
  4028cc:	00402e5d 	.word	0x00402e5d
  4028d0:	2040c238 	.word	0x2040c238
  4028d4:	2040c23c 	.word	0x2040c23c
  4028d8:	0040abc0 	.word	0x0040abc0
  4028dc:	00402a1d 	.word	0x00402a1d
  4028e0:	00401835 	.word	0x00401835

004028e4 <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
  4028e4:	b590      	push	{r4, r7, lr}
  4028e6:	b08b      	sub	sp, #44	; 0x2c
  4028e8:	af00      	add	r7, sp, #0
  4028ea:	60f8      	str	r0, [r7, #12]
  4028ec:	60b9      	str	r1, [r7, #8]
  4028ee:	607a      	str	r2, [r7, #4]
  4028f0:	603b      	str	r3, [r7, #0]
BaseType_t xReturn = pdFAIL;
  4028f2:	2300      	movs	r3, #0
  4028f4:	627b      	str	r3, [r7, #36]	; 0x24
DaemonTaskMessage_t xMessage;

	configASSERT( xTimer );
  4028f6:	68fb      	ldr	r3, [r7, #12]
  4028f8:	2b00      	cmp	r3, #0
  4028fa:	d10b      	bne.n	402914 <xTimerGenericCommand+0x30>
  4028fc:	f04f 0380 	mov.w	r3, #128	; 0x80
  402900:	b672      	cpsid	i
  402902:	f383 8811 	msr	BASEPRI, r3
  402906:	f3bf 8f6f 	isb	sy
  40290a:	f3bf 8f4f 	dsb	sy
  40290e:	b662      	cpsie	i
  402910:	623b      	str	r3, [r7, #32]
  402912:	e7fe      	b.n	402912 <xTimerGenericCommand+0x2e>

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
  402914:	4b19      	ldr	r3, [pc, #100]	; (40297c <xTimerGenericCommand+0x98>)
  402916:	681b      	ldr	r3, [r3, #0]
  402918:	2b00      	cmp	r3, #0
  40291a:	d02a      	beq.n	402972 <xTimerGenericCommand+0x8e>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
  40291c:	68bb      	ldr	r3, [r7, #8]
  40291e:	613b      	str	r3, [r7, #16]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
  402920:	687b      	ldr	r3, [r7, #4]
  402922:	617b      	str	r3, [r7, #20]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
  402924:	68fb      	ldr	r3, [r7, #12]
  402926:	61bb      	str	r3, [r7, #24]

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
  402928:	68bb      	ldr	r3, [r7, #8]
  40292a:	2b05      	cmp	r3, #5
  40292c:	dc18      	bgt.n	402960 <xTimerGenericCommand+0x7c>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
  40292e:	4b14      	ldr	r3, [pc, #80]	; (402980 <xTimerGenericCommand+0x9c>)
  402930:	4798      	blx	r3
  402932:	4603      	mov	r3, r0
  402934:	2b02      	cmp	r3, #2
  402936:	d109      	bne.n	40294c <xTimerGenericCommand+0x68>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
  402938:	4b10      	ldr	r3, [pc, #64]	; (40297c <xTimerGenericCommand+0x98>)
  40293a:	6818      	ldr	r0, [r3, #0]
  40293c:	f107 0110 	add.w	r1, r7, #16
  402940:	2300      	movs	r3, #0
  402942:	6bba      	ldr	r2, [r7, #56]	; 0x38
  402944:	4c0f      	ldr	r4, [pc, #60]	; (402984 <xTimerGenericCommand+0xa0>)
  402946:	47a0      	blx	r4
  402948:	6278      	str	r0, [r7, #36]	; 0x24
  40294a:	e012      	b.n	402972 <xTimerGenericCommand+0x8e>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
  40294c:	4b0b      	ldr	r3, [pc, #44]	; (40297c <xTimerGenericCommand+0x98>)
  40294e:	6818      	ldr	r0, [r3, #0]
  402950:	f107 0110 	add.w	r1, r7, #16
  402954:	2300      	movs	r3, #0
  402956:	2200      	movs	r2, #0
  402958:	4c0a      	ldr	r4, [pc, #40]	; (402984 <xTimerGenericCommand+0xa0>)
  40295a:	47a0      	blx	r4
  40295c:	6278      	str	r0, [r7, #36]	; 0x24
  40295e:	e008      	b.n	402972 <xTimerGenericCommand+0x8e>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
  402960:	4b06      	ldr	r3, [pc, #24]	; (40297c <xTimerGenericCommand+0x98>)
  402962:	6818      	ldr	r0, [r3, #0]
  402964:	f107 0110 	add.w	r1, r7, #16
  402968:	2300      	movs	r3, #0
  40296a:	683a      	ldr	r2, [r7, #0]
  40296c:	4c06      	ldr	r4, [pc, #24]	; (402988 <xTimerGenericCommand+0xa4>)
  40296e:	47a0      	blx	r4
  402970:	6278      	str	r0, [r7, #36]	; 0x24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
  402972:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
  402974:	4618      	mov	r0, r3
  402976:	372c      	adds	r7, #44	; 0x2c
  402978:	46bd      	mov	sp, r7
  40297a:	bd90      	pop	{r4, r7, pc}
  40297c:	2040c238 	.word	0x2040c238
  402980:	0040252d 	.word	0x0040252d
  402984:	00400cad 	.word	0x00400cad
  402988:	00400f0d 	.word	0x00400f0d

0040298c <prvProcessExpiredTimer>:
	return pxTimer->pcTimerName;
}
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
  40298c:	b590      	push	{r4, r7, lr}
  40298e:	b089      	sub	sp, #36	; 0x24
  402990:	af02      	add	r7, sp, #8
  402992:	6078      	str	r0, [r7, #4]
  402994:	6039      	str	r1, [r7, #0]
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
  402996:	4b1d      	ldr	r3, [pc, #116]	; (402a0c <prvProcessExpiredTimer+0x80>)
  402998:	681b      	ldr	r3, [r3, #0]
  40299a:	68db      	ldr	r3, [r3, #12]
  40299c:	68db      	ldr	r3, [r3, #12]
  40299e:	617b      	str	r3, [r7, #20]

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  4029a0:	697b      	ldr	r3, [r7, #20]
  4029a2:	3304      	adds	r3, #4
  4029a4:	4618      	mov	r0, r3
  4029a6:	4b1a      	ldr	r3, [pc, #104]	; (402a10 <prvProcessExpiredTimer+0x84>)
  4029a8:	4798      	blx	r3
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
  4029aa:	697b      	ldr	r3, [r7, #20]
  4029ac:	69db      	ldr	r3, [r3, #28]
  4029ae:	2b01      	cmp	r3, #1
  4029b0:	d123      	bne.n	4029fa <prvProcessExpiredTimer+0x6e>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
  4029b2:	697b      	ldr	r3, [r7, #20]
  4029b4:	699a      	ldr	r2, [r3, #24]
  4029b6:	687b      	ldr	r3, [r7, #4]
  4029b8:	18d1      	adds	r1, r2, r3
  4029ba:	687b      	ldr	r3, [r7, #4]
  4029bc:	683a      	ldr	r2, [r7, #0]
  4029be:	6978      	ldr	r0, [r7, #20]
  4029c0:	4c14      	ldr	r4, [pc, #80]	; (402a14 <prvProcessExpiredTimer+0x88>)
  4029c2:	47a0      	blx	r4
  4029c4:	4603      	mov	r3, r0
  4029c6:	2b00      	cmp	r3, #0
  4029c8:	d017      	beq.n	4029fa <prvProcessExpiredTimer+0x6e>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
  4029ca:	2300      	movs	r3, #0
  4029cc:	9300      	str	r3, [sp, #0]
  4029ce:	2300      	movs	r3, #0
  4029d0:	687a      	ldr	r2, [r7, #4]
  4029d2:	2100      	movs	r1, #0
  4029d4:	6978      	ldr	r0, [r7, #20]
  4029d6:	4c10      	ldr	r4, [pc, #64]	; (402a18 <prvProcessExpiredTimer+0x8c>)
  4029d8:	47a0      	blx	r4
  4029da:	6138      	str	r0, [r7, #16]
			configASSERT( xResult );
  4029dc:	693b      	ldr	r3, [r7, #16]
  4029de:	2b00      	cmp	r3, #0
  4029e0:	d10b      	bne.n	4029fa <prvProcessExpiredTimer+0x6e>
  4029e2:	f04f 0380 	mov.w	r3, #128	; 0x80
  4029e6:	b672      	cpsid	i
  4029e8:	f383 8811 	msr	BASEPRI, r3
  4029ec:	f3bf 8f6f 	isb	sy
  4029f0:	f3bf 8f4f 	dsb	sy
  4029f4:	b662      	cpsie	i
  4029f6:	60fb      	str	r3, [r7, #12]
  4029f8:	e7fe      	b.n	4029f8 <prvProcessExpiredTimer+0x6c>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
  4029fa:	697b      	ldr	r3, [r7, #20]
  4029fc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  4029fe:	6978      	ldr	r0, [r7, #20]
  402a00:	4798      	blx	r3
}
  402a02:	bf00      	nop
  402a04:	371c      	adds	r7, #28
  402a06:	46bd      	mov	sp, r7
  402a08:	bd90      	pop	{r4, r7, pc}
  402a0a:	bf00      	nop
  402a0c:	2040c230 	.word	0x2040c230
  402a10:	004002b5 	.word	0x004002b5
  402a14:	00402b8d 	.word	0x00402b8d
  402a18:	004028e5 	.word	0x004028e5

00402a1c <prvTimerTask>:
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
  402a1c:	b580      	push	{r7, lr}
  402a1e:	b084      	sub	sp, #16
  402a20:	af00      	add	r7, sp, #0
  402a22:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
  402a24:	f107 0308 	add.w	r3, r7, #8
  402a28:	4618      	mov	r0, r3
  402a2a:	4b05      	ldr	r3, [pc, #20]	; (402a40 <prvTimerTask+0x24>)
  402a2c:	4798      	blx	r3
  402a2e:	60f8      	str	r0, [r7, #12]

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
  402a30:	68bb      	ldr	r3, [r7, #8]
  402a32:	4619      	mov	r1, r3
  402a34:	68f8      	ldr	r0, [r7, #12]
  402a36:	4b03      	ldr	r3, [pc, #12]	; (402a44 <prvTimerTask+0x28>)
  402a38:	4798      	blx	r3

		/* Empty the command queue. */
		prvProcessReceivedCommands();
  402a3a:	4b03      	ldr	r3, [pc, #12]	; (402a48 <prvTimerTask+0x2c>)
  402a3c:	4798      	blx	r3
	}
  402a3e:	e7f1      	b.n	402a24 <prvTimerTask+0x8>
  402a40:	00402afd 	.word	0x00402afd
  402a44:	00402a4d 	.word	0x00402a4d
  402a48:	00402c15 	.word	0x00402c15

00402a4c <prvProcessTimerOrBlockTask>:
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
  402a4c:	b580      	push	{r7, lr}
  402a4e:	b084      	sub	sp, #16
  402a50:	af00      	add	r7, sp, #0
  402a52:	6078      	str	r0, [r7, #4]
  402a54:	6039      	str	r1, [r7, #0]
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
  402a56:	4b21      	ldr	r3, [pc, #132]	; (402adc <prvProcessTimerOrBlockTask+0x90>)
  402a58:	4798      	blx	r3
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  402a5a:	f107 0308 	add.w	r3, r7, #8
  402a5e:	4618      	mov	r0, r3
  402a60:	4b1f      	ldr	r3, [pc, #124]	; (402ae0 <prvProcessTimerOrBlockTask+0x94>)
  402a62:	4798      	blx	r3
  402a64:	60f8      	str	r0, [r7, #12]
		if( xTimerListsWereSwitched == pdFALSE )
  402a66:	68bb      	ldr	r3, [r7, #8]
  402a68:	2b00      	cmp	r3, #0
  402a6a:	d130      	bne.n	402ace <prvProcessTimerOrBlockTask+0x82>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
  402a6c:	683b      	ldr	r3, [r7, #0]
  402a6e:	2b00      	cmp	r3, #0
  402a70:	d10a      	bne.n	402a88 <prvProcessTimerOrBlockTask+0x3c>
  402a72:	687a      	ldr	r2, [r7, #4]
  402a74:	68fb      	ldr	r3, [r7, #12]
  402a76:	429a      	cmp	r2, r3
  402a78:	d806      	bhi.n	402a88 <prvProcessTimerOrBlockTask+0x3c>
			{
				( void ) xTaskResumeAll();
  402a7a:	4b1a      	ldr	r3, [pc, #104]	; (402ae4 <prvProcessTimerOrBlockTask+0x98>)
  402a7c:	4798      	blx	r3
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
  402a7e:	68f9      	ldr	r1, [r7, #12]
  402a80:	6878      	ldr	r0, [r7, #4]
  402a82:	4b19      	ldr	r3, [pc, #100]	; (402ae8 <prvProcessTimerOrBlockTask+0x9c>)
  402a84:	4798      	blx	r3
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
  402a86:	e024      	b.n	402ad2 <prvProcessTimerOrBlockTask+0x86>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
  402a88:	683b      	ldr	r3, [r7, #0]
  402a8a:	2b00      	cmp	r3, #0
  402a8c:	d008      	beq.n	402aa0 <prvProcessTimerOrBlockTask+0x54>
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
  402a8e:	4b17      	ldr	r3, [pc, #92]	; (402aec <prvProcessTimerOrBlockTask+0xa0>)
  402a90:	681b      	ldr	r3, [r3, #0]
  402a92:	681b      	ldr	r3, [r3, #0]
  402a94:	2b00      	cmp	r3, #0
  402a96:	bf0c      	ite	eq
  402a98:	2301      	moveq	r3, #1
  402a9a:	2300      	movne	r3, #0
  402a9c:	b2db      	uxtb	r3, r3
  402a9e:	603b      	str	r3, [r7, #0]
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
  402aa0:	4b13      	ldr	r3, [pc, #76]	; (402af0 <prvProcessTimerOrBlockTask+0xa4>)
  402aa2:	6818      	ldr	r0, [r3, #0]
  402aa4:	687a      	ldr	r2, [r7, #4]
  402aa6:	68fb      	ldr	r3, [r7, #12]
  402aa8:	1ad3      	subs	r3, r2, r3
  402aaa:	683a      	ldr	r2, [r7, #0]
  402aac:	4619      	mov	r1, r3
  402aae:	4b11      	ldr	r3, [pc, #68]	; (402af4 <prvProcessTimerOrBlockTask+0xa8>)
  402ab0:	4798      	blx	r3

				if( xTaskResumeAll() == pdFALSE )
  402ab2:	4b0c      	ldr	r3, [pc, #48]	; (402ae4 <prvProcessTimerOrBlockTask+0x98>)
  402ab4:	4798      	blx	r3
  402ab6:	4603      	mov	r3, r0
  402ab8:	2b00      	cmp	r3, #0
  402aba:	d10a      	bne.n	402ad2 <prvProcessTimerOrBlockTask+0x86>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
  402abc:	4b0e      	ldr	r3, [pc, #56]	; (402af8 <prvProcessTimerOrBlockTask+0xac>)
  402abe:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  402ac2:	601a      	str	r2, [r3, #0]
  402ac4:	f3bf 8f4f 	dsb	sy
  402ac8:	f3bf 8f6f 	isb	sy
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
  402acc:	e001      	b.n	402ad2 <prvProcessTimerOrBlockTask+0x86>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
  402ace:	4b05      	ldr	r3, [pc, #20]	; (402ae4 <prvProcessTimerOrBlockTask+0x98>)
  402ad0:	4798      	blx	r3
		}
	}
}
  402ad2:	bf00      	nop
  402ad4:	3710      	adds	r7, #16
  402ad6:	46bd      	mov	sp, r7
  402ad8:	bd80      	pop	{r7, pc}
  402ada:	bf00      	nop
  402adc:	00401c89 	.word	0x00401c89
  402ae0:	00402b45 	.word	0x00402b45
  402ae4:	00401ca5 	.word	0x00401ca5
  402ae8:	0040298d 	.word	0x0040298d
  402aec:	2040c234 	.word	0x2040c234
  402af0:	2040c238 	.word	0x2040c238
  402af4:	004016fd 	.word	0x004016fd
  402af8:	e000ed04 	.word	0xe000ed04

00402afc <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
{
  402afc:	b480      	push	{r7}
  402afe:	b085      	sub	sp, #20
  402b00:	af00      	add	r7, sp, #0
  402b02:	6078      	str	r0, [r7, #4]
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
  402b04:	4b0e      	ldr	r3, [pc, #56]	; (402b40 <prvGetNextExpireTime+0x44>)
  402b06:	681b      	ldr	r3, [r3, #0]
  402b08:	681b      	ldr	r3, [r3, #0]
  402b0a:	2b00      	cmp	r3, #0
  402b0c:	bf0c      	ite	eq
  402b0e:	2301      	moveq	r3, #1
  402b10:	2300      	movne	r3, #0
  402b12:	b2db      	uxtb	r3, r3
  402b14:	461a      	mov	r2, r3
  402b16:	687b      	ldr	r3, [r7, #4]
  402b18:	601a      	str	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
  402b1a:	687b      	ldr	r3, [r7, #4]
  402b1c:	681b      	ldr	r3, [r3, #0]
  402b1e:	2b00      	cmp	r3, #0
  402b20:	d105      	bne.n	402b2e <prvGetNextExpireTime+0x32>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  402b22:	4b07      	ldr	r3, [pc, #28]	; (402b40 <prvGetNextExpireTime+0x44>)
  402b24:	681b      	ldr	r3, [r3, #0]
  402b26:	68db      	ldr	r3, [r3, #12]
  402b28:	681b      	ldr	r3, [r3, #0]
  402b2a:	60fb      	str	r3, [r7, #12]
  402b2c:	e001      	b.n	402b32 <prvGetNextExpireTime+0x36>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
  402b2e:	2300      	movs	r3, #0
  402b30:	60fb      	str	r3, [r7, #12]
	}

	return xNextExpireTime;
  402b32:	68fb      	ldr	r3, [r7, #12]
}
  402b34:	4618      	mov	r0, r3
  402b36:	3714      	adds	r7, #20
  402b38:	46bd      	mov	sp, r7
  402b3a:	f85d 7b04 	ldr.w	r7, [sp], #4
  402b3e:	4770      	bx	lr
  402b40:	2040c230 	.word	0x2040c230

00402b44 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
  402b44:	b580      	push	{r7, lr}
  402b46:	b084      	sub	sp, #16
  402b48:	af00      	add	r7, sp, #0
  402b4a:	6078      	str	r0, [r7, #4]
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
  402b4c:	4b0c      	ldr	r3, [pc, #48]	; (402b80 <prvSampleTimeNow+0x3c>)
  402b4e:	4798      	blx	r3
  402b50:	60f8      	str	r0, [r7, #12]

	if( xTimeNow < xLastTime )
  402b52:	4b0c      	ldr	r3, [pc, #48]	; (402b84 <prvSampleTimeNow+0x40>)
  402b54:	681b      	ldr	r3, [r3, #0]
  402b56:	68fa      	ldr	r2, [r7, #12]
  402b58:	429a      	cmp	r2, r3
  402b5a:	d205      	bcs.n	402b68 <prvSampleTimeNow+0x24>
	{
		prvSwitchTimerLists();
  402b5c:	4b0a      	ldr	r3, [pc, #40]	; (402b88 <prvSampleTimeNow+0x44>)
  402b5e:	4798      	blx	r3
		*pxTimerListsWereSwitched = pdTRUE;
  402b60:	687b      	ldr	r3, [r7, #4]
  402b62:	2201      	movs	r2, #1
  402b64:	601a      	str	r2, [r3, #0]
  402b66:	e002      	b.n	402b6e <prvSampleTimeNow+0x2a>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
  402b68:	687b      	ldr	r3, [r7, #4]
  402b6a:	2200      	movs	r2, #0
  402b6c:	601a      	str	r2, [r3, #0]
	}

	xLastTime = xTimeNow;
  402b6e:	4a05      	ldr	r2, [pc, #20]	; (402b84 <prvSampleTimeNow+0x40>)
  402b70:	68fb      	ldr	r3, [r7, #12]
  402b72:	6013      	str	r3, [r2, #0]

	return xTimeNow;
  402b74:	68fb      	ldr	r3, [r7, #12]
}
  402b76:	4618      	mov	r0, r3
  402b78:	3710      	adds	r7, #16
  402b7a:	46bd      	mov	sp, r7
  402b7c:	bd80      	pop	{r7, pc}
  402b7e:	bf00      	nop
  402b80:	00401df9 	.word	0x00401df9
  402b84:	2040c240 	.word	0x2040c240
  402b88:	00402d8d 	.word	0x00402d8d

00402b8c <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
  402b8c:	b580      	push	{r7, lr}
  402b8e:	b086      	sub	sp, #24
  402b90:	af00      	add	r7, sp, #0
  402b92:	60f8      	str	r0, [r7, #12]
  402b94:	60b9      	str	r1, [r7, #8]
  402b96:	607a      	str	r2, [r7, #4]
  402b98:	603b      	str	r3, [r7, #0]
BaseType_t xProcessTimerNow = pdFALSE;
  402b9a:	2300      	movs	r3, #0
  402b9c:	617b      	str	r3, [r7, #20]

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
  402b9e:	68fb      	ldr	r3, [r7, #12]
  402ba0:	68ba      	ldr	r2, [r7, #8]
  402ba2:	605a      	str	r2, [r3, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  402ba4:	68fb      	ldr	r3, [r7, #12]
  402ba6:	68fa      	ldr	r2, [r7, #12]
  402ba8:	611a      	str	r2, [r3, #16]

	if( xNextExpiryTime <= xTimeNow )
  402baa:	68ba      	ldr	r2, [r7, #8]
  402bac:	687b      	ldr	r3, [r7, #4]
  402bae:	429a      	cmp	r2, r3
  402bb0:	d812      	bhi.n	402bd8 <prvInsertTimerInActiveList+0x4c>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  402bb2:	687a      	ldr	r2, [r7, #4]
  402bb4:	683b      	ldr	r3, [r7, #0]
  402bb6:	1ad2      	subs	r2, r2, r3
  402bb8:	68fb      	ldr	r3, [r7, #12]
  402bba:	699b      	ldr	r3, [r3, #24]
  402bbc:	429a      	cmp	r2, r3
  402bbe:	d302      	bcc.n	402bc6 <prvInsertTimerInActiveList+0x3a>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
  402bc0:	2301      	movs	r3, #1
  402bc2:	617b      	str	r3, [r7, #20]
  402bc4:	e01b      	b.n	402bfe <prvInsertTimerInActiveList+0x72>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
  402bc6:	4b10      	ldr	r3, [pc, #64]	; (402c08 <prvInsertTimerInActiveList+0x7c>)
  402bc8:	681a      	ldr	r2, [r3, #0]
  402bca:	68fb      	ldr	r3, [r7, #12]
  402bcc:	3304      	adds	r3, #4
  402bce:	4619      	mov	r1, r3
  402bd0:	4610      	mov	r0, r2
  402bd2:	4b0e      	ldr	r3, [pc, #56]	; (402c0c <prvInsertTimerInActiveList+0x80>)
  402bd4:	4798      	blx	r3
  402bd6:	e012      	b.n	402bfe <prvInsertTimerInActiveList+0x72>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
  402bd8:	687a      	ldr	r2, [r7, #4]
  402bda:	683b      	ldr	r3, [r7, #0]
  402bdc:	429a      	cmp	r2, r3
  402bde:	d206      	bcs.n	402bee <prvInsertTimerInActiveList+0x62>
  402be0:	68ba      	ldr	r2, [r7, #8]
  402be2:	683b      	ldr	r3, [r7, #0]
  402be4:	429a      	cmp	r2, r3
  402be6:	d302      	bcc.n	402bee <prvInsertTimerInActiveList+0x62>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
  402be8:	2301      	movs	r3, #1
  402bea:	617b      	str	r3, [r7, #20]
  402bec:	e007      	b.n	402bfe <prvInsertTimerInActiveList+0x72>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  402bee:	4b08      	ldr	r3, [pc, #32]	; (402c10 <prvInsertTimerInActiveList+0x84>)
  402bf0:	681a      	ldr	r2, [r3, #0]
  402bf2:	68fb      	ldr	r3, [r7, #12]
  402bf4:	3304      	adds	r3, #4
  402bf6:	4619      	mov	r1, r3
  402bf8:	4610      	mov	r0, r2
  402bfa:	4b04      	ldr	r3, [pc, #16]	; (402c0c <prvInsertTimerInActiveList+0x80>)
  402bfc:	4798      	blx	r3
		}
	}

	return xProcessTimerNow;
  402bfe:	697b      	ldr	r3, [r7, #20]
}
  402c00:	4618      	mov	r0, r3
  402c02:	3718      	adds	r7, #24
  402c04:	46bd      	mov	sp, r7
  402c06:	bd80      	pop	{r7, pc}
  402c08:	2040c234 	.word	0x2040c234
  402c0c:	00400241 	.word	0x00400241
  402c10:	2040c230 	.word	0x2040c230

00402c14 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
  402c14:	b590      	push	{r4, r7, lr}
  402c16:	b08f      	sub	sp, #60	; 0x3c
  402c18:	af02      	add	r7, sp, #8
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
  402c1a:	e09a      	b.n	402d52 <prvProcessReceivedCommands+0x13e>
	{
		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
		{
			/* Negative commands are pended function calls rather than timer
			commands. */
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
  402c1c:	687b      	ldr	r3, [r7, #4]
  402c1e:	2b00      	cmp	r3, #0
  402c20:	da19      	bge.n	402c56 <prvProcessReceivedCommands+0x42>
			{
				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
  402c22:	1d3b      	adds	r3, r7, #4
  402c24:	3304      	adds	r3, #4
  402c26:	62fb      	str	r3, [r7, #44]	; 0x2c

				/* The timer uses the xCallbackParameters member to request a
				callback be executed.  Check the callback is not NULL. */
				configASSERT( pxCallback );
  402c28:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  402c2a:	2b00      	cmp	r3, #0
  402c2c:	d10b      	bne.n	402c46 <prvProcessReceivedCommands+0x32>
  402c2e:	f04f 0380 	mov.w	r3, #128	; 0x80
  402c32:	b672      	cpsid	i
  402c34:	f383 8811 	msr	BASEPRI, r3
  402c38:	f3bf 8f6f 	isb	sy
  402c3c:	f3bf 8f4f 	dsb	sy
  402c40:	b662      	cpsie	i
  402c42:	617b      	str	r3, [r7, #20]
  402c44:	e7fe      	b.n	402c44 <prvProcessReceivedCommands+0x30>

				/* Call the function. */
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
  402c46:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  402c48:	681b      	ldr	r3, [r3, #0]
  402c4a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  402c4c:	6850      	ldr	r0, [r2, #4]
  402c4e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  402c50:	6892      	ldr	r2, [r2, #8]
  402c52:	4611      	mov	r1, r2
  402c54:	4798      	blx	r3
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
  402c56:	687b      	ldr	r3, [r7, #4]
  402c58:	2b00      	cmp	r3, #0
  402c5a:	db7a      	blt.n	402d52 <prvProcessReceivedCommands+0x13e>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
  402c5c:	68fb      	ldr	r3, [r7, #12]
  402c5e:	627b      	str	r3, [r7, #36]	; 0x24

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
  402c60:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402c62:	695b      	ldr	r3, [r3, #20]
  402c64:	2b00      	cmp	r3, #0
  402c66:	d004      	beq.n	402c72 <prvProcessReceivedCommands+0x5e>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  402c68:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402c6a:	3304      	adds	r3, #4
  402c6c:	4618      	mov	r0, r3
  402c6e:	4b40      	ldr	r3, [pc, #256]	; (402d70 <prvProcessReceivedCommands+0x15c>)
  402c70:	4798      	blx	r3
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  402c72:	463b      	mov	r3, r7
  402c74:	4618      	mov	r0, r3
  402c76:	4b3f      	ldr	r3, [pc, #252]	; (402d74 <prvProcessReceivedCommands+0x160>)
  402c78:	4798      	blx	r3
  402c7a:	6238      	str	r0, [r7, #32]

			switch( xMessage.xMessageID )
  402c7c:	687b      	ldr	r3, [r7, #4]
  402c7e:	2b09      	cmp	r3, #9
  402c80:	d866      	bhi.n	402d50 <prvProcessReceivedCommands+0x13c>
  402c82:	a201      	add	r2, pc, #4	; (adr r2, 402c88 <prvProcessReceivedCommands+0x74>)
  402c84:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  402c88:	00402cb1 	.word	0x00402cb1
  402c8c:	00402cb1 	.word	0x00402cb1
  402c90:	00402cb1 	.word	0x00402cb1
  402c94:	00402d53 	.word	0x00402d53
  402c98:	00402d0f 	.word	0x00402d0f
  402c9c:	00402d49 	.word	0x00402d49
  402ca0:	00402cb1 	.word	0x00402cb1
  402ca4:	00402cb1 	.word	0x00402cb1
  402ca8:	00402d53 	.word	0x00402d53
  402cac:	00402d0f 	.word	0x00402d0f
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
  402cb0:	68ba      	ldr	r2, [r7, #8]
  402cb2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402cb4:	699b      	ldr	r3, [r3, #24]
  402cb6:	18d1      	adds	r1, r2, r3
  402cb8:	68bb      	ldr	r3, [r7, #8]
  402cba:	6a3a      	ldr	r2, [r7, #32]
  402cbc:	6a78      	ldr	r0, [r7, #36]	; 0x24
  402cbe:	4c2e      	ldr	r4, [pc, #184]	; (402d78 <prvProcessReceivedCommands+0x164>)
  402cc0:	47a0      	blx	r4
  402cc2:	4603      	mov	r3, r0
  402cc4:	2b00      	cmp	r3, #0
  402cc6:	d044      	beq.n	402d52 <prvProcessReceivedCommands+0x13e>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
  402cc8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402cca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  402ccc:	6a78      	ldr	r0, [r7, #36]	; 0x24
  402cce:	4798      	blx	r3
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
  402cd0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402cd2:	69db      	ldr	r3, [r3, #28]
  402cd4:	2b01      	cmp	r3, #1
  402cd6:	d13c      	bne.n	402d52 <prvProcessReceivedCommands+0x13e>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
  402cd8:	68ba      	ldr	r2, [r7, #8]
  402cda:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402cdc:	699b      	ldr	r3, [r3, #24]
  402cde:	441a      	add	r2, r3
  402ce0:	2300      	movs	r3, #0
  402ce2:	9300      	str	r3, [sp, #0]
  402ce4:	2300      	movs	r3, #0
  402ce6:	2100      	movs	r1, #0
  402ce8:	6a78      	ldr	r0, [r7, #36]	; 0x24
  402cea:	4c24      	ldr	r4, [pc, #144]	; (402d7c <prvProcessReceivedCommands+0x168>)
  402cec:	47a0      	blx	r4
  402cee:	61f8      	str	r0, [r7, #28]
							configASSERT( xResult );
  402cf0:	69fb      	ldr	r3, [r7, #28]
  402cf2:	2b00      	cmp	r3, #0
  402cf4:	d12d      	bne.n	402d52 <prvProcessReceivedCommands+0x13e>
  402cf6:	f04f 0380 	mov.w	r3, #128	; 0x80
  402cfa:	b672      	cpsid	i
  402cfc:	f383 8811 	msr	BASEPRI, r3
  402d00:	f3bf 8f6f 	isb	sy
  402d04:	f3bf 8f4f 	dsb	sy
  402d08:	b662      	cpsie	i
  402d0a:	62bb      	str	r3, [r7, #40]	; 0x28
  402d0c:	e7fe      	b.n	402d0c <prvProcessReceivedCommands+0xf8>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
  402d0e:	68ba      	ldr	r2, [r7, #8]
  402d10:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402d12:	619a      	str	r2, [r3, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
  402d14:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402d16:	699b      	ldr	r3, [r3, #24]
  402d18:	2b00      	cmp	r3, #0
  402d1a:	d10b      	bne.n	402d34 <prvProcessReceivedCommands+0x120>
  402d1c:	f04f 0380 	mov.w	r3, #128	; 0x80
  402d20:	b672      	cpsid	i
  402d22:	f383 8811 	msr	BASEPRI, r3
  402d26:	f3bf 8f6f 	isb	sy
  402d2a:	f3bf 8f4f 	dsb	sy
  402d2e:	b662      	cpsie	i
  402d30:	61bb      	str	r3, [r7, #24]
  402d32:	e7fe      	b.n	402d32 <prvProcessReceivedCommands+0x11e>
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
  402d34:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402d36:	699a      	ldr	r2, [r3, #24]
  402d38:	6a3b      	ldr	r3, [r7, #32]
  402d3a:	18d1      	adds	r1, r2, r3
  402d3c:	6a3b      	ldr	r3, [r7, #32]
  402d3e:	6a3a      	ldr	r2, [r7, #32]
  402d40:	6a78      	ldr	r0, [r7, #36]	; 0x24
  402d42:	4c0d      	ldr	r4, [pc, #52]	; (402d78 <prvProcessReceivedCommands+0x164>)
  402d44:	47a0      	blx	r4
					break;
  402d46:	e004      	b.n	402d52 <prvProcessReceivedCommands+0x13e>
					allocated. */
					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
					{
						/* The timer can only have been allocated dynamically -
						free it again. */
						vPortFree( pxTimer );
  402d48:	6a78      	ldr	r0, [r7, #36]	; 0x24
  402d4a:	4b0d      	ldr	r3, [pc, #52]	; (402d80 <prvProcessReceivedCommands+0x16c>)
  402d4c:	4798      	blx	r3
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
					break;
  402d4e:	e000      	b.n	402d52 <prvProcessReceivedCommands+0x13e>

				default	:
					/* Don't expect to get here. */
					break;
  402d50:	bf00      	nop
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
  402d52:	4b0c      	ldr	r3, [pc, #48]	; (402d84 <prvProcessReceivedCommands+0x170>)
  402d54:	6818      	ldr	r0, [r3, #0]
  402d56:	1d39      	adds	r1, r7, #4
  402d58:	2300      	movs	r3, #0
  402d5a:	2200      	movs	r2, #0
  402d5c:	4c0a      	ldr	r4, [pc, #40]	; (402d88 <prvProcessReceivedCommands+0x174>)
  402d5e:	47a0      	blx	r4
  402d60:	4603      	mov	r3, r0
  402d62:	2b00      	cmp	r3, #0
  402d64:	f47f af5a 	bne.w	402c1c <prvProcessReceivedCommands+0x8>
					/* Don't expect to get here. */
					break;
			}
		}
	}
}
  402d68:	bf00      	nop
  402d6a:	3734      	adds	r7, #52	; 0x34
  402d6c:	46bd      	mov	sp, r7
  402d6e:	bd90      	pop	{r4, r7, pc}
  402d70:	004002b5 	.word	0x004002b5
  402d74:	00402b45 	.word	0x00402b45
  402d78:	00402b8d 	.word	0x00402b8d
  402d7c:	004028e5 	.word	0x004028e5
  402d80:	004008bd 	.word	0x004008bd
  402d84:	2040c238 	.word	0x2040c238
  402d88:	00401079 	.word	0x00401079

00402d8c <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
  402d8c:	b590      	push	{r4, r7, lr}
  402d8e:	b089      	sub	sp, #36	; 0x24
  402d90:	af02      	add	r7, sp, #8

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  402d92:	e046      	b.n	402e22 <prvSwitchTimerLists+0x96>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  402d94:	4b2c      	ldr	r3, [pc, #176]	; (402e48 <prvSwitchTimerLists+0xbc>)
  402d96:	681b      	ldr	r3, [r3, #0]
  402d98:	68db      	ldr	r3, [r3, #12]
  402d9a:	681b      	ldr	r3, [r3, #0]
  402d9c:	617b      	str	r3, [r7, #20]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
  402d9e:	4b2a      	ldr	r3, [pc, #168]	; (402e48 <prvSwitchTimerLists+0xbc>)
  402da0:	681b      	ldr	r3, [r3, #0]
  402da2:	68db      	ldr	r3, [r3, #12]
  402da4:	68db      	ldr	r3, [r3, #12]
  402da6:	613b      	str	r3, [r7, #16]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  402da8:	693b      	ldr	r3, [r7, #16]
  402daa:	3304      	adds	r3, #4
  402dac:	4618      	mov	r0, r3
  402dae:	4b27      	ldr	r3, [pc, #156]	; (402e4c <prvSwitchTimerLists+0xc0>)
  402db0:	4798      	blx	r3
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
  402db2:	693b      	ldr	r3, [r7, #16]
  402db4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  402db6:	6938      	ldr	r0, [r7, #16]
  402db8:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
  402dba:	693b      	ldr	r3, [r7, #16]
  402dbc:	69db      	ldr	r3, [r3, #28]
  402dbe:	2b01      	cmp	r3, #1
  402dc0:	d12f      	bne.n	402e22 <prvSwitchTimerLists+0x96>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
  402dc2:	693b      	ldr	r3, [r7, #16]
  402dc4:	699a      	ldr	r2, [r3, #24]
  402dc6:	697b      	ldr	r3, [r7, #20]
  402dc8:	4413      	add	r3, r2
  402dca:	60fb      	str	r3, [r7, #12]
			if( xReloadTime > xNextExpireTime )
  402dcc:	68fa      	ldr	r2, [r7, #12]
  402dce:	697b      	ldr	r3, [r7, #20]
  402dd0:	429a      	cmp	r2, r3
  402dd2:	d90e      	bls.n	402df2 <prvSwitchTimerLists+0x66>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
  402dd4:	693b      	ldr	r3, [r7, #16]
  402dd6:	68fa      	ldr	r2, [r7, #12]
  402dd8:	605a      	str	r2, [r3, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  402dda:	693b      	ldr	r3, [r7, #16]
  402ddc:	693a      	ldr	r2, [r7, #16]
  402dde:	611a      	str	r2, [r3, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  402de0:	4b19      	ldr	r3, [pc, #100]	; (402e48 <prvSwitchTimerLists+0xbc>)
  402de2:	681a      	ldr	r2, [r3, #0]
  402de4:	693b      	ldr	r3, [r7, #16]
  402de6:	3304      	adds	r3, #4
  402de8:	4619      	mov	r1, r3
  402dea:	4610      	mov	r0, r2
  402dec:	4b18      	ldr	r3, [pc, #96]	; (402e50 <prvSwitchTimerLists+0xc4>)
  402dee:	4798      	blx	r3
  402df0:	e017      	b.n	402e22 <prvSwitchTimerLists+0x96>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
  402df2:	2300      	movs	r3, #0
  402df4:	9300      	str	r3, [sp, #0]
  402df6:	2300      	movs	r3, #0
  402df8:	697a      	ldr	r2, [r7, #20]
  402dfa:	2100      	movs	r1, #0
  402dfc:	6938      	ldr	r0, [r7, #16]
  402dfe:	4c15      	ldr	r4, [pc, #84]	; (402e54 <prvSwitchTimerLists+0xc8>)
  402e00:	47a0      	blx	r4
  402e02:	60b8      	str	r0, [r7, #8]
				configASSERT( xResult );
  402e04:	68bb      	ldr	r3, [r7, #8]
  402e06:	2b00      	cmp	r3, #0
  402e08:	d10b      	bne.n	402e22 <prvSwitchTimerLists+0x96>
  402e0a:	f04f 0380 	mov.w	r3, #128	; 0x80
  402e0e:	b672      	cpsid	i
  402e10:	f383 8811 	msr	BASEPRI, r3
  402e14:	f3bf 8f6f 	isb	sy
  402e18:	f3bf 8f4f 	dsb	sy
  402e1c:	b662      	cpsie	i
  402e1e:	603b      	str	r3, [r7, #0]
  402e20:	e7fe      	b.n	402e20 <prvSwitchTimerLists+0x94>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  402e22:	4b09      	ldr	r3, [pc, #36]	; (402e48 <prvSwitchTimerLists+0xbc>)
  402e24:	681b      	ldr	r3, [r3, #0]
  402e26:	681b      	ldr	r3, [r3, #0]
  402e28:	2b00      	cmp	r3, #0
  402e2a:	d1b3      	bne.n	402d94 <prvSwitchTimerLists+0x8>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
  402e2c:	4b06      	ldr	r3, [pc, #24]	; (402e48 <prvSwitchTimerLists+0xbc>)
  402e2e:	681b      	ldr	r3, [r3, #0]
  402e30:	607b      	str	r3, [r7, #4]
	pxCurrentTimerList = pxOverflowTimerList;
  402e32:	4b09      	ldr	r3, [pc, #36]	; (402e58 <prvSwitchTimerLists+0xcc>)
  402e34:	681b      	ldr	r3, [r3, #0]
  402e36:	4a04      	ldr	r2, [pc, #16]	; (402e48 <prvSwitchTimerLists+0xbc>)
  402e38:	6013      	str	r3, [r2, #0]
	pxOverflowTimerList = pxTemp;
  402e3a:	4a07      	ldr	r2, [pc, #28]	; (402e58 <prvSwitchTimerLists+0xcc>)
  402e3c:	687b      	ldr	r3, [r7, #4]
  402e3e:	6013      	str	r3, [r2, #0]
}
  402e40:	bf00      	nop
  402e42:	371c      	adds	r7, #28
  402e44:	46bd      	mov	sp, r7
  402e46:	bd90      	pop	{r4, r7, pc}
  402e48:	2040c230 	.word	0x2040c230
  402e4c:	004002b5 	.word	0x004002b5
  402e50:	00400241 	.word	0x00400241
  402e54:	004028e5 	.word	0x004028e5
  402e58:	2040c234 	.word	0x2040c234

00402e5c <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
  402e5c:	b580      	push	{r7, lr}
  402e5e:	af00      	add	r7, sp, #0
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
  402e60:	4b13      	ldr	r3, [pc, #76]	; (402eb0 <prvCheckForValidListAndQueue+0x54>)
  402e62:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
  402e64:	4b13      	ldr	r3, [pc, #76]	; (402eb4 <prvCheckForValidListAndQueue+0x58>)
  402e66:	681b      	ldr	r3, [r3, #0]
  402e68:	2b00      	cmp	r3, #0
  402e6a:	d11d      	bne.n	402ea8 <prvCheckForValidListAndQueue+0x4c>
		{
			vListInitialise( &xActiveTimerList1 );
  402e6c:	4812      	ldr	r0, [pc, #72]	; (402eb8 <prvCheckForValidListAndQueue+0x5c>)
  402e6e:	4b13      	ldr	r3, [pc, #76]	; (402ebc <prvCheckForValidListAndQueue+0x60>)
  402e70:	4798      	blx	r3
			vListInitialise( &xActiveTimerList2 );
  402e72:	4813      	ldr	r0, [pc, #76]	; (402ec0 <prvCheckForValidListAndQueue+0x64>)
  402e74:	4b11      	ldr	r3, [pc, #68]	; (402ebc <prvCheckForValidListAndQueue+0x60>)
  402e76:	4798      	blx	r3
			pxCurrentTimerList = &xActiveTimerList1;
  402e78:	4b12      	ldr	r3, [pc, #72]	; (402ec4 <prvCheckForValidListAndQueue+0x68>)
  402e7a:	4a0f      	ldr	r2, [pc, #60]	; (402eb8 <prvCheckForValidListAndQueue+0x5c>)
  402e7c:	601a      	str	r2, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
  402e7e:	4b12      	ldr	r3, [pc, #72]	; (402ec8 <prvCheckForValidListAndQueue+0x6c>)
  402e80:	4a0f      	ldr	r2, [pc, #60]	; (402ec0 <prvCheckForValidListAndQueue+0x64>)
  402e82:	601a      	str	r2, [r3, #0]

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
			}
			#else
			{
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
  402e84:	2200      	movs	r2, #0
  402e86:	2110      	movs	r1, #16
  402e88:	2005      	movs	r0, #5
  402e8a:	4b10      	ldr	r3, [pc, #64]	; (402ecc <prvCheckForValidListAndQueue+0x70>)
  402e8c:	4798      	blx	r3
  402e8e:	4602      	mov	r2, r0
  402e90:	4b08      	ldr	r3, [pc, #32]	; (402eb4 <prvCheckForValidListAndQueue+0x58>)
  402e92:	601a      	str	r2, [r3, #0]
			}
			#endif

			#if ( configQUEUE_REGISTRY_SIZE > 0 )
			{
				if( xTimerQueue != NULL )
  402e94:	4b07      	ldr	r3, [pc, #28]	; (402eb4 <prvCheckForValidListAndQueue+0x58>)
  402e96:	681b      	ldr	r3, [r3, #0]
  402e98:	2b00      	cmp	r3, #0
  402e9a:	d005      	beq.n	402ea8 <prvCheckForValidListAndQueue+0x4c>
				{
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
  402e9c:	4b05      	ldr	r3, [pc, #20]	; (402eb4 <prvCheckForValidListAndQueue+0x58>)
  402e9e:	681b      	ldr	r3, [r3, #0]
  402ea0:	490b      	ldr	r1, [pc, #44]	; (402ed0 <prvCheckForValidListAndQueue+0x74>)
  402ea2:	4618      	mov	r0, r3
  402ea4:	4b0b      	ldr	r3, [pc, #44]	; (402ed4 <prvCheckForValidListAndQueue+0x78>)
  402ea6:	4798      	blx	r3
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
  402ea8:	4b0b      	ldr	r3, [pc, #44]	; (402ed8 <prvCheckForValidListAndQueue+0x7c>)
  402eaa:	4798      	blx	r3
}
  402eac:	bf00      	nop
  402eae:	bd80      	pop	{r7, pc}
  402eb0:	004004e9 	.word	0x004004e9
  402eb4:	2040c238 	.word	0x2040c238
  402eb8:	2040c208 	.word	0x2040c208
  402ebc:	0040019d 	.word	0x0040019d
  402ec0:	2040c21c 	.word	0x2040c21c
  402ec4:	2040c230 	.word	0x2040c230
  402ec8:	2040c234 	.word	0x2040c234
  402ecc:	00400bdd 	.word	0x00400bdd
  402ed0:	0040abc8 	.word	0x0040abc8
  402ed4:	004016ad 	.word	0x004016ad
  402ed8:	0040054d 	.word	0x0040054d

00402edc <prvRecordValue_NormallyFull>:
	vQueueAddToRegistry( xNormallyEmptyQueue, "NormallyEmpty" );
}
/*-----------------------------------------------------------*/

static void prvRecordValue_NormallyFull( UBaseType_t uxValue, UBaseType_t uxSource )
{
  402edc:	b580      	push	{r7, lr}
  402ede:	b082      	sub	sp, #8
  402ee0:	af00      	add	r7, sp, #0
  402ee2:	6078      	str	r0, [r7, #4]
  402ee4:	6039      	str	r1, [r7, #0]
	if( uxValue < intqNUM_VALUES_TO_LOG )
  402ee6:	687b      	ldr	r3, [r7, #4]
  402ee8:	2bc7      	cmp	r3, #199	; 0xc7
  402eea:	d810      	bhi.n	402f0e <prvRecordValue_NormallyFull+0x32>
	{
		/* We don't expect to receive the same value twice, so if the value
		has already been marked as received an error has occurred. */
		if( ucNormallyFullReceivedValues[ uxValue ] != 0x00 )
  402eec:	4a0a      	ldr	r2, [pc, #40]	; (402f18 <prvRecordValue_NormallyFull+0x3c>)
  402eee:	687b      	ldr	r3, [r7, #4]
  402ef0:	4413      	add	r3, r2
  402ef2:	781b      	ldrb	r3, [r3, #0]
  402ef4:	2b00      	cmp	r3, #0
  402ef6:	d003      	beq.n	402f00 <prvRecordValue_NormallyFull+0x24>
		{
			prvQueueAccessLogError( __LINE__ );
  402ef8:	f240 1011 	movw	r0, #273	; 0x111
  402efc:	4b07      	ldr	r3, [pc, #28]	; (402f1c <prvRecordValue_NormallyFull+0x40>)
  402efe:	4798      	blx	r3
		}

		/* Log that this value has been received. */
		ucNormallyFullReceivedValues[ uxValue ] = ( uint8_t ) uxSource;
  402f00:	683b      	ldr	r3, [r7, #0]
  402f02:	b2d9      	uxtb	r1, r3
  402f04:	4a04      	ldr	r2, [pc, #16]	; (402f18 <prvRecordValue_NormallyFull+0x3c>)
  402f06:	687b      	ldr	r3, [r7, #4]
  402f08:	4413      	add	r3, r2
  402f0a:	460a      	mov	r2, r1
  402f0c:	701a      	strb	r2, [r3, #0]
	}
}
  402f0e:	bf00      	nop
  402f10:	3708      	adds	r7, #8
  402f12:	46bd      	mov	sp, r7
  402f14:	bd80      	pop	{r7, pc}
  402f16:	bf00      	nop
  402f18:	2040c33c 	.word	0x2040c33c
  402f1c:	00402f65 	.word	0x00402f65

00402f20 <prvRecordValue_NormallyEmpty>:
/*-----------------------------------------------------------*/

static void prvRecordValue_NormallyEmpty( UBaseType_t uxValue, UBaseType_t uxSource )
{
  402f20:	b580      	push	{r7, lr}
  402f22:	b082      	sub	sp, #8
  402f24:	af00      	add	r7, sp, #0
  402f26:	6078      	str	r0, [r7, #4]
  402f28:	6039      	str	r1, [r7, #0]
	if( uxValue < intqNUM_VALUES_TO_LOG )
  402f2a:	687b      	ldr	r3, [r7, #4]
  402f2c:	2bc7      	cmp	r3, #199	; 0xc7
  402f2e:	d810      	bhi.n	402f52 <prvRecordValue_NormallyEmpty+0x32>
	{
		/* We don't expect to receive the same value twice, so if the value
		has already been marked as received an error has occurred. */
		if( ucNormallyEmptyReceivedValues[ uxValue ] != 0x00 )
  402f30:	4a0a      	ldr	r2, [pc, #40]	; (402f5c <prvRecordValue_NormallyEmpty+0x3c>)
  402f32:	687b      	ldr	r3, [r7, #4]
  402f34:	4413      	add	r3, r2
  402f36:	781b      	ldrb	r3, [r3, #0]
  402f38:	2b00      	cmp	r3, #0
  402f3a:	d003      	beq.n	402f44 <prvRecordValue_NormallyEmpty+0x24>
		{
			prvQueueAccessLogError( __LINE__ );
  402f3c:	f44f 7091 	mov.w	r0, #290	; 0x122
  402f40:	4b07      	ldr	r3, [pc, #28]	; (402f60 <prvRecordValue_NormallyEmpty+0x40>)
  402f42:	4798      	blx	r3
		}

		/* Log that this value has been received. */
		ucNormallyEmptyReceivedValues[ uxValue ] = ( uint8_t ) uxSource;
  402f44:	683b      	ldr	r3, [r7, #0]
  402f46:	b2d9      	uxtb	r1, r3
  402f48:	4a04      	ldr	r2, [pc, #16]	; (402f5c <prvRecordValue_NormallyEmpty+0x3c>)
  402f4a:	687b      	ldr	r3, [r7, #4]
  402f4c:	4413      	add	r3, r2
  402f4e:	460a      	mov	r2, r1
  402f50:	701a      	strb	r2, [r3, #0]
	}
}
  402f52:	bf00      	nop
  402f54:	3708      	adds	r7, #8
  402f56:	46bd      	mov	sp, r7
  402f58:	bd80      	pop	{r7, pc}
  402f5a:	bf00      	nop
  402f5c:	2040c274 	.word	0x2040c274
  402f60:	00402f65 	.word	0x00402f65

00402f64 <prvQueueAccessLogError>:
/*-----------------------------------------------------------*/

static void prvQueueAccessLogError( UBaseType_t uxLine )
{
  402f64:	b480      	push	{r7}
  402f66:	b083      	sub	sp, #12
  402f68:	af00      	add	r7, sp, #0
  402f6a:	6078      	str	r0, [r7, #4]
	/* Latch the line number that caused the error. */
	xErrorLine = uxLine;
  402f6c:	4a05      	ldr	r2, [pc, #20]	; (402f84 <prvQueueAccessLogError+0x20>)
  402f6e:	687b      	ldr	r3, [r7, #4]
  402f70:	6013      	str	r3, [r2, #0]
	xErrorStatus = pdFAIL;
  402f72:	4b05      	ldr	r3, [pc, #20]	; (402f88 <prvQueueAccessLogError+0x24>)
  402f74:	2200      	movs	r2, #0
  402f76:	601a      	str	r2, [r3, #0]
}
  402f78:	bf00      	nop
  402f7a:	370c      	adds	r7, #12
  402f7c:	46bd      	mov	sp, r7
  402f7e:	f85d 7b04 	ldr.w	r7, [sp], #4
  402f82:	4770      	bx	lr
  402f84:	2040c264 	.word	0x2040c264
  402f88:	20400004 	.word	0x20400004

00402f8c <xFirstTimerHandler>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xFirstTimerHandler( void )
{
  402f8c:	b590      	push	{r4, r7, lr}
  402f8e:	b08f      	sub	sp, #60	; 0x3c
  402f90:	af00      	add	r7, sp, #0
BaseType_t xHigherPriorityTaskWoken = pdFALSE;
  402f92:	2300      	movs	r3, #0
  402f94:	607b      	str	r3, [r7, #4]
static UBaseType_t uxNextOperation = 0;

	/* Called from a timer interrupt.  Perform various read and write
	accesses on the queues. */

	uxNextOperation++;
  402f96:	4b69      	ldr	r3, [pc, #420]	; (40313c <xFirstTimerHandler+0x1b0>)
  402f98:	681b      	ldr	r3, [r3, #0]
  402f9a:	3301      	adds	r3, #1
  402f9c:	4a67      	ldr	r2, [pc, #412]	; (40313c <xFirstTimerHandler+0x1b0>)
  402f9e:	6013      	str	r3, [r2, #0]

	if( uxNextOperation & ( UBaseType_t ) 0x01 )
  402fa0:	4b66      	ldr	r3, [pc, #408]	; (40313c <xFirstTimerHandler+0x1b0>)
  402fa2:	681b      	ldr	r3, [r3, #0]
  402fa4:	f003 0301 	and.w	r3, r3, #1
  402fa8:	2b00      	cmp	r3, #0
  402faa:	f000 8094 	beq.w	4030d6 <xFirstTimerHandler+0x14a>
	{
		timerNORMALLY_EMPTY_TX();
  402fae:	4b64      	ldr	r3, [pc, #400]	; (403140 <xFirstTimerHandler+0x1b4>)
  402fb0:	681b      	ldr	r3, [r3, #0]
  402fb2:	4618      	mov	r0, r3
  402fb4:	4b63      	ldr	r3, [pc, #396]	; (403144 <xFirstTimerHandler+0x1b8>)
  402fb6:	4798      	blx	r3
  402fb8:	4603      	mov	r3, r0
  402fba:	2b01      	cmp	r3, #1
  402fbc:	d028      	beq.n	403010 <xFirstTimerHandler+0x84>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
  402fbe:	f3ef 8211 	mrs	r2, BASEPRI
  402fc2:	f04f 0380 	mov.w	r3, #128	; 0x80
  402fc6:	b672      	cpsid	i
  402fc8:	f383 8811 	msr	BASEPRI, r3
  402fcc:	f3bf 8f6f 	isb	sy
  402fd0:	f3bf 8f4f 	dsb	sy
  402fd4:	b662      	cpsie	i
  402fd6:	617a      	str	r2, [r7, #20]
  402fd8:	613b      	str	r3, [r7, #16]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
  402fda:	697b      	ldr	r3, [r7, #20]
  402fdc:	633b      	str	r3, [r7, #48]	; 0x30
  402fde:	4b5a      	ldr	r3, [pc, #360]	; (403148 <xFirstTimerHandler+0x1bc>)
  402fe0:	681b      	ldr	r3, [r3, #0]
  402fe2:	3301      	adds	r3, #1
  402fe4:	4a58      	ldr	r2, [pc, #352]	; (403148 <xFirstTimerHandler+0x1bc>)
  402fe6:	6013      	str	r3, [r2, #0]
  402fe8:	4b55      	ldr	r3, [pc, #340]	; (403140 <xFirstTimerHandler+0x1b4>)
  402fea:	6818      	ldr	r0, [r3, #0]
  402fec:	1d3a      	adds	r2, r7, #4
  402fee:	2300      	movs	r3, #0
  402ff0:	4955      	ldr	r1, [pc, #340]	; (403148 <xFirstTimerHandler+0x1bc>)
  402ff2:	4c56      	ldr	r4, [pc, #344]	; (40314c <xFirstTimerHandler+0x1c0>)
  402ff4:	47a0      	blx	r4
  402ff6:	4603      	mov	r3, r0
  402ff8:	2b01      	cmp	r3, #1
  402ffa:	d004      	beq.n	403006 <xFirstTimerHandler+0x7a>
  402ffc:	4b52      	ldr	r3, [pc, #328]	; (403148 <xFirstTimerHandler+0x1bc>)
  402ffe:	681b      	ldr	r3, [r3, #0]
  403000:	3b01      	subs	r3, #1
  403002:	4a51      	ldr	r2, [pc, #324]	; (403148 <xFirstTimerHandler+0x1bc>)
  403004:	6013      	str	r3, [r2, #0]
  403006:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  403008:	637b      	str	r3, [r7, #52]	; 0x34
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
  40300a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40300c:	f383 8811 	msr	BASEPRI, r3
		timerNORMALLY_EMPTY_TX();
  403010:	4b4b      	ldr	r3, [pc, #300]	; (403140 <xFirstTimerHandler+0x1b4>)
  403012:	681b      	ldr	r3, [r3, #0]
  403014:	4618      	mov	r0, r3
  403016:	4b4b      	ldr	r3, [pc, #300]	; (403144 <xFirstTimerHandler+0x1b8>)
  403018:	4798      	blx	r3
  40301a:	4603      	mov	r3, r0
  40301c:	2b01      	cmp	r3, #1
  40301e:	d028      	beq.n	403072 <xFirstTimerHandler+0xe6>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
  403020:	f3ef 8211 	mrs	r2, BASEPRI
  403024:	f04f 0380 	mov.w	r3, #128	; 0x80
  403028:	b672      	cpsid	i
  40302a:	f383 8811 	msr	BASEPRI, r3
  40302e:	f3bf 8f6f 	isb	sy
  403032:	f3bf 8f4f 	dsb	sy
  403036:	b662      	cpsie	i
  403038:	62fa      	str	r2, [r7, #44]	; 0x2c
  40303a:	60fb      	str	r3, [r7, #12]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
  40303c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40303e:	627b      	str	r3, [r7, #36]	; 0x24
  403040:	4b41      	ldr	r3, [pc, #260]	; (403148 <xFirstTimerHandler+0x1bc>)
  403042:	681b      	ldr	r3, [r3, #0]
  403044:	3301      	adds	r3, #1
  403046:	4a40      	ldr	r2, [pc, #256]	; (403148 <xFirstTimerHandler+0x1bc>)
  403048:	6013      	str	r3, [r2, #0]
  40304a:	4b3d      	ldr	r3, [pc, #244]	; (403140 <xFirstTimerHandler+0x1b4>)
  40304c:	6818      	ldr	r0, [r3, #0]
  40304e:	1d3a      	adds	r2, r7, #4
  403050:	2300      	movs	r3, #0
  403052:	493d      	ldr	r1, [pc, #244]	; (403148 <xFirstTimerHandler+0x1bc>)
  403054:	4c3d      	ldr	r4, [pc, #244]	; (40314c <xFirstTimerHandler+0x1c0>)
  403056:	47a0      	blx	r4
  403058:	4603      	mov	r3, r0
  40305a:	2b01      	cmp	r3, #1
  40305c:	d004      	beq.n	403068 <xFirstTimerHandler+0xdc>
  40305e:	4b3a      	ldr	r3, [pc, #232]	; (403148 <xFirstTimerHandler+0x1bc>)
  403060:	681b      	ldr	r3, [r3, #0]
  403062:	3b01      	subs	r3, #1
  403064:	4a38      	ldr	r2, [pc, #224]	; (403148 <xFirstTimerHandler+0x1bc>)
  403066:	6013      	str	r3, [r2, #0]
  403068:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40306a:	62bb      	str	r3, [r7, #40]	; 0x28
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
  40306c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40306e:	f383 8811 	msr	BASEPRI, r3
		timerNORMALLY_EMPTY_TX();
  403072:	4b33      	ldr	r3, [pc, #204]	; (403140 <xFirstTimerHandler+0x1b4>)
  403074:	681b      	ldr	r3, [r3, #0]
  403076:	4618      	mov	r0, r3
  403078:	4b32      	ldr	r3, [pc, #200]	; (403144 <xFirstTimerHandler+0x1b8>)
  40307a:	4798      	blx	r3
  40307c:	4603      	mov	r3, r0
  40307e:	2b01      	cmp	r3, #1
  403080:	d056      	beq.n	403130 <xFirstTimerHandler+0x1a4>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
  403082:	f3ef 8211 	mrs	r2, BASEPRI
  403086:	f04f 0380 	mov.w	r3, #128	; 0x80
  40308a:	b672      	cpsid	i
  40308c:	f383 8811 	msr	BASEPRI, r3
  403090:	f3bf 8f6f 	isb	sy
  403094:	f3bf 8f4f 	dsb	sy
  403098:	b662      	cpsie	i
  40309a:	623a      	str	r2, [r7, #32]
  40309c:	60bb      	str	r3, [r7, #8]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
  40309e:	6a3b      	ldr	r3, [r7, #32]
  4030a0:	61bb      	str	r3, [r7, #24]
  4030a2:	4b29      	ldr	r3, [pc, #164]	; (403148 <xFirstTimerHandler+0x1bc>)
  4030a4:	681b      	ldr	r3, [r3, #0]
  4030a6:	3301      	adds	r3, #1
  4030a8:	4a27      	ldr	r2, [pc, #156]	; (403148 <xFirstTimerHandler+0x1bc>)
  4030aa:	6013      	str	r3, [r2, #0]
  4030ac:	4b24      	ldr	r3, [pc, #144]	; (403140 <xFirstTimerHandler+0x1b4>)
  4030ae:	6818      	ldr	r0, [r3, #0]
  4030b0:	1d3a      	adds	r2, r7, #4
  4030b2:	2300      	movs	r3, #0
  4030b4:	4924      	ldr	r1, [pc, #144]	; (403148 <xFirstTimerHandler+0x1bc>)
  4030b6:	4c25      	ldr	r4, [pc, #148]	; (40314c <xFirstTimerHandler+0x1c0>)
  4030b8:	47a0      	blx	r4
  4030ba:	4603      	mov	r3, r0
  4030bc:	2b01      	cmp	r3, #1
  4030be:	d004      	beq.n	4030ca <xFirstTimerHandler+0x13e>
  4030c0:	4b21      	ldr	r3, [pc, #132]	; (403148 <xFirstTimerHandler+0x1bc>)
  4030c2:	681b      	ldr	r3, [r3, #0]
  4030c4:	3b01      	subs	r3, #1
  4030c6:	4a20      	ldr	r2, [pc, #128]	; (403148 <xFirstTimerHandler+0x1bc>)
  4030c8:	6013      	str	r3, [r2, #0]
  4030ca:	69bb      	ldr	r3, [r7, #24]
  4030cc:	61fb      	str	r3, [r7, #28]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
  4030ce:	69fb      	ldr	r3, [r7, #28]
  4030d0:	f383 8811 	msr	BASEPRI, r3
  4030d4:	e02c      	b.n	403130 <xFirstTimerHandler+0x1a4>
	}
	else
	{
		timerNORMALLY_FULL_RX();
  4030d6:	4b1e      	ldr	r3, [pc, #120]	; (403150 <xFirstTimerHandler+0x1c4>)
  4030d8:	681b      	ldr	r3, [r3, #0]
  4030da:	1d3a      	adds	r2, r7, #4
  4030dc:	4639      	mov	r1, r7
  4030de:	4618      	mov	r0, r3
  4030e0:	4b1c      	ldr	r3, [pc, #112]	; (403154 <xFirstTimerHandler+0x1c8>)
  4030e2:	4798      	blx	r3
  4030e4:	4603      	mov	r3, r0
  4030e6:	2b01      	cmp	r3, #1
  4030e8:	d104      	bne.n	4030f4 <xFirstTimerHandler+0x168>
  4030ea:	683b      	ldr	r3, [r7, #0]
  4030ec:	2105      	movs	r1, #5
  4030ee:	4618      	mov	r0, r3
  4030f0:	4b19      	ldr	r3, [pc, #100]	; (403158 <xFirstTimerHandler+0x1cc>)
  4030f2:	4798      	blx	r3
		timerNORMALLY_FULL_RX();
  4030f4:	4b16      	ldr	r3, [pc, #88]	; (403150 <xFirstTimerHandler+0x1c4>)
  4030f6:	681b      	ldr	r3, [r3, #0]
  4030f8:	1d3a      	adds	r2, r7, #4
  4030fa:	4639      	mov	r1, r7
  4030fc:	4618      	mov	r0, r3
  4030fe:	4b15      	ldr	r3, [pc, #84]	; (403154 <xFirstTimerHandler+0x1c8>)
  403100:	4798      	blx	r3
  403102:	4603      	mov	r3, r0
  403104:	2b01      	cmp	r3, #1
  403106:	d104      	bne.n	403112 <xFirstTimerHandler+0x186>
  403108:	683b      	ldr	r3, [r7, #0]
  40310a:	2105      	movs	r1, #5
  40310c:	4618      	mov	r0, r3
  40310e:	4b12      	ldr	r3, [pc, #72]	; (403158 <xFirstTimerHandler+0x1cc>)
  403110:	4798      	blx	r3
		timerNORMALLY_FULL_RX();
  403112:	4b0f      	ldr	r3, [pc, #60]	; (403150 <xFirstTimerHandler+0x1c4>)
  403114:	681b      	ldr	r3, [r3, #0]
  403116:	1d3a      	adds	r2, r7, #4
  403118:	4639      	mov	r1, r7
  40311a:	4618      	mov	r0, r3
  40311c:	4b0d      	ldr	r3, [pc, #52]	; (403154 <xFirstTimerHandler+0x1c8>)
  40311e:	4798      	blx	r3
  403120:	4603      	mov	r3, r0
  403122:	2b01      	cmp	r3, #1
  403124:	d104      	bne.n	403130 <xFirstTimerHandler+0x1a4>
  403126:	683b      	ldr	r3, [r7, #0]
  403128:	2105      	movs	r1, #5
  40312a:	4618      	mov	r0, r3
  40312c:	4b0a      	ldr	r3, [pc, #40]	; (403158 <xFirstTimerHandler+0x1cc>)
  40312e:	4798      	blx	r3
	}

	return xHigherPriorityTaskWoken;
  403130:	687b      	ldr	r3, [r7, #4]
}
  403132:	4618      	mov	r0, r3
  403134:	373c      	adds	r7, #60	; 0x3c
  403136:	46bd      	mov	sp, r7
  403138:	bd90      	pop	{r4, r7, pc}
  40313a:	bf00      	nop
  40313c:	2040c404 	.word	0x2040c404
  403140:	2040c24c 	.word	0x2040c24c
  403144:	00401661 	.word	0x00401661
  403148:	2040c26c 	.word	0x2040c26c
  40314c:	00400f0d 	.word	0x00400f0d
  403150:	2040c250 	.word	0x2040c250
  403154:	004012e1 	.word	0x004012e1
  403158:	00402edd 	.word	0x00402edd

0040315c <xSecondTimerHandler>:
/*-----------------------------------------------------------*/

BaseType_t xSecondTimerHandler( void )
{
  40315c:	b590      	push	{r4, r7, lr}
  40315e:	b097      	sub	sp, #92	; 0x5c
  403160:	af00      	add	r7, sp, #0
UBaseType_t uxRxedValue;
BaseType_t xHigherPriorityTaskWoken = pdFALSE;
  403162:	2300      	movs	r3, #0
  403164:	603b      	str	r3, [r7, #0]
static UBaseType_t uxNextOperation = 0;

	/* Called from a timer interrupt.  Perform various read and write
	accesses on the queues. */

	uxNextOperation++;
  403166:	4b9f      	ldr	r3, [pc, #636]	; (4033e4 <xSecondTimerHandler+0x288>)
  403168:	681b      	ldr	r3, [r3, #0]
  40316a:	3301      	adds	r3, #1
  40316c:	4a9d      	ldr	r2, [pc, #628]	; (4033e4 <xSecondTimerHandler+0x288>)
  40316e:	6013      	str	r3, [r2, #0]

	if( uxNextOperation & ( UBaseType_t ) 0x01 )
  403170:	4b9c      	ldr	r3, [pc, #624]	; (4033e4 <xSecondTimerHandler+0x288>)
  403172:	681b      	ldr	r3, [r3, #0]
  403174:	f003 0301 	and.w	r3, r3, #1
  403178:	2b00      	cmp	r3, #0
  40317a:	f000 808b 	beq.w	403294 <xSecondTimerHandler+0x138>
	{
		timerNORMALLY_EMPTY_TX();
  40317e:	4b9a      	ldr	r3, [pc, #616]	; (4033e8 <xSecondTimerHandler+0x28c>)
  403180:	681b      	ldr	r3, [r3, #0]
  403182:	4618      	mov	r0, r3
  403184:	4b99      	ldr	r3, [pc, #612]	; (4033ec <xSecondTimerHandler+0x290>)
  403186:	4798      	blx	r3
  403188:	4603      	mov	r3, r0
  40318a:	2b01      	cmp	r3, #1
  40318c:	d028      	beq.n	4031e0 <xSecondTimerHandler+0x84>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
  40318e:	f3ef 8211 	mrs	r2, BASEPRI
  403192:	f04f 0380 	mov.w	r3, #128	; 0x80
  403196:	b672      	cpsid	i
  403198:	f383 8811 	msr	BASEPRI, r3
  40319c:	f3bf 8f6f 	isb	sy
  4031a0:	f3bf 8f4f 	dsb	sy
  4031a4:	b662      	cpsie	i
  4031a6:	61fa      	str	r2, [r7, #28]
  4031a8:	61bb      	str	r3, [r7, #24]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
  4031aa:	69fb      	ldr	r3, [r7, #28]
  4031ac:	653b      	str	r3, [r7, #80]	; 0x50
  4031ae:	4b90      	ldr	r3, [pc, #576]	; (4033f0 <xSecondTimerHandler+0x294>)
  4031b0:	681b      	ldr	r3, [r3, #0]
  4031b2:	3301      	adds	r3, #1
  4031b4:	4a8e      	ldr	r2, [pc, #568]	; (4033f0 <xSecondTimerHandler+0x294>)
  4031b6:	6013      	str	r3, [r2, #0]
  4031b8:	4b8b      	ldr	r3, [pc, #556]	; (4033e8 <xSecondTimerHandler+0x28c>)
  4031ba:	6818      	ldr	r0, [r3, #0]
  4031bc:	463a      	mov	r2, r7
  4031be:	2300      	movs	r3, #0
  4031c0:	498b      	ldr	r1, [pc, #556]	; (4033f0 <xSecondTimerHandler+0x294>)
  4031c2:	4c8c      	ldr	r4, [pc, #560]	; (4033f4 <xSecondTimerHandler+0x298>)
  4031c4:	47a0      	blx	r4
  4031c6:	4603      	mov	r3, r0
  4031c8:	2b01      	cmp	r3, #1
  4031ca:	d004      	beq.n	4031d6 <xSecondTimerHandler+0x7a>
  4031cc:	4b88      	ldr	r3, [pc, #544]	; (4033f0 <xSecondTimerHandler+0x294>)
  4031ce:	681b      	ldr	r3, [r3, #0]
  4031d0:	3b01      	subs	r3, #1
  4031d2:	4a87      	ldr	r2, [pc, #540]	; (4033f0 <xSecondTimerHandler+0x294>)
  4031d4:	6013      	str	r3, [r2, #0]
  4031d6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  4031d8:	657b      	str	r3, [r7, #84]	; 0x54
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
  4031da:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  4031dc:	f383 8811 	msr	BASEPRI, r3
		timerNORMALLY_EMPTY_TX();
  4031e0:	4b81      	ldr	r3, [pc, #516]	; (4033e8 <xSecondTimerHandler+0x28c>)
  4031e2:	681b      	ldr	r3, [r3, #0]
  4031e4:	4618      	mov	r0, r3
  4031e6:	4b81      	ldr	r3, [pc, #516]	; (4033ec <xSecondTimerHandler+0x290>)
  4031e8:	4798      	blx	r3
  4031ea:	4603      	mov	r3, r0
  4031ec:	2b01      	cmp	r3, #1
  4031ee:	d028      	beq.n	403242 <xSecondTimerHandler+0xe6>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
  4031f0:	f3ef 8211 	mrs	r2, BASEPRI
  4031f4:	f04f 0380 	mov.w	r3, #128	; 0x80
  4031f8:	b672      	cpsid	i
  4031fa:	f383 8811 	msr	BASEPRI, r3
  4031fe:	f3bf 8f6f 	isb	sy
  403202:	f3bf 8f4f 	dsb	sy
  403206:	b662      	cpsie	i
  403208:	64fa      	str	r2, [r7, #76]	; 0x4c
  40320a:	617b      	str	r3, [r7, #20]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
  40320c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  40320e:	647b      	str	r3, [r7, #68]	; 0x44
  403210:	4b77      	ldr	r3, [pc, #476]	; (4033f0 <xSecondTimerHandler+0x294>)
  403212:	681b      	ldr	r3, [r3, #0]
  403214:	3301      	adds	r3, #1
  403216:	4a76      	ldr	r2, [pc, #472]	; (4033f0 <xSecondTimerHandler+0x294>)
  403218:	6013      	str	r3, [r2, #0]
  40321a:	4b73      	ldr	r3, [pc, #460]	; (4033e8 <xSecondTimerHandler+0x28c>)
  40321c:	6818      	ldr	r0, [r3, #0]
  40321e:	463a      	mov	r2, r7
  403220:	2300      	movs	r3, #0
  403222:	4973      	ldr	r1, [pc, #460]	; (4033f0 <xSecondTimerHandler+0x294>)
  403224:	4c73      	ldr	r4, [pc, #460]	; (4033f4 <xSecondTimerHandler+0x298>)
  403226:	47a0      	blx	r4
  403228:	4603      	mov	r3, r0
  40322a:	2b01      	cmp	r3, #1
  40322c:	d004      	beq.n	403238 <xSecondTimerHandler+0xdc>
  40322e:	4b70      	ldr	r3, [pc, #448]	; (4033f0 <xSecondTimerHandler+0x294>)
  403230:	681b      	ldr	r3, [r3, #0]
  403232:	3b01      	subs	r3, #1
  403234:	4a6e      	ldr	r2, [pc, #440]	; (4033f0 <xSecondTimerHandler+0x294>)
  403236:	6013      	str	r3, [r2, #0]
  403238:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40323a:	64bb      	str	r3, [r7, #72]	; 0x48
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
  40323c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  40323e:	f383 8811 	msr	BASEPRI, r3

		timerNORMALLY_EMPTY_RX();
  403242:	4b69      	ldr	r3, [pc, #420]	; (4033e8 <xSecondTimerHandler+0x28c>)
  403244:	681b      	ldr	r3, [r3, #0]
  403246:	463a      	mov	r2, r7
  403248:	1d39      	adds	r1, r7, #4
  40324a:	4618      	mov	r0, r3
  40324c:	4b6a      	ldr	r3, [pc, #424]	; (4033f8 <xSecondTimerHandler+0x29c>)
  40324e:	4798      	blx	r3
  403250:	4603      	mov	r3, r0
  403252:	2b01      	cmp	r3, #1
  403254:	d004      	beq.n	403260 <xSecondTimerHandler+0x104>
  403256:	f44f 7032 	mov.w	r0, #712	; 0x2c8
  40325a:	4b68      	ldr	r3, [pc, #416]	; (4033fc <xSecondTimerHandler+0x2a0>)
  40325c:	4798      	blx	r3
  40325e:	e004      	b.n	40326a <xSecondTimerHandler+0x10e>
  403260:	687b      	ldr	r3, [r7, #4]
  403262:	2105      	movs	r1, #5
  403264:	4618      	mov	r0, r3
  403266:	4b66      	ldr	r3, [pc, #408]	; (403400 <xSecondTimerHandler+0x2a4>)
  403268:	4798      	blx	r3
		timerNORMALLY_EMPTY_RX();
  40326a:	4b5f      	ldr	r3, [pc, #380]	; (4033e8 <xSecondTimerHandler+0x28c>)
  40326c:	681b      	ldr	r3, [r3, #0]
  40326e:	463a      	mov	r2, r7
  403270:	1d39      	adds	r1, r7, #4
  403272:	4618      	mov	r0, r3
  403274:	4b60      	ldr	r3, [pc, #384]	; (4033f8 <xSecondTimerHandler+0x29c>)
  403276:	4798      	blx	r3
  403278:	4603      	mov	r3, r0
  40327a:	2b01      	cmp	r3, #1
  40327c:	d004      	beq.n	403288 <xSecondTimerHandler+0x12c>
  40327e:	f240 20c9 	movw	r0, #713	; 0x2c9
  403282:	4b5e      	ldr	r3, [pc, #376]	; (4033fc <xSecondTimerHandler+0x2a0>)
  403284:	4798      	blx	r3
  403286:	e0a7      	b.n	4033d8 <xSecondTimerHandler+0x27c>
  403288:	687b      	ldr	r3, [r7, #4]
  40328a:	2105      	movs	r1, #5
  40328c:	4618      	mov	r0, r3
  40328e:	4b5c      	ldr	r3, [pc, #368]	; (403400 <xSecondTimerHandler+0x2a4>)
  403290:	4798      	blx	r3
  403292:	e0a1      	b.n	4033d8 <xSecondTimerHandler+0x27c>
	}
	else
	{
		timerNORMALLY_FULL_RX();
  403294:	4b5b      	ldr	r3, [pc, #364]	; (403404 <xSecondTimerHandler+0x2a8>)
  403296:	681b      	ldr	r3, [r3, #0]
  403298:	463a      	mov	r2, r7
  40329a:	1d39      	adds	r1, r7, #4
  40329c:	4618      	mov	r0, r3
  40329e:	4b56      	ldr	r3, [pc, #344]	; (4033f8 <xSecondTimerHandler+0x29c>)
  4032a0:	4798      	blx	r3
  4032a2:	4603      	mov	r3, r0
  4032a4:	2b01      	cmp	r3, #1
  4032a6:	d104      	bne.n	4032b2 <xSecondTimerHandler+0x156>
  4032a8:	687b      	ldr	r3, [r7, #4]
  4032aa:	2105      	movs	r1, #5
  4032ac:	4618      	mov	r0, r3
  4032ae:	4b56      	ldr	r3, [pc, #344]	; (403408 <xSecondTimerHandler+0x2ac>)
  4032b0:	4798      	blx	r3
		timerNORMALLY_FULL_TX();
  4032b2:	4b54      	ldr	r3, [pc, #336]	; (403404 <xSecondTimerHandler+0x2a8>)
  4032b4:	681b      	ldr	r3, [r3, #0]
  4032b6:	4618      	mov	r0, r3
  4032b8:	4b4c      	ldr	r3, [pc, #304]	; (4033ec <xSecondTimerHandler+0x290>)
  4032ba:	4798      	blx	r3
  4032bc:	4603      	mov	r3, r0
  4032be:	2b01      	cmp	r3, #1
  4032c0:	d028      	beq.n	403314 <xSecondTimerHandler+0x1b8>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
  4032c2:	f3ef 8211 	mrs	r2, BASEPRI
  4032c6:	f04f 0380 	mov.w	r3, #128	; 0x80
  4032ca:	b672      	cpsid	i
  4032cc:	f383 8811 	msr	BASEPRI, r3
  4032d0:	f3bf 8f6f 	isb	sy
  4032d4:	f3bf 8f4f 	dsb	sy
  4032d8:	b662      	cpsie	i
  4032da:	643a      	str	r2, [r7, #64]	; 0x40
  4032dc:	613b      	str	r3, [r7, #16]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
  4032de:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  4032e0:	63bb      	str	r3, [r7, #56]	; 0x38
  4032e2:	4b4a      	ldr	r3, [pc, #296]	; (40340c <xSecondTimerHandler+0x2b0>)
  4032e4:	681b      	ldr	r3, [r3, #0]
  4032e6:	3301      	adds	r3, #1
  4032e8:	4a48      	ldr	r2, [pc, #288]	; (40340c <xSecondTimerHandler+0x2b0>)
  4032ea:	6013      	str	r3, [r2, #0]
  4032ec:	4b45      	ldr	r3, [pc, #276]	; (403404 <xSecondTimerHandler+0x2a8>)
  4032ee:	6818      	ldr	r0, [r3, #0]
  4032f0:	463a      	mov	r2, r7
  4032f2:	2300      	movs	r3, #0
  4032f4:	4945      	ldr	r1, [pc, #276]	; (40340c <xSecondTimerHandler+0x2b0>)
  4032f6:	4c3f      	ldr	r4, [pc, #252]	; (4033f4 <xSecondTimerHandler+0x298>)
  4032f8:	47a0      	blx	r4
  4032fa:	4603      	mov	r3, r0
  4032fc:	2b01      	cmp	r3, #1
  4032fe:	d004      	beq.n	40330a <xSecondTimerHandler+0x1ae>
  403300:	4b42      	ldr	r3, [pc, #264]	; (40340c <xSecondTimerHandler+0x2b0>)
  403302:	681b      	ldr	r3, [r3, #0]
  403304:	3b01      	subs	r3, #1
  403306:	4a41      	ldr	r2, [pc, #260]	; (40340c <xSecondTimerHandler+0x2b0>)
  403308:	6013      	str	r3, [r2, #0]
  40330a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  40330c:	63fb      	str	r3, [r7, #60]	; 0x3c
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
  40330e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  403310:	f383 8811 	msr	BASEPRI, r3
		timerNORMALLY_FULL_TX();
  403314:	4b3b      	ldr	r3, [pc, #236]	; (403404 <xSecondTimerHandler+0x2a8>)
  403316:	681b      	ldr	r3, [r3, #0]
  403318:	4618      	mov	r0, r3
  40331a:	4b34      	ldr	r3, [pc, #208]	; (4033ec <xSecondTimerHandler+0x290>)
  40331c:	4798      	blx	r3
  40331e:	4603      	mov	r3, r0
  403320:	2b01      	cmp	r3, #1
  403322:	d028      	beq.n	403376 <xSecondTimerHandler+0x21a>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
  403324:	f3ef 8211 	mrs	r2, BASEPRI
  403328:	f04f 0380 	mov.w	r3, #128	; 0x80
  40332c:	b672      	cpsid	i
  40332e:	f383 8811 	msr	BASEPRI, r3
  403332:	f3bf 8f6f 	isb	sy
  403336:	f3bf 8f4f 	dsb	sy
  40333a:	b662      	cpsie	i
  40333c:	637a      	str	r2, [r7, #52]	; 0x34
  40333e:	60fb      	str	r3, [r7, #12]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
  403340:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  403342:	62fb      	str	r3, [r7, #44]	; 0x2c
  403344:	4b31      	ldr	r3, [pc, #196]	; (40340c <xSecondTimerHandler+0x2b0>)
  403346:	681b      	ldr	r3, [r3, #0]
  403348:	3301      	adds	r3, #1
  40334a:	4a30      	ldr	r2, [pc, #192]	; (40340c <xSecondTimerHandler+0x2b0>)
  40334c:	6013      	str	r3, [r2, #0]
  40334e:	4b2d      	ldr	r3, [pc, #180]	; (403404 <xSecondTimerHandler+0x2a8>)
  403350:	6818      	ldr	r0, [r3, #0]
  403352:	463a      	mov	r2, r7
  403354:	2300      	movs	r3, #0
  403356:	492d      	ldr	r1, [pc, #180]	; (40340c <xSecondTimerHandler+0x2b0>)
  403358:	4c26      	ldr	r4, [pc, #152]	; (4033f4 <xSecondTimerHandler+0x298>)
  40335a:	47a0      	blx	r4
  40335c:	4603      	mov	r3, r0
  40335e:	2b01      	cmp	r3, #1
  403360:	d004      	beq.n	40336c <xSecondTimerHandler+0x210>
  403362:	4b2a      	ldr	r3, [pc, #168]	; (40340c <xSecondTimerHandler+0x2b0>)
  403364:	681b      	ldr	r3, [r3, #0]
  403366:	3b01      	subs	r3, #1
  403368:	4a28      	ldr	r2, [pc, #160]	; (40340c <xSecondTimerHandler+0x2b0>)
  40336a:	6013      	str	r3, [r2, #0]
  40336c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40336e:	633b      	str	r3, [r7, #48]	; 0x30
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
  403370:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  403372:	f383 8811 	msr	BASEPRI, r3
		timerNORMALLY_FULL_TX();
  403376:	4b23      	ldr	r3, [pc, #140]	; (403404 <xSecondTimerHandler+0x2a8>)
  403378:	681b      	ldr	r3, [r3, #0]
  40337a:	4618      	mov	r0, r3
  40337c:	4b1b      	ldr	r3, [pc, #108]	; (4033ec <xSecondTimerHandler+0x290>)
  40337e:	4798      	blx	r3
  403380:	4603      	mov	r3, r0
  403382:	2b01      	cmp	r3, #1
  403384:	d028      	beq.n	4033d8 <xSecondTimerHandler+0x27c>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
  403386:	f3ef 8211 	mrs	r2, BASEPRI
  40338a:	f04f 0380 	mov.w	r3, #128	; 0x80
  40338e:	b672      	cpsid	i
  403390:	f383 8811 	msr	BASEPRI, r3
  403394:	f3bf 8f6f 	isb	sy
  403398:	f3bf 8f4f 	dsb	sy
  40339c:	b662      	cpsie	i
  40339e:	62ba      	str	r2, [r7, #40]	; 0x28
  4033a0:	60bb      	str	r3, [r7, #8]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
  4033a2:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4033a4:	623b      	str	r3, [r7, #32]
  4033a6:	4b19      	ldr	r3, [pc, #100]	; (40340c <xSecondTimerHandler+0x2b0>)
  4033a8:	681b      	ldr	r3, [r3, #0]
  4033aa:	3301      	adds	r3, #1
  4033ac:	4a17      	ldr	r2, [pc, #92]	; (40340c <xSecondTimerHandler+0x2b0>)
  4033ae:	6013      	str	r3, [r2, #0]
  4033b0:	4b14      	ldr	r3, [pc, #80]	; (403404 <xSecondTimerHandler+0x2a8>)
  4033b2:	6818      	ldr	r0, [r3, #0]
  4033b4:	463a      	mov	r2, r7
  4033b6:	2300      	movs	r3, #0
  4033b8:	4914      	ldr	r1, [pc, #80]	; (40340c <xSecondTimerHandler+0x2b0>)
  4033ba:	4c0e      	ldr	r4, [pc, #56]	; (4033f4 <xSecondTimerHandler+0x298>)
  4033bc:	47a0      	blx	r4
  4033be:	4603      	mov	r3, r0
  4033c0:	2b01      	cmp	r3, #1
  4033c2:	d004      	beq.n	4033ce <xSecondTimerHandler+0x272>
  4033c4:	4b11      	ldr	r3, [pc, #68]	; (40340c <xSecondTimerHandler+0x2b0>)
  4033c6:	681b      	ldr	r3, [r3, #0]
  4033c8:	3b01      	subs	r3, #1
  4033ca:	4a10      	ldr	r2, [pc, #64]	; (40340c <xSecondTimerHandler+0x2b0>)
  4033cc:	6013      	str	r3, [r2, #0]
  4033ce:	6a3b      	ldr	r3, [r7, #32]
  4033d0:	627b      	str	r3, [r7, #36]	; 0x24
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
  4033d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4033d4:	f383 8811 	msr	BASEPRI, r3
	}

	return xHigherPriorityTaskWoken;
  4033d8:	683b      	ldr	r3, [r7, #0]
}
  4033da:	4618      	mov	r0, r3
  4033dc:	375c      	adds	r7, #92	; 0x5c
  4033de:	46bd      	mov	sp, r7
  4033e0:	bd90      	pop	{r4, r7, pc}
  4033e2:	bf00      	nop
  4033e4:	2040c408 	.word	0x2040c408
  4033e8:	2040c24c 	.word	0x2040c24c
  4033ec:	00401661 	.word	0x00401661
  4033f0:	2040c26c 	.word	0x2040c26c
  4033f4:	00400f0d 	.word	0x00400f0d
  4033f8:	004012e1 	.word	0x004012e1
  4033fc:	00402f65 	.word	0x00402f65
  403400:	00402f21 	.word	0x00402f21
  403404:	2040c250 	.word	0x2040c250
  403408:	00402edd 	.word	0x00402edd
  40340c:	2040c270 	.word	0x2040c270

00403410 <main_blinky>:
static QueueHandle_t xQueue = NULL;

/*-----------------------------------------------------------*/

void main_blinky( void )
{
  403410:	b590      	push	{r4, r7, lr}
  403412:	b083      	sub	sp, #12
  403414:	af02      	add	r7, sp, #8
	/* Create the queue. */
	xQueue = xQueueCreate( mainQUEUE_LENGTH, sizeof( uint32_t ) );
  403416:	2200      	movs	r2, #0
  403418:	2104      	movs	r1, #4
  40341a:	2001      	movs	r0, #1
  40341c:	4b0f      	ldr	r3, [pc, #60]	; (40345c <main_blinky+0x4c>)
  40341e:	4798      	blx	r3
  403420:	4602      	mov	r2, r0
  403422:	4b0f      	ldr	r3, [pc, #60]	; (403460 <main_blinky+0x50>)
  403424:	601a      	str	r2, [r3, #0]

	if( xQueue != NULL )
  403426:	4b0e      	ldr	r3, [pc, #56]	; (403460 <main_blinky+0x50>)
  403428:	681b      	ldr	r3, [r3, #0]
  40342a:	2b00      	cmp	r3, #0
  40342c:	d015      	beq.n	40345a <main_blinky+0x4a>
	{
		/* Start the two tasks as described in the comments at the top of this
		file. */
		xTaskCreate( prvQueueReceiveTask,				/* The function that implements the task. */
  40342e:	2300      	movs	r3, #0
  403430:	9301      	str	r3, [sp, #4]
  403432:	2302      	movs	r3, #2
  403434:	9300      	str	r3, [sp, #0]
  403436:	2300      	movs	r3, #0
  403438:	2282      	movs	r2, #130	; 0x82
  40343a:	490a      	ldr	r1, [pc, #40]	; (403464 <main_blinky+0x54>)
  40343c:	480a      	ldr	r0, [pc, #40]	; (403468 <main_blinky+0x58>)
  40343e:	4c0b      	ldr	r4, [pc, #44]	; (40346c <main_blinky+0x5c>)
  403440:	47a0      	blx	r4
					configMINIMAL_STACK_SIZE, 			/* The size of the stack to allocate to the task. */
					NULL, 								/* The parameter passed to the task - not used in this case. */
					mainQUEUE_RECEIVE_TASK_PRIORITY, 	/* The priority assigned to the task. */
					NULL );								/* The task handle is not required, so NULL is passed. */

		xTaskCreate( prvQueueSendTask, "TX", configMINIMAL_STACK_SIZE, NULL, mainQUEUE_SEND_TASK_PRIORITY, NULL );
  403442:	2300      	movs	r3, #0
  403444:	9301      	str	r3, [sp, #4]
  403446:	2301      	movs	r3, #1
  403448:	9300      	str	r3, [sp, #0]
  40344a:	2300      	movs	r3, #0
  40344c:	2282      	movs	r2, #130	; 0x82
  40344e:	4908      	ldr	r1, [pc, #32]	; (403470 <main_blinky+0x60>)
  403450:	4808      	ldr	r0, [pc, #32]	; (403474 <main_blinky+0x64>)
  403452:	4c06      	ldr	r4, [pc, #24]	; (40346c <main_blinky+0x5c>)
  403454:	47a0      	blx	r4

		/* Start the tasks and timer running. */
		vTaskStartScheduler();
  403456:	4b08      	ldr	r3, [pc, #32]	; (403478 <main_blinky+0x68>)
  403458:	4798      	blx	r3
	line will never be reached.  If the following line does execute, then
	there was insufficient FreeRTOS heap memory available for the Idle and/or
	timer tasks to be created.  See the memory management section on the
	FreeRTOS web site for more details on the FreeRTOS heap
	http://www.freertos.org/a00111.html. */
	for( ;; );
  40345a:	e7fe      	b.n	40345a <main_blinky+0x4a>
  40345c:	00400bdd 	.word	0x00400bdd
  403460:	2040c424 	.word	0x2040c424
  403464:	0040abd0 	.word	0x0040abd0
  403468:	004034c1 	.word	0x004034c1
  40346c:	00401835 	.word	0x00401835
  403470:	0040abd4 	.word	0x0040abd4
  403474:	0040347d 	.word	0x0040347d
  403478:	00401bdd 	.word	0x00401bdd

0040347c <prvQueueSendTask>:
}
/*-----------------------------------------------------------*/

static void prvQueueSendTask( void *pvParameters )
{
  40347c:	b590      	push	{r4, r7, lr}
  40347e:	b085      	sub	sp, #20
  403480:	af00      	add	r7, sp, #0
  403482:	6078      	str	r0, [r7, #4]
TickType_t xNextWakeTime;
const unsigned long ulValueToSend = 100UL;
  403484:	2364      	movs	r3, #100	; 0x64
  403486:	60bb      	str	r3, [r7, #8]

	/* Remove compiler warning about unused parameter. */
	( void ) pvParameters;

	/* Initialise xNextWakeTime - this only needs to be done once. */
	xNextWakeTime = xTaskGetTickCount();
  403488:	4b09      	ldr	r3, [pc, #36]	; (4034b0 <prvQueueSendTask+0x34>)
  40348a:	4798      	blx	r3
  40348c:	4603      	mov	r3, r0
  40348e:	60fb      	str	r3, [r7, #12]

	for( ;; )
	{
		/* Place this task in the blocked state until it is time to run again. */
		vTaskDelayUntil( &xNextWakeTime, mainQUEUE_SEND_FREQUENCY_MS );
  403490:	f107 030c 	add.w	r3, r7, #12
  403494:	21c8      	movs	r1, #200	; 0xc8
  403496:	4618      	mov	r0, r3
  403498:	4b06      	ldr	r3, [pc, #24]	; (4034b4 <prvQueueSendTask+0x38>)
  40349a:	4798      	blx	r3

		/* Send to the queue - causing the queue receive task to unblock and
		toggle the LED.  0 is used as the block time so the sending operation
		will not block - it shouldn't need to block as the queue should always
		be empty at this point in the code. */
		xQueueSend( xQueue, &ulValueToSend, 0U );
  40349c:	4b06      	ldr	r3, [pc, #24]	; (4034b8 <prvQueueSendTask+0x3c>)
  40349e:	6818      	ldr	r0, [r3, #0]
  4034a0:	f107 0108 	add.w	r1, r7, #8
  4034a4:	2300      	movs	r3, #0
  4034a6:	2200      	movs	r2, #0
  4034a8:	4c04      	ldr	r4, [pc, #16]	; (4034bc <prvQueueSendTask+0x40>)
  4034aa:	47a0      	blx	r4
	}
  4034ac:	e7f0      	b.n	403490 <prvQueueSendTask+0x14>
  4034ae:	bf00      	nop
  4034b0:	00401df9 	.word	0x00401df9
  4034b4:	00401ad1 	.word	0x00401ad1
  4034b8:	2040c424 	.word	0x2040c424
  4034bc:	00400cad 	.word	0x00400cad

004034c0 <prvQueueReceiveTask>:
}
/*-----------------------------------------------------------*/

static void prvQueueReceiveTask( void *pvParameters )
{
  4034c0:	b590      	push	{r4, r7, lr}
  4034c2:	b085      	sub	sp, #20
  4034c4:	af00      	add	r7, sp, #0
  4034c6:	6078      	str	r0, [r7, #4]
unsigned long ulReceivedValue;
const unsigned long ulExpectedValue = 100UL;
  4034c8:	2364      	movs	r3, #100	; 0x64
  4034ca:	60fb      	str	r3, [r7, #12]
	for( ;; )
	{
		/* Wait until something arrives in the queue - this task will block
		indefinitely provided INCLUDE_vTaskSuspend is set to 1 in
		FreeRTOSConfig.h. */
		xQueueReceive( xQueue, &ulReceivedValue, portMAX_DELAY );
  4034cc:	4b09      	ldr	r3, [pc, #36]	; (4034f4 <prvQueueReceiveTask+0x34>)
  4034ce:	6818      	ldr	r0, [r3, #0]
  4034d0:	f107 0108 	add.w	r1, r7, #8
  4034d4:	2300      	movs	r3, #0
  4034d6:	f04f 32ff 	mov.w	r2, #4294967295
  4034da:	4c07      	ldr	r4, [pc, #28]	; (4034f8 <prvQueueReceiveTask+0x38>)
  4034dc:	47a0      	blx	r4

		/*  To get here something must have been received from the queue, but
		is it the expected value?  If it is, toggle the LED. */
		if( ulReceivedValue == ulExpectedValue )
  4034de:	68ba      	ldr	r2, [r7, #8]
  4034e0:	68fb      	ldr	r3, [r7, #12]
  4034e2:	429a      	cmp	r2, r3
  4034e4:	d1f2      	bne.n	4034cc <prvQueueReceiveTask+0xc>
		{
			LED_Toggle( mainTASK_LED );
  4034e6:	2000      	movs	r0, #0
  4034e8:	4b04      	ldr	r3, [pc, #16]	; (4034fc <prvQueueReceiveTask+0x3c>)
  4034ea:	4798      	blx	r3
			ulReceivedValue = 0U;
  4034ec:	2300      	movs	r3, #0
  4034ee:	60bb      	str	r3, [r7, #8]
		}
	}
  4034f0:	e7ec      	b.n	4034cc <prvQueueReceiveTask+0xc>
  4034f2:	bf00      	nop
  4034f4:	2040c424 	.word	0x2040c424
  4034f8:	00401079 	.word	0x00401079
  4034fc:	00403ad9 	.word	0x00403ad9

00403500 <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  403500:	b480      	push	{r7}
  403502:	b083      	sub	sp, #12
  403504:	af00      	add	r7, sp, #0
  403506:	4603      	mov	r3, r0
  403508:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
  40350a:	4909      	ldr	r1, [pc, #36]	; (403530 <NVIC_ClearPendingIRQ+0x30>)
  40350c:	f997 3007 	ldrsb.w	r3, [r7, #7]
  403510:	095b      	lsrs	r3, r3, #5
  403512:	79fa      	ldrb	r2, [r7, #7]
  403514:	f002 021f 	and.w	r2, r2, #31
  403518:	2001      	movs	r0, #1
  40351a:	fa00 f202 	lsl.w	r2, r0, r2
  40351e:	3360      	adds	r3, #96	; 0x60
  403520:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  403524:	bf00      	nop
  403526:	370c      	adds	r7, #12
  403528:	46bd      	mov	sp, r7
  40352a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40352e:	4770      	bx	lr
  403530:	e000e100 	.word	0xe000e100

00403534 <TC0_Handler>:
//	TC_Start( TC1, tmrTC1_CHANNEL_0 );
}
/*-----------------------------------------------------------*/

void TC0_Handler( void )
{
  403534:	b580      	push	{r7, lr}
  403536:	af00      	add	r7, sp, #0
	/* Read will clear the status bit. */
	if( ( TC0->TC_CHANNEL[ tmrTC0_CHANNEL_0 ].TC_SR & tmrRC_COMPARE ) != 0 )
  403538:	4b13      	ldr	r3, [pc, #76]	; (403588 <TC0_Handler+0x54>)
  40353a:	6a1b      	ldr	r3, [r3, #32]
  40353c:	f003 0310 	and.w	r3, r3, #16
  403540:	2b00      	cmp	r3, #0
  403542:	d00c      	beq.n	40355e <TC0_Handler+0x2a>
	{
		/* Call the IntQ test function for this channel. */
		portYIELD_FROM_ISR( xFirstTimerHandler() );
  403544:	4b11      	ldr	r3, [pc, #68]	; (40358c <TC0_Handler+0x58>)
  403546:	4798      	blx	r3
  403548:	4603      	mov	r3, r0
  40354a:	2b00      	cmp	r3, #0
  40354c:	d007      	beq.n	40355e <TC0_Handler+0x2a>
  40354e:	4b10      	ldr	r3, [pc, #64]	; (403590 <TC0_Handler+0x5c>)
  403550:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  403554:	601a      	str	r2, [r3, #0]
  403556:	f3bf 8f4f 	dsb	sy
  40355a:	f3bf 8f6f 	isb	sy
	}

	if( ( TC0->TC_CHANNEL[ tmrTC0_CHANNEL_1 ].TC_SR & tmrRC_COMPARE ) != 0 )
  40355e:	4b0a      	ldr	r3, [pc, #40]	; (403588 <TC0_Handler+0x54>)
  403560:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  403562:	f003 0310 	and.w	r3, r3, #16
  403566:	2b00      	cmp	r3, #0
  403568:	d00c      	beq.n	403584 <TC0_Handler+0x50>
	{
		/* Call the IntQ test function for this channel. */
		portYIELD_FROM_ISR( xSecondTimerHandler() );
  40356a:	4b0a      	ldr	r3, [pc, #40]	; (403594 <TC0_Handler+0x60>)
  40356c:	4798      	blx	r3
  40356e:	4603      	mov	r3, r0
  403570:	2b00      	cmp	r3, #0
  403572:	d007      	beq.n	403584 <TC0_Handler+0x50>
  403574:	4b06      	ldr	r3, [pc, #24]	; (403590 <TC0_Handler+0x5c>)
  403576:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  40357a:	601a      	str	r2, [r3, #0]
  40357c:	f3bf 8f4f 	dsb	sy
  403580:	f3bf 8f6f 	isb	sy
	}
}
  403584:	bf00      	nop
  403586:	bd80      	pop	{r7, pc}
  403588:	4000c000 	.word	0x4000c000
  40358c:	00402f8d 	.word	0x00402f8d
  403590:	e000ed04 	.word	0xe000ed04
  403594:	0040315d 	.word	0x0040315d

00403598 <TC1_Handler>:
/*-----------------------------------------------------------*/

void TC1_Handler( void )
{
  403598:	b580      	push	{r7, lr}
  40359a:	b082      	sub	sp, #8
  40359c:	af00      	add	r7, sp, #0
volatile uint32_t ulDummy;

    /* Dummy read to clear status bit. */
    ulDummy = TC1->TC_CHANNEL[ tmrTC1_CHANNEL_0 ].TC_SR;
  40359e:	4b08      	ldr	r3, [pc, #32]	; (4035c0 <TC1_Handler+0x28>)
  4035a0:	6a1b      	ldr	r3, [r3, #32]
  4035a2:	607b      	str	r3, [r7, #4]
	NVIC_ClearPendingIRQ( TC1_IRQn );
  4035a4:	2018      	movs	r0, #24
  4035a6:	4b07      	ldr	r3, [pc, #28]	; (4035c4 <TC1_Handler+0x2c>)
  4035a8:	4798      	blx	r3

	/* Keep a count of the number of interrupts to use as a time base for the
	run-time stats. */
	ulHighFrequencyTimerCounts++;
  4035aa:	4b07      	ldr	r3, [pc, #28]	; (4035c8 <TC1_Handler+0x30>)
  4035ac:	681b      	ldr	r3, [r3, #0]
  4035ae:	3301      	adds	r3, #1
  4035b0:	4a05      	ldr	r2, [pc, #20]	; (4035c8 <TC1_Handler+0x30>)
  4035b2:	6013      	str	r3, [r2, #0]

	/* Prevent compiler warnings about the variable being set but then
	unused. */
	( void ) ulDummy;
  4035b4:	687b      	ldr	r3, [r7, #4]
}
  4035b6:	bf00      	nop
  4035b8:	3708      	adds	r7, #8
  4035ba:	46bd      	mov	sp, r7
  4035bc:	bd80      	pop	{r7, pc}
  4035be:	bf00      	nop
  4035c0:	40010000 	.word	0x40010000
  4035c4:	00403501 	.word	0x00403501
  4035c8:	2040c430 	.word	0x2040c430

004035cc <TCM_Disable>:
/** \brief  TCM memory Disable

	The function enables TCM memories
 */
__STATIC_INLINE void TCM_Disable(void) 
{
  4035cc:	b480      	push	{r7}
  4035ce:	af00      	add	r7, sp, #0
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb");
  4035d0:	f3bf 8f4f 	dsb	sy
    so that all instructions following the ISB are fetched from cache or
    memory, after the instruction has been completed.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb");
  4035d4:	f3bf 8f6f 	isb	sy

	__DSB();
	__ISB();
	SCB->ITCMCR &= ~(uint32_t)SCB_ITCMCR_EN_Msk;
  4035d8:	4a0c      	ldr	r2, [pc, #48]	; (40360c <TCM_Disable+0x40>)
  4035da:	4b0c      	ldr	r3, [pc, #48]	; (40360c <TCM_Disable+0x40>)
  4035dc:	f8d3 3290 	ldr.w	r3, [r3, #656]	; 0x290
  4035e0:	f023 0301 	bic.w	r3, r3, #1
  4035e4:	f8c2 3290 	str.w	r3, [r2, #656]	; 0x290
	SCB->DTCMCR &= ~(uint32_t)SCB_ITCMCR_EN_Msk;
  4035e8:	4a08      	ldr	r2, [pc, #32]	; (40360c <TCM_Disable+0x40>)
  4035ea:	4b08      	ldr	r3, [pc, #32]	; (40360c <TCM_Disable+0x40>)
  4035ec:	f8d3 3294 	ldr.w	r3, [r3, #660]	; 0x294
  4035f0:	f023 0301 	bic.w	r3, r3, #1
  4035f4:	f8c2 3294 	str.w	r3, [r2, #660]	; 0x294
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb");
  4035f8:	f3bf 8f4f 	dsb	sy
    so that all instructions following the ISB are fetched from cache or
    memory, after the instruction has been completed.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb");
  4035fc:	f3bf 8f6f 	isb	sy
	__DSB();
	__ISB();
}
  403600:	bf00      	nop
  403602:	46bd      	mov	sp, r7
  403604:	f85d 7b04 	ldr.w	r7, [sp], #4
  403608:	4770      	bx	lr
  40360a:	bf00      	nop
  40360c:	e000ed00 	.word	0xe000ed00

00403610 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  403610:	b580      	push	{r7, lr}
  403612:	b082      	sub	sp, #8
  403614:	af00      	add	r7, sp, #0
		uint32_t *pSrc, *pDest;

		/* Initialize the relocate segment */
		pSrc = &_etext;
  403616:	4b1b      	ldr	r3, [pc, #108]	; (403684 <Reset_Handler+0x74>)
  403618:	607b      	str	r3, [r7, #4]
		pDest = &_srelocate;
  40361a:	4b1b      	ldr	r3, [pc, #108]	; (403688 <Reset_Handler+0x78>)
  40361c:	603b      	str	r3, [r7, #0]

		if (pSrc != pDest) {
  40361e:	687a      	ldr	r2, [r7, #4]
  403620:	683b      	ldr	r3, [r7, #0]
  403622:	429a      	cmp	r2, r3
  403624:	d00c      	beq.n	403640 <Reset_Handler+0x30>
				for (; pDest < &_erelocate;) {
  403626:	e007      	b.n	403638 <Reset_Handler+0x28>
						*pDest++ = *pSrc++;
  403628:	683b      	ldr	r3, [r7, #0]
  40362a:	1d1a      	adds	r2, r3, #4
  40362c:	603a      	str	r2, [r7, #0]
  40362e:	687a      	ldr	r2, [r7, #4]
  403630:	1d11      	adds	r1, r2, #4
  403632:	6079      	str	r1, [r7, #4]
  403634:	6812      	ldr	r2, [r2, #0]
  403636:	601a      	str	r2, [r3, #0]
		/* Initialize the relocate segment */
		pSrc = &_etext;
		pDest = &_srelocate;

		if (pSrc != pDest) {
				for (; pDest < &_erelocate;) {
  403638:	683b      	ldr	r3, [r7, #0]
  40363a:	4a14      	ldr	r2, [pc, #80]	; (40368c <Reset_Handler+0x7c>)
  40363c:	4293      	cmp	r3, r2
  40363e:	d3f3      	bcc.n	403628 <Reset_Handler+0x18>
						*pDest++ = *pSrc++;
				}
		}

		/* Clear the zero segment */
		for (pDest = &_szero; pDest < &_ezero;) {
  403640:	4b13      	ldr	r3, [pc, #76]	; (403690 <Reset_Handler+0x80>)
  403642:	603b      	str	r3, [r7, #0]
  403644:	e004      	b.n	403650 <Reset_Handler+0x40>
				*pDest++ = 0;
  403646:	683b      	ldr	r3, [r7, #0]
  403648:	1d1a      	adds	r2, r3, #4
  40364a:	603a      	str	r2, [r7, #0]
  40364c:	2200      	movs	r2, #0
  40364e:	601a      	str	r2, [r3, #0]
						*pDest++ = *pSrc++;
				}
		}

		/* Clear the zero segment */
		for (pDest = &_szero; pDest < &_ezero;) {
  403650:	683b      	ldr	r3, [r7, #0]
  403652:	4a10      	ldr	r2, [pc, #64]	; (403694 <Reset_Handler+0x84>)
  403654:	4293      	cmp	r3, r2
  403656:	d3f6      	bcc.n	403646 <Reset_Handler+0x36>
				*pDest++ = 0;
		}

		/* Set the vector table base address */
		pSrc = (uint32_t *) & _sfixed;
  403658:	4b0f      	ldr	r3, [pc, #60]	; (403698 <Reset_Handler+0x88>)
  40365a:	607b      	str	r3, [r7, #4]
		SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  40365c:	4a0f      	ldr	r2, [pc, #60]	; (40369c <Reset_Handler+0x8c>)
  40365e:	687b      	ldr	r3, [r7, #4]
  403660:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  403664:	6093      	str	r3, [r2, #8]
		EFC->EEFC_FCR = (EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FCMD_SGPB
						| EEFC_FCR_FARG(7));
 
		TCM_Enable();
	#else
		EFC->EEFC_FCR = (EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FCMD_CGPB 
  403666:	4b0e      	ldr	r3, [pc, #56]	; (4036a0 <Reset_Handler+0x90>)
  403668:	4a0e      	ldr	r2, [pc, #56]	; (4036a4 <Reset_Handler+0x94>)
  40366a:	605a      	str	r2, [r3, #4]
						| EEFC_FCR_FARG(8));
		EFC->EEFC_FCR = (EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FCMD_CGPB 
  40366c:	4b0c      	ldr	r3, [pc, #48]	; (4036a0 <Reset_Handler+0x90>)
  40366e:	4a0e      	ldr	r2, [pc, #56]	; (4036a8 <Reset_Handler+0x98>)
  403670:	605a      	str	r2, [r3, #4]
						| EEFC_FCR_FARG(7));
	
		TCM_Disable();
  403672:	4b0e      	ldr	r3, [pc, #56]	; (4036ac <Reset_Handler+0x9c>)
  403674:	4798      	blx	r3
	#endif

		LowLevelInit();
  403676:	4b0e      	ldr	r3, [pc, #56]	; (4036b0 <Reset_Handler+0xa0>)
  403678:	4798      	blx	r3
		/* Initialize the C library */
		__libc_init_array();
  40367a:	4b0e      	ldr	r3, [pc, #56]	; (4036b4 <Reset_Handler+0xa4>)
  40367c:	4798      	blx	r3

		/* Branch to main function */
		main();
  40367e:	4b0e      	ldr	r3, [pc, #56]	; (4036b8 <Reset_Handler+0xa8>)
  403680:	4798      	blx	r3

		/* Infinite loop */
		while (1);
  403682:	e7fe      	b.n	403682 <Reset_Handler+0x72>
  403684:	0040afa0 	.word	0x0040afa0
  403688:	20400000 	.word	0x20400000
  40368c:	204008ac 	.word	0x204008ac
  403690:	204008ac 	.word	0x204008ac
  403694:	2040c4c0 	.word	0x2040c4c0
  403698:	00400000 	.word	0x00400000
  40369c:	e000ed00 	.word	0xe000ed00
  4036a0:	400e0c00 	.word	0x400e0c00
  4036a4:	5a00080c 	.word	0x5a00080c
  4036a8:	5a00070c 	.word	0x5a00070c
  4036ac:	004035cd 	.word	0x004035cd
  4036b0:	0040396d 	.word	0x0040396d
  4036b4:	00404cbd 	.word	0x00404cbd
  4036b8:	00404305 	.word	0x00404305

004036bc <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  4036bc:	b480      	push	{r7}
  4036be:	af00      	add	r7, sp, #0
		while (1) {
		}
  4036c0:	e7fe      	b.n	4036c0 <Dummy_Handler+0x4>
  4036c2:	bf00      	nop

004036c4 <SystemInit>:
/**
 * \brief Set up the Microcontroller system.
 * Initialize the System and update the SystemFrequency variable.
 */
 void SystemInit( void )
{
  4036c4:	b480      	push	{r7}
  4036c6:	b083      	sub	sp, #12
  4036c8:	af00      	add	r7, sp, #0
	uint32_t read_MOR;
	/* Set FWS according to SYS_BOARD_MCKR configuration */
	EFC->EEFC_FMR = EEFC_FMR_FWS(5);
  4036ca:	4b38      	ldr	r3, [pc, #224]	; (4037ac <SystemInit+0xe8>)
  4036cc:	f44f 62a0 	mov.w	r2, #1280	; 0x500
  4036d0:	601a      	str	r2, [r3, #0]
	 /* Before switching MAIN OSC on external crystal : enable it and don't 
	 * disable at the same time RC OSC in case of if MAIN OSC is still using RC
	 * OSC
	 */
	
	read_MOR = PMC->CKGR_MOR;
  4036d2:	4b37      	ldr	r3, [pc, #220]	; (4037b0 <SystemInit+0xec>)
  4036d4:	6a1b      	ldr	r3, [r3, #32]
  4036d6:	607b      	str	r3, [r7, #4]
	 /* enable external crystal - enable RC OSC */
	read_MOR |= (CKGR_MOR_KEY_PASSWD |CKGR_MOR_XT32KFME); 
  4036d8:	687a      	ldr	r2, [r7, #4]
  4036da:	4b36      	ldr	r3, [pc, #216]	; (4037b4 <SystemInit+0xf0>)
  4036dc:	4313      	orrs	r3, r2
  4036de:	607b      	str	r3, [r7, #4]
	PMC->CKGR_MOR = read_MOR;
  4036e0:	4a33      	ldr	r2, [pc, #204]	; (4037b0 <SystemInit+0xec>)
  4036e2:	687b      	ldr	r3, [r7, #4]
  4036e4:	6213      	str	r3, [r2, #32]
	
	/* Select XTAL 32k instead of internal slow RC 32k for slow clock */
	if ( (SUPC->SUPC_SR & SUPC_SR_OSCSEL) != SUPC_SR_OSCSEL_CRYST )
  4036e6:	4b34      	ldr	r3, [pc, #208]	; (4037b8 <SystemInit+0xf4>)
  4036e8:	695b      	ldr	r3, [r3, #20]
  4036ea:	f003 0380 	and.w	r3, r3, #128	; 0x80
  4036ee:	2b00      	cmp	r3, #0
  4036f0:	d109      	bne.n	403706 <SystemInit+0x42>
	{
		SUPC->SUPC_CR = SUPC_CR_KEY_PASSWD | SUPC_CR_XTALSEL_CRYSTAL_SEL;
  4036f2:	4b31      	ldr	r3, [pc, #196]	; (4037b8 <SystemInit+0xf4>)
  4036f4:	4a31      	ldr	r2, [pc, #196]	; (4037bc <SystemInit+0xf8>)
  4036f6:	601a      	str	r2, [r3, #0]
	
		while( !(SUPC->SUPC_SR & SUPC_SR_OSCSEL) );
  4036f8:	bf00      	nop
  4036fa:	4b2f      	ldr	r3, [pc, #188]	; (4037b8 <SystemInit+0xf4>)
  4036fc:	695b      	ldr	r3, [r3, #20]
  4036fe:	f003 0380 	and.w	r3, r3, #128	; 0x80
  403702:	2b00      	cmp	r3, #0
  403704:	d0f9      	beq.n	4036fa <SystemInit+0x36>
	}
	
	/* Initialize main oscillator */
	if ( !(PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) )
  403706:	4b2a      	ldr	r3, [pc, #168]	; (4037b0 <SystemInit+0xec>)
  403708:	6a1b      	ldr	r3, [r3, #32]
  40370a:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  40370e:	2b00      	cmp	r3, #0
  403710:	d109      	bne.n	403726 <SystemInit+0x62>
	{
	  PMC->CKGR_MOR = CKGR_MOR_KEY_PASSWD | SYS_BOARD_OSCOUNT
  403712:	4b27      	ldr	r3, [pc, #156]	; (4037b0 <SystemInit+0xec>)
  403714:	4a2a      	ldr	r2, [pc, #168]	; (4037c0 <SystemInit+0xfc>)
  403716:	621a      	str	r2, [r3, #32]
					| CKGR_MOR_MOSCRCEN | CKGR_MOR_MOSCXTEN;
	
	  while ( !(PMC->PMC_SR & PMC_SR_MOSCXTS) )
  403718:	bf00      	nop
  40371a:	4b25      	ldr	r3, [pc, #148]	; (4037b0 <SystemInit+0xec>)
  40371c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  40371e:	f003 0301 	and.w	r3, r3, #1
  403722:	2b00      	cmp	r3, #0
  403724:	d0f9      	beq.n	40371a <SystemInit+0x56>
	  {
	  }
	}
	
	/* Switch to 3-20MHz Xtal oscillator */
	PMC->CKGR_MOR = CKGR_MOR_KEY_PASSWD | SYS_BOARD_OSCOUNT 
  403726:	4b22      	ldr	r3, [pc, #136]	; (4037b0 <SystemInit+0xec>)
  403728:	4a26      	ldr	r2, [pc, #152]	; (4037c4 <SystemInit+0x100>)
  40372a:	621a      	str	r2, [r3, #32]
					| CKGR_MOR_MOSCRCEN | CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCSEL;
	
	while ( !(PMC->PMC_SR & PMC_SR_MOSCSELS) )
  40372c:	bf00      	nop
  40372e:	4b20      	ldr	r3, [pc, #128]	; (4037b0 <SystemInit+0xec>)
  403730:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  403732:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
  403736:	2b00      	cmp	r3, #0
  403738:	d0f9      	beq.n	40372e <SystemInit+0x6a>
	{
	}
	
	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~(uint32_t)PMC_MCKR_CSS_Msk)
  40373a:	4a1d      	ldr	r2, [pc, #116]	; (4037b0 <SystemInit+0xec>)
  40373c:	4b1c      	ldr	r3, [pc, #112]	; (4037b0 <SystemInit+0xec>)
  40373e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  403740:	f023 0303 	bic.w	r3, r3, #3
					| PMC_MCKR_CSS_MAIN_CLK;
  403744:	f043 0301 	orr.w	r3, r3, #1
	
	while ( !(PMC->PMC_SR & PMC_SR_MOSCSELS) )
	{
	}
	
	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~(uint32_t)PMC_MCKR_CSS_Msk)
  403748:	6313      	str	r3, [r2, #48]	; 0x30
					| PMC_MCKR_CSS_MAIN_CLK;

	while ( !(PMC->PMC_SR & PMC_SR_MCKRDY) )
  40374a:	bf00      	nop
  40374c:	4b18      	ldr	r3, [pc, #96]	; (4037b0 <SystemInit+0xec>)
  40374e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  403750:	f003 0308 	and.w	r3, r3, #8
  403754:	2b00      	cmp	r3, #0
  403756:	d0f9      	beq.n	40374c <SystemInit+0x88>
	{
	}
   
	/* Initialize PLLA */
	PMC->CKGR_PLLAR = SYS_BOARD_PLLAR;
  403758:	4b15      	ldr	r3, [pc, #84]	; (4037b0 <SystemInit+0xec>)
  40375a:	4a1b      	ldr	r2, [pc, #108]	; (4037c8 <SystemInit+0x104>)
  40375c:	629a      	str	r2, [r3, #40]	; 0x28
	while ( !(PMC->PMC_SR & PMC_SR_LOCKA) )
  40375e:	bf00      	nop
  403760:	4b13      	ldr	r3, [pc, #76]	; (4037b0 <SystemInit+0xec>)
  403762:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  403764:	f003 0302 	and.w	r3, r3, #2
  403768:	2b00      	cmp	r3, #0
  40376a:	d0f9      	beq.n	403760 <SystemInit+0x9c>
	{
	}
   
	/* Switch to main clock */
	PMC->PMC_MCKR = (SYS_BOARD_MCKR & ~PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_MAIN_CLK;
  40376c:	4b10      	ldr	r3, [pc, #64]	; (4037b0 <SystemInit+0xec>)
  40376e:	f240 1201 	movw	r2, #257	; 0x101
  403772:	631a      	str	r2, [r3, #48]	; 0x30
	while ( !(PMC->PMC_SR & PMC_SR_MCKRDY) )
  403774:	bf00      	nop
  403776:	4b0e      	ldr	r3, [pc, #56]	; (4037b0 <SystemInit+0xec>)
  403778:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  40377a:	f003 0308 	and.w	r3, r3, #8
  40377e:	2b00      	cmp	r3, #0
  403780:	d0f9      	beq.n	403776 <SystemInit+0xb2>
	{
	}
   
	/* Switch to PLLA */
	PMC->PMC_MCKR = SYS_BOARD_MCKR;
  403782:	4b0b      	ldr	r3, [pc, #44]	; (4037b0 <SystemInit+0xec>)
  403784:	f44f 7281 	mov.w	r2, #258	; 0x102
  403788:	631a      	str	r2, [r3, #48]	; 0x30
	while ( !(PMC->PMC_SR & PMC_SR_MCKRDY) )
  40378a:	bf00      	nop
  40378c:	4b08      	ldr	r3, [pc, #32]	; (4037b0 <SystemInit+0xec>)
  40378e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  403790:	f003 0308 	and.w	r3, r3, #8
  403794:	2b00      	cmp	r3, #0
  403796:	d0f9      	beq.n	40378c <SystemInit+0xc8>
	{
	}
   
	SystemCoreClock = CHIP_FREQ_CPU_MAX;
  403798:	4b0c      	ldr	r3, [pc, #48]	; (4037cc <SystemInit+0x108>)
  40379a:	4a0d      	ldr	r2, [pc, #52]	; (4037d0 <SystemInit+0x10c>)
  40379c:	601a      	str	r2, [r3, #0]
}
  40379e:	bf00      	nop
  4037a0:	370c      	adds	r7, #12
  4037a2:	46bd      	mov	sp, r7
  4037a4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4037a8:	4770      	bx	lr
  4037aa:	bf00      	nop
  4037ac:	400e0c00 	.word	0x400e0c00
  4037b0:	400e0600 	.word	0x400e0600
  4037b4:	04370000 	.word	0x04370000
  4037b8:	400e1810 	.word	0x400e1810
  4037bc:	a5000008 	.word	0xa5000008
  4037c0:	00370809 	.word	0x00370809
  4037c4:	01370809 	.word	0x01370809
  4037c8:	20183f01 	.word	0x20183f01
  4037cc:	20400008 	.word	0x20400008
  4037d0:	11e1a300 	.word	0x11e1a300

004037d4 <_SetupMemoryRegion>:

/**
 * \brief Set up a memory region.
 */
void _SetupMemoryRegion( void )
{
  4037d4:	b580      	push	{r7, lr}
  4037d6:	b082      	sub	sp, #8
  4037d8:	af00      	add	r7, sp, #0
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
  4037da:	f3bf 8f5f 	dmb	sy
/***************************************************
	ITCM memory region --- Normal 
	START_Addr:-  0x00000000UL
	END_Addr:-    0x00400000UL
****************************************************/
	dwRegionBaseAddr = 
  4037de:	2311      	movs	r3, #17
  4037e0:	607b      	str	r3, [r7, #4]
		MPU_REGION_VALID |
		MPU_DEFAULT_ITCM_REGION;        // 1

	dwRegionAttr = 
		MPU_AP_PRIVILEGED_READ_WRITE | 
		MPU_CalMPURegionSize(ITCM_END_ADDRESS - ITCM_START_ADDRESS) |
  4037e2:	484a      	ldr	r0, [pc, #296]	; (40390c <_SetupMemoryRegion+0x138>)
  4037e4:	4b4a      	ldr	r3, [pc, #296]	; (403910 <_SetupMemoryRegion+0x13c>)
  4037e6:	4798      	blx	r3
  4037e8:	4602      	mov	r2, r0
	dwRegionBaseAddr = 
		ITCM_START_ADDRESS |
		MPU_REGION_VALID |
		MPU_DEFAULT_ITCM_REGION;        // 1

	dwRegionAttr = 
  4037ea:	4b4a      	ldr	r3, [pc, #296]	; (403914 <_SetupMemoryRegion+0x140>)
  4037ec:	4313      	orrs	r3, r2
  4037ee:	603b      	str	r3, [r7, #0]
		MPU_AP_PRIVILEGED_READ_WRITE | 
		MPU_CalMPURegionSize(ITCM_END_ADDRESS - ITCM_START_ADDRESS) |
		MPU_REGION_ENABLE;

	MPU_SetRegion( dwRegionBaseAddr, dwRegionAttr);
  4037f0:	6839      	ldr	r1, [r7, #0]
  4037f2:	6878      	ldr	r0, [r7, #4]
  4037f4:	4b48      	ldr	r3, [pc, #288]	; (403918 <_SetupMemoryRegion+0x144>)
  4037f6:	4798      	blx	r3
	(update to Strongly ordered in write accesses)
	START_Addr:-  0x00400000UL
	END_Addr:-    0x00600000UL
******************************************************/
	
	dwRegionBaseAddr = 
  4037f8:	4b48      	ldr	r3, [pc, #288]	; (40391c <_SetupMemoryRegion+0x148>)
  4037fa:	607b      	str	r3, [r7, #4]
		MPU_DEFAULT_IFLASH_REGION;      //2

	dwRegionAttr = 
		MPU_AP_READONLY |
		INNER_NORMAL_WB_NWA_TYPE( NON_SHAREABLE ) |
		MPU_CalMPURegionSize(IFLASH_END_ADDRESS - IFLASH_START_ADDRESS) |
  4037fc:	4848      	ldr	r0, [pc, #288]	; (403920 <_SetupMemoryRegion+0x14c>)
  4037fe:	4b44      	ldr	r3, [pc, #272]	; (403910 <_SetupMemoryRegion+0x13c>)
  403800:	4798      	blx	r3
  403802:	4602      	mov	r2, r0
	dwRegionBaseAddr = 
		IFLASH_START_ADDRESS |
		MPU_REGION_VALID |
		MPU_DEFAULT_IFLASH_REGION;      //2

	dwRegionAttr = 
  403804:	4b47      	ldr	r3, [pc, #284]	; (403924 <_SetupMemoryRegion+0x150>)
  403806:	4313      	orrs	r3, r2
  403808:	603b      	str	r3, [r7, #0]
		MPU_AP_READONLY |
		INNER_NORMAL_WB_NWA_TYPE( NON_SHAREABLE ) |
		MPU_CalMPURegionSize(IFLASH_END_ADDRESS - IFLASH_START_ADDRESS) |
		MPU_REGION_ENABLE;

	MPU_SetRegion( dwRegionBaseAddr, dwRegionAttr);
  40380a:	6839      	ldr	r1, [r7, #0]
  40380c:	6878      	ldr	r0, [r7, #4]
  40380e:	4b42      	ldr	r3, [pc, #264]	; (403918 <_SetupMemoryRegion+0x144>)
  403810:	4798      	blx	r3
	START_Addr:-  0x20000000L
	END_Addr:-    0x20400000UL
******************************************************/

	/* DTCM memory region */
	dwRegionBaseAddr = 
  403812:	4b45      	ldr	r3, [pc, #276]	; (403928 <_SetupMemoryRegion+0x154>)
  403814:	607b      	str	r3, [r7, #4]
		MPU_REGION_VALID |
		MPU_DEFAULT_DTCM_REGION;         //3

	dwRegionAttr = 
		MPU_AP_PRIVILEGED_READ_WRITE | 
		MPU_CalMPURegionSize(DTCM_END_ADDRESS - DTCM_START_ADDRESS) |
  403816:	483d      	ldr	r0, [pc, #244]	; (40390c <_SetupMemoryRegion+0x138>)
  403818:	4b3d      	ldr	r3, [pc, #244]	; (403910 <_SetupMemoryRegion+0x13c>)
  40381a:	4798      	blx	r3
  40381c:	4602      	mov	r2, r0
	dwRegionBaseAddr = 
		DTCM_START_ADDRESS |
		MPU_REGION_VALID |
		MPU_DEFAULT_DTCM_REGION;         //3

	dwRegionAttr = 
  40381e:	4b3d      	ldr	r3, [pc, #244]	; (403914 <_SetupMemoryRegion+0x140>)
  403820:	4313      	orrs	r3, r2
  403822:	603b      	str	r3, [r7, #0]
		MPU_AP_PRIVILEGED_READ_WRITE | 
		MPU_CalMPURegionSize(DTCM_END_ADDRESS - DTCM_START_ADDRESS) |
		MPU_REGION_ENABLE;

	MPU_SetRegion( dwRegionBaseAddr, dwRegionAttr);
  403824:	6839      	ldr	r1, [r7, #0]
  403826:	6878      	ldr	r0, [r7, #4]
  403828:	4b3b      	ldr	r3, [pc, #236]	; (403918 <_SetupMemoryRegion+0x144>)
  40382a:	4798      	blx	r3
	SRAM Cacheable memory region --- Normal
	START_Addr:-  0x20400000UL
	END_Addr:-    0x2043FFFFUL
******************************************************/
	/* SRAM memory  region */
	dwRegionBaseAddr = 
  40382c:	4b3f      	ldr	r3, [pc, #252]	; (40392c <_SetupMemoryRegion+0x158>)
  40382e:	607b      	str	r3, [r7, #4]
		MPU_DEFAULT_SRAM_REGION_1;         //4

	dwRegionAttr = 
		MPU_AP_FULL_ACCESS    |
		INNER_NORMAL_WB_NWA_TYPE( NON_SHAREABLE ) |
		MPU_CalMPURegionSize(SRAM_FIRST_END_ADDRESS - SRAM_FIRST_START_ADDRESS) 
  403830:	483f      	ldr	r0, [pc, #252]	; (403930 <_SetupMemoryRegion+0x15c>)
  403832:	4b37      	ldr	r3, [pc, #220]	; (403910 <_SetupMemoryRegion+0x13c>)
  403834:	4798      	blx	r3
  403836:	4602      	mov	r2, r0
	dwRegionBaseAddr = 
		SRAM_FIRST_START_ADDRESS |
		MPU_REGION_VALID |
		MPU_DEFAULT_SRAM_REGION_1;         //4

	dwRegionAttr = 
  403838:	4b3e      	ldr	r3, [pc, #248]	; (403934 <_SetupMemoryRegion+0x160>)
  40383a:	4313      	orrs	r3, r2
  40383c:	603b      	str	r3, [r7, #0]
		MPU_AP_FULL_ACCESS    |
		INNER_NORMAL_WB_NWA_TYPE( NON_SHAREABLE ) |
		MPU_CalMPURegionSize(SRAM_FIRST_END_ADDRESS - SRAM_FIRST_START_ADDRESS) 
		| MPU_REGION_ENABLE;

	MPU_SetRegion( dwRegionBaseAddr, dwRegionAttr);
  40383e:	6839      	ldr	r1, [r7, #0]
  403840:	6878      	ldr	r0, [r7, #4]
  403842:	4b35      	ldr	r3, [pc, #212]	; (403918 <_SetupMemoryRegion+0x144>)
  403844:	4798      	blx	r3
	Internal SRAM second partition memory region --- Normal 
	START_Addr:-  0x20440000UL
	END_Addr:-    0x2045FFFFUL
******************************************************/
	/* SRAM memory region */
	dwRegionBaseAddr = 
  403846:	4b3c      	ldr	r3, [pc, #240]	; (403938 <_SetupMemoryRegion+0x164>)
  403848:	607b      	str	r3, [r7, #4]
		MPU_DEFAULT_SRAM_REGION_2;         //5

	dwRegionAttr = 
		MPU_AP_FULL_ACCESS    |
		INNER_NORMAL_WB_NWA_TYPE( NON_SHAREABLE ) |
		MPU_CalMPURegionSize(SRAM_SECOND_END_ADDRESS - SRAM_SECOND_START_ADDRESS) |
  40384a:	483c      	ldr	r0, [pc, #240]	; (40393c <_SetupMemoryRegion+0x168>)
  40384c:	4b30      	ldr	r3, [pc, #192]	; (403910 <_SetupMemoryRegion+0x13c>)
  40384e:	4798      	blx	r3
  403850:	4602      	mov	r2, r0
	dwRegionBaseAddr = 
		SRAM_SECOND_START_ADDRESS |
		MPU_REGION_VALID |
		MPU_DEFAULT_SRAM_REGION_2;         //5

	dwRegionAttr = 
  403852:	4b38      	ldr	r3, [pc, #224]	; (403934 <_SetupMemoryRegion+0x160>)
  403854:	4313      	orrs	r3, r2
  403856:	603b      	str	r3, [r7, #0]
		MPU_AP_FULL_ACCESS    |
		INNER_NORMAL_WB_NWA_TYPE( NON_SHAREABLE ) |
		MPU_CalMPURegionSize(SRAM_SECOND_END_ADDRESS - SRAM_SECOND_START_ADDRESS) |
		MPU_REGION_ENABLE;

	MPU_SetRegion( dwRegionBaseAddr, dwRegionAttr);
  403858:	6839      	ldr	r1, [r7, #0]
  40385a:	6878      	ldr	r0, [r7, #4]
  40385c:	4b2e      	ldr	r3, [pc, #184]	; (403918 <_SetupMemoryRegion+0x144>)
  40385e:	4798      	blx	r3
/****************************************************
	Peripheral memory region --- DEVICE Shareable
	START_Addr:-  0x40000000UL
	END_Addr:-    0x5FFFFFFFUL
******************************************************/
	dwRegionBaseAddr = 
  403860:	4b37      	ldr	r3, [pc, #220]	; (403940 <_SetupMemoryRegion+0x16c>)
  403862:	607b      	str	r3, [r7, #4]
		MPU_PERIPHERALS_REGION;          //6

	dwRegionAttr = MPU_AP_FULL_ACCESS |
		MPU_REGION_EXECUTE_NEVER |
		SHAREABLE_DEVICE_TYPE |
		MPU_CalMPURegionSize(PERIPHERALS_END_ADDRESS - PERIPHERALS_START_ADDRESS)
  403864:	f06f 4060 	mvn.w	r0, #3758096384	; 0xe0000000
  403868:	4b29      	ldr	r3, [pc, #164]	; (403910 <_SetupMemoryRegion+0x13c>)
  40386a:	4798      	blx	r3
  40386c:	4602      	mov	r2, r0
	dwRegionBaseAddr = 
		PERIPHERALS_START_ADDRESS |
		MPU_REGION_VALID |
		MPU_PERIPHERALS_REGION;          //6

	dwRegionAttr = MPU_AP_FULL_ACCESS |
  40386e:	4b35      	ldr	r3, [pc, #212]	; (403944 <_SetupMemoryRegion+0x170>)
  403870:	4313      	orrs	r3, r2
  403872:	603b      	str	r3, [r7, #0]
		MPU_REGION_EXECUTE_NEVER |
		SHAREABLE_DEVICE_TYPE |
		MPU_CalMPURegionSize(PERIPHERALS_END_ADDRESS - PERIPHERALS_START_ADDRESS)
		|MPU_REGION_ENABLE;

	MPU_SetRegion( dwRegionBaseAddr, dwRegionAttr);
  403874:	6839      	ldr	r1, [r7, #0]
  403876:	6878      	ldr	r0, [r7, #4]
  403878:	4b27      	ldr	r3, [pc, #156]	; (403918 <_SetupMemoryRegion+0x144>)
  40387a:	4798      	blx	r3
/****************************************************
	External EBI memory  memory region --- Strongly Ordered
	START_Addr:-  0x60000000UL
	END_Addr:-    0x6FFFFFFFUL
******************************************************/
	dwRegionBaseAddr =
  40387c:	4b32      	ldr	r3, [pc, #200]	; (403948 <_SetupMemoryRegion+0x174>)
  40387e:	607b      	str	r3, [r7, #4]
	dwRegionAttr =
		MPU_AP_FULL_ACCESS |
		/* External memory Must be defined with 'Device' or 'Strongly Ordered'
		attribute for write accesses (AXI) */
		STRONGLY_ORDERED_SHAREABLE_TYPE |
		MPU_CalMPURegionSize(EXT_EBI_END_ADDRESS - EXT_EBI_START_ADDRESS) |
  403880:	f06f 4070 	mvn.w	r0, #4026531840	; 0xf0000000
  403884:	4b22      	ldr	r3, [pc, #136]	; (403910 <_SetupMemoryRegion+0x13c>)
  403886:	4798      	blx	r3
  403888:	4602      	mov	r2, r0
	dwRegionBaseAddr =
		EXT_EBI_START_ADDRESS |
		MPU_REGION_VALID |
		MPU_EXT_EBI_REGION;

	dwRegionAttr =
  40388a:	4b30      	ldr	r3, [pc, #192]	; (40394c <_SetupMemoryRegion+0x178>)
  40388c:	4313      	orrs	r3, r2
  40388e:	603b      	str	r3, [r7, #0]
		attribute for write accesses (AXI) */
		STRONGLY_ORDERED_SHAREABLE_TYPE |
		MPU_CalMPURegionSize(EXT_EBI_END_ADDRESS - EXT_EBI_START_ADDRESS) |
		MPU_REGION_ENABLE;

	MPU_SetRegion( dwRegionBaseAddr, dwRegionAttr);
  403890:	6839      	ldr	r1, [r7, #0]
  403892:	6878      	ldr	r0, [r7, #4]
  403894:	4b20      	ldr	r3, [pc, #128]	; (403918 <_SetupMemoryRegion+0x144>)
  403896:	4798      	blx	r3
/****************************************************
	SDRAM Cacheable memory region --- Normal
	START_Addr:-  0x70000000UL
	END_Addr:-    0x7FFFFFFFUL
******************************************************/
	dwRegionBaseAddr = 
  403898:	4b2d      	ldr	r3, [pc, #180]	; (403950 <_SetupMemoryRegion+0x17c>)
  40389a:	607b      	str	r3, [r7, #4]
		MPU_DEFAULT_SDRAM_REGION;        //7

	dwRegionAttr = 
		MPU_AP_FULL_ACCESS    |
		INNER_NORMAL_WB_RWA_TYPE( SHAREABLE ) |
		MPU_CalMPURegionSize(SDRAM_END_ADDRESS - SDRAM_START_ADDRESS) |
  40389c:	f06f 4070 	mvn.w	r0, #4026531840	; 0xf0000000
  4038a0:	4b1b      	ldr	r3, [pc, #108]	; (403910 <_SetupMemoryRegion+0x13c>)
  4038a2:	4798      	blx	r3
  4038a4:	4602      	mov	r2, r0
	dwRegionBaseAddr = 
		SDRAM_START_ADDRESS |
		MPU_REGION_VALID |
		MPU_DEFAULT_SDRAM_REGION;        //7

	dwRegionAttr = 
  4038a6:	4b2b      	ldr	r3, [pc, #172]	; (403954 <_SetupMemoryRegion+0x180>)
  4038a8:	4313      	orrs	r3, r2
  4038aa:	603b      	str	r3, [r7, #0]
		MPU_AP_FULL_ACCESS    |
		INNER_NORMAL_WB_RWA_TYPE( SHAREABLE ) |
		MPU_CalMPURegionSize(SDRAM_END_ADDRESS - SDRAM_START_ADDRESS) |
		MPU_REGION_ENABLE;

	MPU_SetRegion( dwRegionBaseAddr, dwRegionAttr);
  4038ac:	6839      	ldr	r1, [r7, #0]
  4038ae:	6878      	ldr	r0, [r7, #4]
  4038b0:	4b19      	ldr	r3, [pc, #100]	; (403918 <_SetupMemoryRegion+0x144>)
  4038b2:	4798      	blx	r3
/****************************************************
	QSPI memory region --- Strongly ordered
	START_Addr:-  0x80000000UL
	END_Addr:-    0x9FFFFFFFUL
******************************************************/
	dwRegionBaseAddr = 
  4038b4:	4b28      	ldr	r3, [pc, #160]	; (403958 <_SetupMemoryRegion+0x184>)
  4038b6:	607b      	str	r3, [r7, #4]
		MPU_QSPIMEM_REGION;              //8

	dwRegionAttr = 
		MPU_AP_FULL_ACCESS |
		STRONGLY_ORDERED_SHAREABLE_TYPE |
		MPU_CalMPURegionSize(QSPI_END_ADDRESS - QSPI_START_ADDRESS) |
  4038b8:	f06f 4060 	mvn.w	r0, #3758096384	; 0xe0000000
  4038bc:	4b14      	ldr	r3, [pc, #80]	; (403910 <_SetupMemoryRegion+0x13c>)
  4038be:	4798      	blx	r3
  4038c0:	4602      	mov	r2, r0
	dwRegionBaseAddr = 
		QSPI_START_ADDRESS |
		MPU_REGION_VALID |
		MPU_QSPIMEM_REGION;              //8

	dwRegionAttr = 
  4038c2:	4b22      	ldr	r3, [pc, #136]	; (40394c <_SetupMemoryRegion+0x178>)
  4038c4:	4313      	orrs	r3, r2
  4038c6:	603b      	str	r3, [r7, #0]
		MPU_AP_FULL_ACCESS |
		STRONGLY_ORDERED_SHAREABLE_TYPE |
		MPU_CalMPURegionSize(QSPI_END_ADDRESS - QSPI_START_ADDRESS) |
		MPU_REGION_ENABLE;

	MPU_SetRegion( dwRegionBaseAddr, dwRegionAttr);
  4038c8:	6839      	ldr	r1, [r7, #0]
  4038ca:	6878      	ldr	r0, [r7, #4]
  4038cc:	4b12      	ldr	r3, [pc, #72]	; (403918 <_SetupMemoryRegion+0x144>)
  4038ce:	4798      	blx	r3
/****************************************************
	USB RAM Memory region --- Device
	START_Addr:-  0xA0100000UL
	END_Addr:-    0xA01FFFFFUL
******************************************************/
	dwRegionBaseAddr = 
  4038d0:	4b22      	ldr	r3, [pc, #136]	; (40395c <_SetupMemoryRegion+0x188>)
  4038d2:	607b      	str	r3, [r7, #4]

	dwRegionAttr = 
		MPU_AP_FULL_ACCESS |
		MPU_REGION_EXECUTE_NEVER |
		SHAREABLE_DEVICE_TYPE |
		MPU_CalMPURegionSize(USBHSRAM_END_ADDRESS - USBHSRAM_START_ADDRESS) |
  4038d4:	4822      	ldr	r0, [pc, #136]	; (403960 <_SetupMemoryRegion+0x18c>)
  4038d6:	4b0e      	ldr	r3, [pc, #56]	; (403910 <_SetupMemoryRegion+0x13c>)
  4038d8:	4798      	blx	r3
  4038da:	4602      	mov	r2, r0
	dwRegionBaseAddr = 
		USBHSRAM_START_ADDRESS |
		MPU_REGION_VALID |
		MPU_USBHSRAM_REGION;              //9

	dwRegionAttr = 
  4038dc:	4b19      	ldr	r3, [pc, #100]	; (403944 <_SetupMemoryRegion+0x170>)
  4038de:	4313      	orrs	r3, r2
  4038e0:	603b      	str	r3, [r7, #0]
		MPU_REGION_EXECUTE_NEVER |
		SHAREABLE_DEVICE_TYPE |
		MPU_CalMPURegionSize(USBHSRAM_END_ADDRESS - USBHSRAM_START_ADDRESS) |
		MPU_REGION_ENABLE;

	MPU_SetRegion( dwRegionBaseAddr, dwRegionAttr);
  4038e2:	6839      	ldr	r1, [r7, #0]
  4038e4:	6878      	ldr	r0, [r7, #4]
  4038e6:	4b0c      	ldr	r3, [pc, #48]	; (403918 <_SetupMemoryRegion+0x144>)
  4038e8:	4798      	blx	r3


	/* Enable the memory management fault , Bus Fault, Usage Fault exception */
	SCB->SHCSR |= (SCB_SHCSR_MEMFAULTENA_Msk | SCB_SHCSR_BUSFAULTENA_Msk
  4038ea:	4a1e      	ldr	r2, [pc, #120]	; (403964 <_SetupMemoryRegion+0x190>)
  4038ec:	4b1d      	ldr	r3, [pc, #116]	; (403964 <_SetupMemoryRegion+0x190>)
  4038ee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  4038f0:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
  4038f4:	6253      	str	r3, [r2, #36]	; 0x24
					| SCB_SHCSR_USGFAULTENA_Msk);

	/* Enable the MPU region */
	MPU_Enable( MPU_ENABLE | MPU_PRIVDEFENA);
  4038f6:	2005      	movs	r0, #5
  4038f8:	4b1b      	ldr	r3, [pc, #108]	; (403968 <_SetupMemoryRegion+0x194>)
  4038fa:	4798      	blx	r3
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb");
  4038fc:	f3bf 8f4f 	dsb	sy
    so that all instructions following the ISB are fetched from cache or
    memory, after the instruction has been completed.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb");
  403900:	f3bf 8f6f 	isb	sy
	
	memory_sync();
}
  403904:	bf00      	nop
  403906:	3708      	adds	r7, #8
  403908:	46bd      	mov	sp, r7
  40390a:	bd80      	pop	{r7, pc}
  40390c:	003fffff 	.word	0x003fffff
  403910:	00403ce5 	.word	0x00403ce5
  403914:	01000001 	.word	0x01000001
  403918:	00403cbd 	.word	0x00403cbd
  40391c:	00400012 	.word	0x00400012
  403920:	001fffff 	.word	0x001fffff
  403924:	06230001 	.word	0x06230001
  403928:	20000013 	.word	0x20000013
  40392c:	20400014 	.word	0x20400014
  403930:	0003ffff 	.word	0x0003ffff
  403934:	03230001 	.word	0x03230001
  403938:	20440015 	.word	0x20440015
  40393c:	0001ffff 	.word	0x0001ffff
  403940:	40000016 	.word	0x40000016
  403944:	13010001 	.word	0x13010001
  403948:	60000017 	.word	0x60000017
  40394c:	03000001 	.word	0x03000001
  403950:	70000018 	.word	0x70000018
  403954:	03250001 	.word	0x03250001
  403958:	80000019 	.word	0x80000019
  40395c:	a010001a 	.word	0xa010001a
  403960:	000fffff 	.word	0x000fffff
  403964:	e000ed00 	.word	0xe000ed00
  403968:	00403c9d 	.word	0x00403c9d

0040396c <LowLevelInit>:

/**
 * \brief Performs the low-level initialization of the chip.
 */
extern WEAK void LowLevelInit( void )
{
  40396c:	b580      	push	{r7, lr}
  40396e:	af00      	add	r7, sp, #0
  
	SystemInit(); 
  403970:	4b02      	ldr	r3, [pc, #8]	; (40397c <LowLevelInit+0x10>)
  403972:	4798      	blx	r3
#ifndef MPU_EXAMPLE_FEATURE
	_SetupMemoryRegion();
  403974:	4b02      	ldr	r3, [pc, #8]	; (403980 <LowLevelInit+0x14>)
  403976:	4798      	blx	r3
	/* copy code_TCM from flash to ITCM */
	while(dst < &_eitcm){
		*dst++ = *src++;
	}
#endif
}
  403978:	bf00      	nop
  40397a:	bd80      	pop	{r7, pc}
  40397c:	004036c5 	.word	0x004036c5
  403980:	004037d5 	.word	0x004037d5

00403984 <DBG_Configure>:
 *
 * \param baudrate  Baudrate at which the USART should operate (in Hz).
 * \param masterClock  Frequency of the system master clock (in Hz).
 */
extern void DBG_Configure( uint32_t baudrate, uint32_t masterClock)
{
  403984:	b5b0      	push	{r4, r5, r7, lr}
  403986:	b08a      	sub	sp, #40	; 0x28
  403988:	af00      	add	r7, sp, #0
  40398a:	6078      	str	r0, [r7, #4]
  40398c:	6039      	str	r1, [r7, #0]

	const Pin pPins[] = CONSOLE_PINS;
  40398e:	4b23      	ldr	r3, [pc, #140]	; (403a1c <DBG_Configure+0x98>)
  403990:	f107 040c 	add.w	r4, r7, #12
  403994:	461d      	mov	r5, r3
  403996:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  403998:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  40399a:	e895 0003 	ldmia.w	r5, {r0, r1}
  40399e:	e884 0003 	stmia.w	r4, {r0, r1}
	// Enable receiver and transmitter
	pUart->UART_CR = UART_CR_RXEN | UART_CR_TXEN;
#endif

#if defined CONSOLE_ON_USART
	Usart *pUsart = CONSOLE_Usart;
  4039a2:	4b1f      	ldr	r3, [pc, #124]	; (403a20 <DBG_Configure+0x9c>)
  4039a4:	627b      	str	r3, [r7, #36]	; 0x24
	// Disable the MATRIX registers write protection
	MATRIX->MATRIX_WPMR  = MATRIX_WPMR_WPKEY_PASSWD;
  4039a6:	4b1f      	ldr	r3, [pc, #124]	; (403a24 <DBG_Configure+0xa0>)
  4039a8:	4a1f      	ldr	r2, [pc, #124]	; (403a28 <DBG_Configure+0xa4>)
  4039aa:	f8c3 21e4 	str.w	r2, [r3, #484]	; 0x1e4
	MATRIX->CCFG_SYSIO |= CCFG_SYSIO_SYSIO4;
  4039ae:	4a1d      	ldr	r2, [pc, #116]	; (403a24 <DBG_Configure+0xa0>)
  4039b0:	4b1c      	ldr	r3, [pc, #112]	; (403a24 <DBG_Configure+0xa0>)
  4039b2:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
  4039b6:	f043 0310 	orr.w	r3, r3, #16
  4039ba:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114
  
	PIO_Configure( pPins, PIO_LISTSIZE( pPins ) );
  4039be:	f107 030c 	add.w	r3, r7, #12
  4039c2:	2102      	movs	r1, #2
  4039c4:	4618      	mov	r0, r3
  4039c6:	4b19      	ldr	r3, [pc, #100]	; (403a2c <DBG_Configure+0xa8>)
  4039c8:	4798      	blx	r3
	
	// Reset & disable receiver and transmitter, disable interrupts
	pUsart->US_CR = US_CR_RSTRX | US_CR_RSTTX | US_CR_RSTSTA;
  4039ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4039cc:	f44f 7286 	mov.w	r2, #268	; 0x10c
  4039d0:	601a      	str	r2, [r3, #0]
	pUsart->US_IDR = 0xFFFFFFFF;
  4039d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4039d4:	f04f 32ff 	mov.w	r2, #4294967295
  4039d8:	60da      	str	r2, [r3, #12]
	PMC_EnablePeripheral(CONSOLE_ID);
  4039da:	200e      	movs	r0, #14
  4039dc:	4b14      	ldr	r3, [pc, #80]	; (403a30 <DBG_Configure+0xac>)
  4039de:	4798      	blx	r3
	pUsart->US_BRGR = (masterClock / baudrate) / 16;
  4039e0:	683a      	ldr	r2, [r7, #0]
  4039e2:	687b      	ldr	r3, [r7, #4]
  4039e4:	fbb2 f3f3 	udiv	r3, r2, r3
  4039e8:	091a      	lsrs	r2, r3, #4
  4039ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4039ec:	621a      	str	r2, [r3, #32]
   
	// Configure mode register
	pUsart->US_MR 
			= (US_MR_USART_MODE_NORMAL | US_MR_PAR_NO| US_MR_USCLKS_MCK 
  4039ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4039f0:	f44f 620c 	mov.w	r2, #2240	; 0x8c0
  4039f4:	605a      	str	r2, [r3, #4]
					| US_MR_CHRL_8_BIT);

	// Enable receiver and transmitter
	pUsart->US_CR = US_CR_RXEN | US_CR_TXEN;
  4039f6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4039f8:	2250      	movs	r2, #80	; 0x50
  4039fa:	601a      	str	r2, [r3, #0]
#endif
	_ucIsConsoleInitialized = 1;
  4039fc:	4b0d      	ldr	r3, [pc, #52]	; (403a34 <DBG_Configure+0xb0>)
  4039fe:	2201      	movs	r2, #1
  403a00:	701a      	strb	r2, [r3, #0]

	/* Disable buffering for printf(). */
#if ( defined (__GNUC__) && !defined (__SAMBA__) )
	setvbuf(stdout, (char *)NULL, _IONBF, 0);
  403a02:	4b0d      	ldr	r3, [pc, #52]	; (403a38 <DBG_Configure+0xb4>)
  403a04:	681b      	ldr	r3, [r3, #0]
  403a06:	6898      	ldr	r0, [r3, #8]
  403a08:	2300      	movs	r3, #0
  403a0a:	2202      	movs	r2, #2
  403a0c:	2100      	movs	r1, #0
  403a0e:	4c0b      	ldr	r4, [pc, #44]	; (403a3c <DBG_Configure+0xb8>)
  403a10:	47a0      	blx	r4
#endif
}
  403a12:	bf00      	nop
  403a14:	3728      	adds	r7, #40	; 0x28
  403a16:	46bd      	mov	sp, r7
  403a18:	bdb0      	pop	{r4, r5, r7, pc}
  403a1a:	bf00      	nop
  403a1c:	0040abd8 	.word	0x0040abd8
  403a20:	40028000 	.word	0x40028000
  403a24:	40088000 	.word	0x40088000
  403a28:	4d415400 	.word	0x4d415400
  403a2c:	00403fa9 	.word	0x00403fa9
  403a30:	00404179 	.word	0x00404179
  403a34:	2040c439 	.word	0x2040c439
  403a38:	20400438 	.word	0x20400438
  403a3c:	00404f05 	.word	0x00404f05

00403a40 <DBG_PutChar>:
 *
 * \note This function is synchronous (i.e. uses polling).
 * \param c  Character to send.
 */
extern void DBG_PutChar( uint8_t c )
{
  403a40:	b580      	push	{r7, lr}
  403a42:	b084      	sub	sp, #16
  403a44:	af00      	add	r7, sp, #0
  403a46:	4603      	mov	r3, r0
  403a48:	71fb      	strb	r3, [r7, #7]
	// Wait for the transfer to complete
	while ((pUart->UART_SR & UART_SR_TXEMPTY) == 0);
#endif

#if defined CONSOLE_ON_USART
	Usart *pUsart=CONSOLE_Usart;
  403a4a:	4b10      	ldr	r3, [pc, #64]	; (403a8c <DBG_PutChar+0x4c>)
  403a4c:	60fb      	str	r3, [r7, #12]
	if ( !_ucIsConsoleInitialized )
  403a4e:	4b10      	ldr	r3, [pc, #64]	; (403a90 <DBG_PutChar+0x50>)
  403a50:	781b      	ldrb	r3, [r3, #0]
  403a52:	2b00      	cmp	r3, #0
  403a54:	d104      	bne.n	403a60 <DBG_PutChar+0x20>
	{
		DBG_Configure(CONSOLE_BAUDRATE, BOARD_MCK);
  403a56:	490f      	ldr	r1, [pc, #60]	; (403a94 <DBG_PutChar+0x54>)
  403a58:	f44f 30e1 	mov.w	r0, #115200	; 0x1c200
  403a5c:	4b0e      	ldr	r3, [pc, #56]	; (403a98 <DBG_PutChar+0x58>)
  403a5e:	4798      	blx	r3
	}
	// Wait for the transmitter to be ready
	while ((pUsart->US_CSR & US_CSR_TXEMPTY) == 0);
  403a60:	bf00      	nop
  403a62:	68fb      	ldr	r3, [r7, #12]
  403a64:	695b      	ldr	r3, [r3, #20]
  403a66:	f403 7300 	and.w	r3, r3, #512	; 0x200
  403a6a:	2b00      	cmp	r3, #0
  403a6c:	d0f9      	beq.n	403a62 <DBG_PutChar+0x22>

	// Send character
	pUsart->US_THR = c;
  403a6e:	79fa      	ldrb	r2, [r7, #7]
  403a70:	68fb      	ldr	r3, [r7, #12]
  403a72:	61da      	str	r2, [r3, #28]

	// Wait for the transfer to complete
	while ((pUsart->US_CSR & US_CSR_TXEMPTY) == 0);
  403a74:	bf00      	nop
  403a76:	68fb      	ldr	r3, [r7, #12]
  403a78:	695b      	ldr	r3, [r3, #20]
  403a7a:	f403 7300 	and.w	r3, r3, #512	; 0x200
  403a7e:	2b00      	cmp	r3, #0
  403a80:	d0f9      	beq.n	403a76 <DBG_PutChar+0x36>
#endif
}
  403a82:	bf00      	nop
  403a84:	3710      	adds	r7, #16
  403a86:	46bd      	mov	sp, r7
  403a88:	bd80      	pop	{r7, pc}
  403a8a:	bf00      	nop
  403a8c:	40028000 	.word	0x40028000
  403a90:	2040c439 	.word	0x2040c439
  403a94:	08f0d180 	.word	0x08f0d180
  403a98:	00403985 	.word	0x00403985

00403a9c <LED_Configure>:
 *  not exist on the board, the function does nothing.
 *  \param led  Number of the LED to configure.
 *  \return 1 if the LED exists and has been configured; otherwise 0.
 */
extern uint32_t LED_Configure( uint32_t dwLed )
{
  403a9c:	b580      	push	{r7, lr}
  403a9e:	b082      	sub	sp, #8
  403aa0:	af00      	add	r7, sp, #0
  403aa2:	6078      	str	r0, [r7, #4]
#ifdef PINS_LEDS
	// Check that LED exists
	if ( dwLed >= numLeds) {
  403aa4:	2202      	movs	r2, #2
  403aa6:	687b      	ldr	r3, [r7, #4]
  403aa8:	4293      	cmp	r3, r2
  403aaa:	d301      	bcc.n	403ab0 <LED_Configure+0x14>
		return 0;
  403aac:	2300      	movs	r3, #0
  403aae:	e00b      	b.n	403ac8 <LED_Configure+0x2c>
	}

	// Configure LED
	return ( PIO_Configure( &pinsLeds[dwLed], 1 ) );
  403ab0:	687a      	ldr	r2, [r7, #4]
  403ab2:	4613      	mov	r3, r2
  403ab4:	005b      	lsls	r3, r3, #1
  403ab6:	4413      	add	r3, r2
  403ab8:	009b      	lsls	r3, r3, #2
  403aba:	4a05      	ldr	r2, [pc, #20]	; (403ad0 <LED_Configure+0x34>)
  403abc:	4413      	add	r3, r2
  403abe:	2101      	movs	r1, #1
  403ac0:	4618      	mov	r0, r3
  403ac2:	4b04      	ldr	r3, [pc, #16]	; (403ad4 <LED_Configure+0x38>)
  403ac4:	4798      	blx	r3
  403ac6:	4603      	mov	r3, r0
#else
	return 0;
#endif
}
  403ac8:	4618      	mov	r0, r3
  403aca:	3708      	adds	r7, #8
  403acc:	46bd      	mov	sp, r7
  403ace:	bd80      	pop	{r7, pc}
  403ad0:	0040acd0 	.word	0x0040acd0
  403ad4:	00403fa9 	.word	0x00403fa9

00403ad8 <LED_Toggle>:
 *
 *  \param led  Number of the LED to toggle.
 *  \return 1 if the LED has been toggled; otherwise 0.
 */
extern uint32_t LED_Toggle( uint32_t dwLed )
{
  403ad8:	b580      	push	{r7, lr}
  403ada:	b082      	sub	sp, #8
  403adc:	af00      	add	r7, sp, #0
  403ade:	6078      	str	r0, [r7, #4]
#ifdef PINS_LEDS
	/* Check if LED exists */
	if ( dwLed >= numLeds ) {
  403ae0:	2202      	movs	r2, #2
  403ae2:	687b      	ldr	r3, [r7, #4]
  403ae4:	4293      	cmp	r3, r2
  403ae6:	d301      	bcc.n	403aec <LED_Toggle+0x14>
		return 0;
  403ae8:	2300      	movs	r3, #0
  403aea:	e022      	b.n	403b32 <LED_Toggle+0x5a>
	}

	/* Toggle LED */
	if ( PIO_GetOutputDataStatus( &pinsLeds[dwLed] ) ) {
  403aec:	687a      	ldr	r2, [r7, #4]
  403aee:	4613      	mov	r3, r2
  403af0:	005b      	lsls	r3, r3, #1
  403af2:	4413      	add	r3, r2
  403af4:	009b      	lsls	r3, r3, #2
  403af6:	4a11      	ldr	r2, [pc, #68]	; (403b3c <LED_Toggle+0x64>)
  403af8:	4413      	add	r3, r2
  403afa:	4618      	mov	r0, r3
  403afc:	4b10      	ldr	r3, [pc, #64]	; (403b40 <LED_Toggle+0x68>)
  403afe:	4798      	blx	r3
  403b00:	4603      	mov	r3, r0
  403b02:	2b00      	cmp	r3, #0
  403b04:	d00a      	beq.n	403b1c <LED_Toggle+0x44>
		PIO_Clear( &pinsLeds[dwLed] );
  403b06:	687a      	ldr	r2, [r7, #4]
  403b08:	4613      	mov	r3, r2
  403b0a:	005b      	lsls	r3, r3, #1
  403b0c:	4413      	add	r3, r2
  403b0e:	009b      	lsls	r3, r3, #2
  403b10:	4a0a      	ldr	r2, [pc, #40]	; (403b3c <LED_Toggle+0x64>)
  403b12:	4413      	add	r3, r2
  403b14:	4618      	mov	r0, r3
  403b16:	4b0b      	ldr	r3, [pc, #44]	; (403b44 <LED_Toggle+0x6c>)
  403b18:	4798      	blx	r3
  403b1a:	e009      	b.n	403b30 <LED_Toggle+0x58>
	} else {
		PIO_Set( &pinsLeds[dwLed] );
  403b1c:	687a      	ldr	r2, [r7, #4]
  403b1e:	4613      	mov	r3, r2
  403b20:	005b      	lsls	r3, r3, #1
  403b22:	4413      	add	r3, r2
  403b24:	009b      	lsls	r3, r3, #2
  403b26:	4a05      	ldr	r2, [pc, #20]	; (403b3c <LED_Toggle+0x64>)
  403b28:	4413      	add	r3, r2
  403b2a:	4618      	mov	r0, r3
  403b2c:	4b06      	ldr	r3, [pc, #24]	; (403b48 <LED_Toggle+0x70>)
  403b2e:	4798      	blx	r3
	}

	return 1;
  403b30:	2301      	movs	r3, #1
#else
	return 0;
#endif
}
  403b32:	4618      	mov	r0, r3
  403b34:	3708      	adds	r7, #8
  403b36:	46bd      	mov	sp, r7
  403b38:	bd80      	pop	{r7, pc}
  403b3a:	bf00      	nop
  403b3c:	0040acd0 	.word	0x0040acd0
  403b40:	0040414d 	.word	0x0040414d
  403b44:	0040412d 	.word	0x0040412d
  403b48:	0040410d 	.word	0x0040410d

00403b4c <_sbrk>:
extern void _exit( int status );
extern void _kill( int pid, int sig );
extern int _getpid ( void );

extern caddr_t _sbrk ( int incr )
{
  403b4c:	b480      	push	{r7}
  403b4e:	b085      	sub	sp, #20
  403b50:	af00      	add	r7, sp, #0
  403b52:	6078      	str	r0, [r7, #4]
	static unsigned char *heap = NULL;
	unsigned char *prev_sheap;

	if ( heap == NULL ) {
  403b54:	4b0b      	ldr	r3, [pc, #44]	; (403b84 <_sbrk+0x38>)
  403b56:	681b      	ldr	r3, [r3, #0]
  403b58:	2b00      	cmp	r3, #0
  403b5a:	d102      	bne.n	403b62 <_sbrk+0x16>
		heap = (unsigned char *)&_sheap;
  403b5c:	4b09      	ldr	r3, [pc, #36]	; (403b84 <_sbrk+0x38>)
  403b5e:	4a0a      	ldr	r2, [pc, #40]	; (403b88 <_sbrk+0x3c>)
  403b60:	601a      	str	r2, [r3, #0]
	}
	prev_sheap = heap;
  403b62:	4b08      	ldr	r3, [pc, #32]	; (403b84 <_sbrk+0x38>)
  403b64:	681b      	ldr	r3, [r3, #0]
  403b66:	60fb      	str	r3, [r7, #12]

	heap += incr;
  403b68:	4b06      	ldr	r3, [pc, #24]	; (403b84 <_sbrk+0x38>)
  403b6a:	681a      	ldr	r2, [r3, #0]
  403b6c:	687b      	ldr	r3, [r7, #4]
  403b6e:	4413      	add	r3, r2
  403b70:	4a04      	ldr	r2, [pc, #16]	; (403b84 <_sbrk+0x38>)
  403b72:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_sheap;
  403b74:	68fb      	ldr	r3, [r7, #12]
}
  403b76:	4618      	mov	r0, r3
  403b78:	3714      	adds	r7, #20
  403b7a:	46bd      	mov	sp, r7
  403b7c:	f85d 7b04 	ldr.w	r7, [sp], #4
  403b80:	4770      	bx	lr
  403b82:	bf00      	nop
  403b84:	2040c444 	.word	0x2040c444
  403b88:	2040e4c0 	.word	0x2040e4c0

00403b8c <_close>:
	( void ) new;
	return -1;
}

extern int _close( int file )
{
  403b8c:	b480      	push	{r7}
  403b8e:	b083      	sub	sp, #12
  403b90:	af00      	add	r7, sp, #0
  403b92:	6078      	str	r0, [r7, #4]
	( void ) file;
	return -1;
  403b94:	f04f 33ff 	mov.w	r3, #4294967295
}
  403b98:	4618      	mov	r0, r3
  403b9a:	370c      	adds	r7, #12
  403b9c:	46bd      	mov	sp, r7
  403b9e:	f85d 7b04 	ldr.w	r7, [sp], #4
  403ba2:	4770      	bx	lr

00403ba4 <_fstat>:

extern int _fstat( int file, struct stat *st )
{
  403ba4:	b480      	push	{r7}
  403ba6:	b083      	sub	sp, #12
  403ba8:	af00      	add	r7, sp, #0
  403baa:	6078      	str	r0, [r7, #4]
  403bac:	6039      	str	r1, [r7, #0]
	( void ) file;
	st->st_mode = S_IFCHR;
  403bae:	683b      	ldr	r3, [r7, #0]
  403bb0:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  403bb4:	605a      	str	r2, [r3, #4]

	return 0;
  403bb6:	2300      	movs	r3, #0
}
  403bb8:	4618      	mov	r0, r3
  403bba:	370c      	adds	r7, #12
  403bbc:	46bd      	mov	sp, r7
  403bbe:	f85d 7b04 	ldr.w	r7, [sp], #4
  403bc2:	4770      	bx	lr

00403bc4 <_isatty>:

extern int _isatty( int file )
{
  403bc4:	b480      	push	{r7}
  403bc6:	b083      	sub	sp, #12
  403bc8:	af00      	add	r7, sp, #0
  403bca:	6078      	str	r0, [r7, #4]
	( void ) file;
	return 1;
  403bcc:	2301      	movs	r3, #1
}
  403bce:	4618      	mov	r0, r3
  403bd0:	370c      	adds	r7, #12
  403bd2:	46bd      	mov	sp, r7
  403bd4:	f85d 7b04 	ldr.w	r7, [sp], #4
  403bd8:	4770      	bx	lr
  403bda:	bf00      	nop

00403bdc <_lseek>:

extern int _lseek( int file, int ptr, int dir )
{
  403bdc:	b480      	push	{r7}
  403bde:	b085      	sub	sp, #20
  403be0:	af00      	add	r7, sp, #0
  403be2:	60f8      	str	r0, [r7, #12]
  403be4:	60b9      	str	r1, [r7, #8]
  403be6:	607a      	str	r2, [r7, #4]
	( void ) file;
	( void ) ptr;
	( void ) dir;
	return 0;
  403be8:	2300      	movs	r3, #0
}
  403bea:	4618      	mov	r0, r3
  403bec:	3714      	adds	r7, #20
  403bee:	46bd      	mov	sp, r7
  403bf0:	f85d 7b04 	ldr.w	r7, [sp], #4
  403bf4:	4770      	bx	lr
  403bf6:	bf00      	nop

00403bf8 <_read>:

extern int _read(int file, char *ptr, int len)
{
  403bf8:	b480      	push	{r7}
  403bfa:	b085      	sub	sp, #20
  403bfc:	af00      	add	r7, sp, #0
  403bfe:	60f8      	str	r0, [r7, #12]
  403c00:	60b9      	str	r1, [r7, #8]
  403c02:	607a      	str	r2, [r7, #4]
	( void ) file;
	( void ) ptr;
	( void ) len;
	return 0;
  403c04:	2300      	movs	r3, #0
}
  403c06:	4618      	mov	r0, r3
  403c08:	3714      	adds	r7, #20
  403c0a:	46bd      	mov	sp, r7
  403c0c:	f85d 7b04 	ldr.w	r7, [sp], #4
  403c10:	4770      	bx	lr
  403c12:	bf00      	nop

00403c14 <_write>:

extern int _write( int file, char *ptr, int len )
{
  403c14:	b580      	push	{r7, lr}
  403c16:	b086      	sub	sp, #24
  403c18:	af00      	add	r7, sp, #0
  403c1a:	60f8      	str	r0, [r7, #12]
  403c1c:	60b9      	str	r1, [r7, #8]
  403c1e:	607a      	str	r2, [r7, #4]
	int iIndex;

	( void ) file;

	//    for (; *ptr != 0; ptr++ )
	for ( iIndex=0; iIndex < len; iIndex++, ptr++ ) {
  403c20:	2300      	movs	r3, #0
  403c22:	617b      	str	r3, [r7, #20]
  403c24:	e00a      	b.n	403c3c <_write+0x28>
		DBG_PutChar( *ptr );
  403c26:	68bb      	ldr	r3, [r7, #8]
  403c28:	781b      	ldrb	r3, [r3, #0]
  403c2a:	4618      	mov	r0, r3
  403c2c:	4b08      	ldr	r3, [pc, #32]	; (403c50 <_write+0x3c>)
  403c2e:	4798      	blx	r3
	int iIndex;

	( void ) file;

	//    for (; *ptr != 0; ptr++ )
	for ( iIndex=0; iIndex < len; iIndex++, ptr++ ) {
  403c30:	697b      	ldr	r3, [r7, #20]
  403c32:	3301      	adds	r3, #1
  403c34:	617b      	str	r3, [r7, #20]
  403c36:	68bb      	ldr	r3, [r7, #8]
  403c38:	3301      	adds	r3, #1
  403c3a:	60bb      	str	r3, [r7, #8]
  403c3c:	697a      	ldr	r2, [r7, #20]
  403c3e:	687b      	ldr	r3, [r7, #4]
  403c40:	429a      	cmp	r2, r3
  403c42:	dbf0      	blt.n	403c26 <_write+0x12>
		DBG_PutChar( *ptr );
	}

	return iIndex;
  403c44:	697b      	ldr	r3, [r7, #20]
}
  403c46:	4618      	mov	r0, r3
  403c48:	3718      	adds	r7, #24
  403c4a:	46bd      	mov	sp, r7
  403c4c:	bd80      	pop	{r7, pc}
  403c4e:	bf00      	nop
  403c50:	00403a41 	.word	0x00403a41

00403c54 <_exit>:

extern void _exit( int status )
{
  403c54:	b580      	push	{r7, lr}
  403c56:	b082      	sub	sp, #8
  403c58:	af00      	add	r7, sp, #0
  403c5a:	6078      	str	r0, [r7, #4]
	printf( "Exiting with status %d.\n", status );
  403c5c:	6879      	ldr	r1, [r7, #4]
  403c5e:	4802      	ldr	r0, [pc, #8]	; (403c68 <_exit+0x14>)
  403c60:	4b02      	ldr	r3, [pc, #8]	; (403c6c <_exit+0x18>)
  403c62:	4798      	blx	r3
	for (;;);
  403c64:	e7fe      	b.n	403c64 <_exit+0x10>
  403c66:	bf00      	nop
  403c68:	0040acec 	.word	0x0040acec
  403c6c:	00404edd 	.word	0x00404edd

00403c70 <_kill>:
}

extern void _kill( int pid, int sig )
{
  403c70:	b480      	push	{r7}
  403c72:	b083      	sub	sp, #12
  403c74:	af00      	add	r7, sp, #0
  403c76:	6078      	str	r0, [r7, #4]
  403c78:	6039      	str	r1, [r7, #0]
	( void ) pid;
	( void ) sig;
	return;
  403c7a:	bf00      	nop
}
  403c7c:	370c      	adds	r7, #12
  403c7e:	46bd      	mov	sp, r7
  403c80:	f85d 7b04 	ldr.w	r7, [sp], #4
  403c84:	4770      	bx	lr
  403c86:	bf00      	nop

00403c88 <_getpid>:

extern int _getpid ( void )
{
  403c88:	b480      	push	{r7}
  403c8a:	af00      	add	r7, sp, #0
	return -1;
  403c8c:	f04f 33ff 	mov.w	r3, #4294967295
}
  403c90:	4618      	mov	r0, r3
  403c92:	46bd      	mov	sp, r7
  403c94:	f85d 7b04 	ldr.w	r7, [sp], #4
  403c98:	4770      	bx	lr
  403c9a:	bf00      	nop

00403c9c <MPU_Enable>:
 * \brief Enables the MPU module.
 *
 * \param dwMPUEnable  Enable/Disable the memory region.
 */
void MPU_Enable( uint32_t dwMPUEnable )
{
  403c9c:	b480      	push	{r7}
  403c9e:	b083      	sub	sp, #12
  403ca0:	af00      	add	r7, sp, #0
  403ca2:	6078      	str	r0, [r7, #4]
	MPU->CTRL = dwMPUEnable ;
  403ca4:	4a04      	ldr	r2, [pc, #16]	; (403cb8 <MPU_Enable+0x1c>)
  403ca6:	687b      	ldr	r3, [r7, #4]
  403ca8:	6053      	str	r3, [r2, #4]
}
  403caa:	bf00      	nop
  403cac:	370c      	adds	r7, #12
  403cae:	46bd      	mov	sp, r7
  403cb0:	f85d 7b04 	ldr.w	r7, [sp], #4
  403cb4:	4770      	bx	lr
  403cb6:	bf00      	nop
  403cb8:	e000ed90 	.word	0xe000ed90

00403cbc <MPU_SetRegion>:
 *
 * \param dwRegionBaseAddr  Memory region base address.
 * \param dwRegionAttr  Memory region attributes.  
 */
void MPU_SetRegion( uint32_t dwRegionBaseAddr, uint32_t dwRegionAttr )
{
  403cbc:	b480      	push	{r7}
  403cbe:	b083      	sub	sp, #12
  403cc0:	af00      	add	r7, sp, #0
  403cc2:	6078      	str	r0, [r7, #4]
  403cc4:	6039      	str	r1, [r7, #0]
	MPU->RBAR = dwRegionBaseAddr;
  403cc6:	4a06      	ldr	r2, [pc, #24]	; (403ce0 <MPU_SetRegion+0x24>)
  403cc8:	687b      	ldr	r3, [r7, #4]
  403cca:	60d3      	str	r3, [r2, #12]
	MPU->RASR = dwRegionAttr;
  403ccc:	4a04      	ldr	r2, [pc, #16]	; (403ce0 <MPU_SetRegion+0x24>)
  403cce:	683b      	ldr	r3, [r7, #0]
  403cd0:	6113      	str	r3, [r2, #16]
}
  403cd2:	bf00      	nop
  403cd4:	370c      	adds	r7, #12
  403cd6:	46bd      	mov	sp, r7
  403cd8:	f85d 7b04 	ldr.w	r7, [sp], #4
  403cdc:	4770      	bx	lr
  403cde:	bf00      	nop
  403ce0:	e000ed90 	.word	0xe000ed90

00403ce4 <MPU_CalMPURegionSize>:

/**
 * \brief Calculate region size for the RASR.
 */
uint32_t MPU_CalMPURegionSize( uint32_t dwActualSizeInBytes )
{
  403ce4:	b480      	push	{r7}
  403ce6:	b085      	sub	sp, #20
  403ce8:	af00      	add	r7, sp, #0
  403cea:	6078      	str	r0, [r7, #4]
	uint32_t dwRegionSize = 32;
  403cec:	2320      	movs	r3, #32
  403cee:	60fb      	str	r3, [r7, #12]
	uint32_t dwReturnValue = 4;
  403cf0:	2304      	movs	r3, #4
  403cf2:	60bb      	str	r3, [r7, #8]

	while( dwReturnValue < 31 ) {
  403cf4:	e009      	b.n	403d0a <MPU_CalMPURegionSize+0x26>
		if( dwActualSizeInBytes <= dwRegionSize ) {
  403cf6:	687a      	ldr	r2, [r7, #4]
  403cf8:	68fb      	ldr	r3, [r7, #12]
  403cfa:	429a      	cmp	r2, r3
  403cfc:	d909      	bls.n	403d12 <MPU_CalMPURegionSize+0x2e>
			break;
		} else {
			dwReturnValue++;
  403cfe:	68bb      	ldr	r3, [r7, #8]
  403d00:	3301      	adds	r3, #1
  403d02:	60bb      	str	r3, [r7, #8]
		}
		dwRegionSize <<= 1;
  403d04:	68fb      	ldr	r3, [r7, #12]
  403d06:	005b      	lsls	r3, r3, #1
  403d08:	60fb      	str	r3, [r7, #12]
uint32_t MPU_CalMPURegionSize( uint32_t dwActualSizeInBytes )
{
	uint32_t dwRegionSize = 32;
	uint32_t dwReturnValue = 4;

	while( dwReturnValue < 31 ) {
  403d0a:	68bb      	ldr	r3, [r7, #8]
  403d0c:	2b1e      	cmp	r3, #30
  403d0e:	d9f2      	bls.n	403cf6 <MPU_CalMPURegionSize+0x12>
  403d10:	e000      	b.n	403d14 <MPU_CalMPURegionSize+0x30>
		if( dwActualSizeInBytes <= dwRegionSize ) {
			break;
  403d12:	bf00      	nop
			dwReturnValue++;
		}
		dwRegionSize <<= 1;
	}

	return ( dwReturnValue << 1 );
  403d14:	68bb      	ldr	r3, [r7, #8]
  403d16:	005b      	lsls	r3, r3, #1
}
  403d18:	4618      	mov	r0, r3
  403d1a:	3714      	adds	r7, #20
  403d1c:	46bd      	mov	sp, r7
  403d1e:	f85d 7b04 	ldr.w	r7, [sp], #4
  403d22:	4770      	bx	lr

00403d24 <PIO_SetPeripheralA>:
 */
static void PIO_SetPeripheralA(
		Pio *pio,
		unsigned int mask,
		unsigned char enablePullUp)
{
  403d24:	b480      	push	{r7}
  403d26:	b087      	sub	sp, #28
  403d28:	af00      	add	r7, sp, #0
  403d2a:	60f8      	str	r0, [r7, #12]
  403d2c:	60b9      	str	r1, [r7, #8]
  403d2e:	4613      	mov	r3, r2
  403d30:	71fb      	strb	r3, [r7, #7]
	unsigned int abcdsr;
	/* Disable interrupts on the pin(s) */
	pio->PIO_IDR = mask;
  403d32:	68fb      	ldr	r3, [r7, #12]
  403d34:	68ba      	ldr	r2, [r7, #8]
  403d36:	645a      	str	r2, [r3, #68]	; 0x44

	/* Enable the pull-up(s) if necessary */
	if (enablePullUp) {
  403d38:	79fb      	ldrb	r3, [r7, #7]
  403d3a:	2b00      	cmp	r3, #0
  403d3c:	d003      	beq.n	403d46 <PIO_SetPeripheralA+0x22>
		pio->PIO_PUER = mask;
  403d3e:	68fb      	ldr	r3, [r7, #12]
  403d40:	68ba      	ldr	r2, [r7, #8]
  403d42:	665a      	str	r2, [r3, #100]	; 0x64
  403d44:	e002      	b.n	403d4c <PIO_SetPeripheralA+0x28>
	} else {
		pio->PIO_PUDR = mask;
  403d46:	68fb      	ldr	r3, [r7, #12]
  403d48:	68ba      	ldr	r2, [r7, #8]
  403d4a:	661a      	str	r2, [r3, #96]	; 0x60
	}

	abcdsr = pio->PIO_ABCDSR[0];
  403d4c:	68fb      	ldr	r3, [r7, #12]
  403d4e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  403d50:	617b      	str	r3, [r7, #20]
	pio->PIO_ABCDSR[0] &= (~mask & abcdsr);
  403d52:	68fb      	ldr	r3, [r7, #12]
  403d54:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  403d56:	68bb      	ldr	r3, [r7, #8]
  403d58:	43d9      	mvns	r1, r3
  403d5a:	697b      	ldr	r3, [r7, #20]
  403d5c:	400b      	ands	r3, r1
  403d5e:	401a      	ands	r2, r3
  403d60:	68fb      	ldr	r3, [r7, #12]
  403d62:	671a      	str	r2, [r3, #112]	; 0x70
	abcdsr = pio->PIO_ABCDSR[1];
  403d64:	68fb      	ldr	r3, [r7, #12]
  403d66:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  403d68:	617b      	str	r3, [r7, #20]
	pio->PIO_ABCDSR[1] &= (~mask & abcdsr);
  403d6a:	68fb      	ldr	r3, [r7, #12]
  403d6c:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  403d6e:	68bb      	ldr	r3, [r7, #8]
  403d70:	43d9      	mvns	r1, r3
  403d72:	697b      	ldr	r3, [r7, #20]
  403d74:	400b      	ands	r3, r1
  403d76:	401a      	ands	r2, r3
  403d78:	68fb      	ldr	r3, [r7, #12]
  403d7a:	675a      	str	r2, [r3, #116]	; 0x74
	pio->PIO_PDR = mask;
  403d7c:	68fb      	ldr	r3, [r7, #12]
  403d7e:	68ba      	ldr	r2, [r7, #8]
  403d80:	605a      	str	r2, [r3, #4]
}
  403d82:	bf00      	nop
  403d84:	371c      	adds	r7, #28
  403d86:	46bd      	mov	sp, r7
  403d88:	f85d 7b04 	ldr.w	r7, [sp], #4
  403d8c:	4770      	bx	lr
  403d8e:	bf00      	nop

00403d90 <PIO_SetPeripheralB>:
 */
static void PIO_SetPeripheralB(
		Pio *pio,
		unsigned int mask,
		unsigned char enablePullUp)
{
  403d90:	b480      	push	{r7}
  403d92:	b087      	sub	sp, #28
  403d94:	af00      	add	r7, sp, #0
  403d96:	60f8      	str	r0, [r7, #12]
  403d98:	60b9      	str	r1, [r7, #8]
  403d9a:	4613      	mov	r3, r2
  403d9c:	71fb      	strb	r3, [r7, #7]
	unsigned int abcdsr;
	/* Disable interrupts on the pin(s) */
	pio->PIO_IDR = mask;
  403d9e:	68fb      	ldr	r3, [r7, #12]
  403da0:	68ba      	ldr	r2, [r7, #8]
  403da2:	645a      	str	r2, [r3, #68]	; 0x44

	/* Enable the pull-up(s) if necessary */
	if (enablePullUp) {
  403da4:	79fb      	ldrb	r3, [r7, #7]
  403da6:	2b00      	cmp	r3, #0
  403da8:	d003      	beq.n	403db2 <PIO_SetPeripheralB+0x22>
		pio->PIO_PUER = mask;
  403daa:	68fb      	ldr	r3, [r7, #12]
  403dac:	68ba      	ldr	r2, [r7, #8]
  403dae:	665a      	str	r2, [r3, #100]	; 0x64
  403db0:	e002      	b.n	403db8 <PIO_SetPeripheralB+0x28>
	} else {
		pio->PIO_PUDR = mask;
  403db2:	68fb      	ldr	r3, [r7, #12]
  403db4:	68ba      	ldr	r2, [r7, #8]
  403db6:	661a      	str	r2, [r3, #96]	; 0x60
	}

	abcdsr = pio->PIO_ABCDSR[0];
  403db8:	68fb      	ldr	r3, [r7, #12]
  403dba:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  403dbc:	617b      	str	r3, [r7, #20]
	pio->PIO_ABCDSR[0] = (mask | abcdsr);
  403dbe:	68ba      	ldr	r2, [r7, #8]
  403dc0:	697b      	ldr	r3, [r7, #20]
  403dc2:	431a      	orrs	r2, r3
  403dc4:	68fb      	ldr	r3, [r7, #12]
  403dc6:	671a      	str	r2, [r3, #112]	; 0x70
	abcdsr = pio->PIO_ABCDSR[1];
  403dc8:	68fb      	ldr	r3, [r7, #12]
  403dca:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  403dcc:	617b      	str	r3, [r7, #20]
	pio->PIO_ABCDSR[1] &= (~mask & abcdsr);
  403dce:	68fb      	ldr	r3, [r7, #12]
  403dd0:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  403dd2:	68bb      	ldr	r3, [r7, #8]
  403dd4:	43d9      	mvns	r1, r3
  403dd6:	697b      	ldr	r3, [r7, #20]
  403dd8:	400b      	ands	r3, r1
  403dda:	401a      	ands	r2, r3
  403ddc:	68fb      	ldr	r3, [r7, #12]
  403dde:	675a      	str	r2, [r3, #116]	; 0x74

	pio->PIO_PDR = mask;
  403de0:	68fb      	ldr	r3, [r7, #12]
  403de2:	68ba      	ldr	r2, [r7, #8]
  403de4:	605a      	str	r2, [r3, #4]
}
  403de6:	bf00      	nop
  403de8:	371c      	adds	r7, #28
  403dea:	46bd      	mov	sp, r7
  403dec:	f85d 7b04 	ldr.w	r7, [sp], #4
  403df0:	4770      	bx	lr
  403df2:	bf00      	nop

00403df4 <PIO_SetPeripheralC>:
 */
static void PIO_SetPeripheralC(
		Pio *pio,
		unsigned int mask,
		unsigned char enablePullUp)
{
  403df4:	b480      	push	{r7}
  403df6:	b087      	sub	sp, #28
  403df8:	af00      	add	r7, sp, #0
  403dfa:	60f8      	str	r0, [r7, #12]
  403dfc:	60b9      	str	r1, [r7, #8]
  403dfe:	4613      	mov	r3, r2
  403e00:	71fb      	strb	r3, [r7, #7]
	unsigned int abcdsr;
	/* Disable interrupts on the pin(s) */
	pio->PIO_IDR = mask;
  403e02:	68fb      	ldr	r3, [r7, #12]
  403e04:	68ba      	ldr	r2, [r7, #8]
  403e06:	645a      	str	r2, [r3, #68]	; 0x44

	/* Enable the pull-up(s) if necessary */
	if (enablePullUp) {
  403e08:	79fb      	ldrb	r3, [r7, #7]
  403e0a:	2b00      	cmp	r3, #0
  403e0c:	d003      	beq.n	403e16 <PIO_SetPeripheralC+0x22>
		pio->PIO_PUER = mask;
  403e0e:	68fb      	ldr	r3, [r7, #12]
  403e10:	68ba      	ldr	r2, [r7, #8]
  403e12:	665a      	str	r2, [r3, #100]	; 0x64
  403e14:	e002      	b.n	403e1c <PIO_SetPeripheralC+0x28>
	} else {
		pio->PIO_PUDR = mask;
  403e16:	68fb      	ldr	r3, [r7, #12]
  403e18:	68ba      	ldr	r2, [r7, #8]
  403e1a:	661a      	str	r2, [r3, #96]	; 0x60
	}

	abcdsr = pio->PIO_ABCDSR[0];
  403e1c:	68fb      	ldr	r3, [r7, #12]
  403e1e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  403e20:	617b      	str	r3, [r7, #20]
	pio->PIO_ABCDSR[0] &= (~mask & abcdsr);
  403e22:	68fb      	ldr	r3, [r7, #12]
  403e24:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  403e26:	68bb      	ldr	r3, [r7, #8]
  403e28:	43d9      	mvns	r1, r3
  403e2a:	697b      	ldr	r3, [r7, #20]
  403e2c:	400b      	ands	r3, r1
  403e2e:	401a      	ands	r2, r3
  403e30:	68fb      	ldr	r3, [r7, #12]
  403e32:	671a      	str	r2, [r3, #112]	; 0x70
	abcdsr = pio->PIO_ABCDSR[1];
  403e34:	68fb      	ldr	r3, [r7, #12]
  403e36:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  403e38:	617b      	str	r3, [r7, #20]
	pio->PIO_ABCDSR[1] = (mask | abcdsr);
  403e3a:	68ba      	ldr	r2, [r7, #8]
  403e3c:	697b      	ldr	r3, [r7, #20]
  403e3e:	431a      	orrs	r2, r3
  403e40:	68fb      	ldr	r3, [r7, #12]
  403e42:	675a      	str	r2, [r3, #116]	; 0x74

	pio->PIO_PDR = mask;
  403e44:	68fb      	ldr	r3, [r7, #12]
  403e46:	68ba      	ldr	r2, [r7, #8]
  403e48:	605a      	str	r2, [r3, #4]
}
  403e4a:	bf00      	nop
  403e4c:	371c      	adds	r7, #28
  403e4e:	46bd      	mov	sp, r7
  403e50:	f85d 7b04 	ldr.w	r7, [sp], #4
  403e54:	4770      	bx	lr
  403e56:	bf00      	nop

00403e58 <PIO_SetPeripheralD>:
 */
static void PIO_SetPeripheralD(
		Pio *pio,
		unsigned int mask,
		unsigned char enablePullUp)
{
  403e58:	b480      	push	{r7}
  403e5a:	b087      	sub	sp, #28
  403e5c:	af00      	add	r7, sp, #0
  403e5e:	60f8      	str	r0, [r7, #12]
  403e60:	60b9      	str	r1, [r7, #8]
  403e62:	4613      	mov	r3, r2
  403e64:	71fb      	strb	r3, [r7, #7]
	unsigned int abcdsr;
	/* Disable interrupts on the pin(s) */
	pio->PIO_IDR = mask;
  403e66:	68fb      	ldr	r3, [r7, #12]
  403e68:	68ba      	ldr	r2, [r7, #8]
  403e6a:	645a      	str	r2, [r3, #68]	; 0x44

	/* Enable the pull-up(s) if necessary */
	if (enablePullUp) {
  403e6c:	79fb      	ldrb	r3, [r7, #7]
  403e6e:	2b00      	cmp	r3, #0
  403e70:	d003      	beq.n	403e7a <PIO_SetPeripheralD+0x22>
		pio->PIO_PUER = mask;
  403e72:	68fb      	ldr	r3, [r7, #12]
  403e74:	68ba      	ldr	r2, [r7, #8]
  403e76:	665a      	str	r2, [r3, #100]	; 0x64
  403e78:	e002      	b.n	403e80 <PIO_SetPeripheralD+0x28>
	} else {
		pio->PIO_PUDR = mask;
  403e7a:	68fb      	ldr	r3, [r7, #12]
  403e7c:	68ba      	ldr	r2, [r7, #8]
  403e7e:	661a      	str	r2, [r3, #96]	; 0x60
	}

	abcdsr = pio->PIO_ABCDSR[0];
  403e80:	68fb      	ldr	r3, [r7, #12]
  403e82:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  403e84:	617b      	str	r3, [r7, #20]
	pio->PIO_ABCDSR[0] = (mask | abcdsr);
  403e86:	68ba      	ldr	r2, [r7, #8]
  403e88:	697b      	ldr	r3, [r7, #20]
  403e8a:	431a      	orrs	r2, r3
  403e8c:	68fb      	ldr	r3, [r7, #12]
  403e8e:	671a      	str	r2, [r3, #112]	; 0x70
	abcdsr = pio->PIO_ABCDSR[1];
  403e90:	68fb      	ldr	r3, [r7, #12]
  403e92:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  403e94:	617b      	str	r3, [r7, #20]
	pio->PIO_ABCDSR[1] = (mask | abcdsr);
  403e96:	68ba      	ldr	r2, [r7, #8]
  403e98:	697b      	ldr	r3, [r7, #20]
  403e9a:	431a      	orrs	r2, r3
  403e9c:	68fb      	ldr	r3, [r7, #12]
  403e9e:	675a      	str	r2, [r3, #116]	; 0x74

	pio->PIO_PDR = mask;
  403ea0:	68fb      	ldr	r3, [r7, #12]
  403ea2:	68ba      	ldr	r2, [r7, #8]
  403ea4:	605a      	str	r2, [r3, #4]
}
  403ea6:	bf00      	nop
  403ea8:	371c      	adds	r7, #28
  403eaa:	46bd      	mov	sp, r7
  403eac:	f85d 7b04 	ldr.w	r7, [sp], #4
  403eb0:	4770      	bx	lr
  403eb2:	bf00      	nop

00403eb4 <PIO_SetInput>:
 */
static void PIO_SetInput(
		Pio *pio,
		unsigned int mask,
		unsigned char attribute)
{
  403eb4:	b480      	push	{r7}
  403eb6:	b085      	sub	sp, #20
  403eb8:	af00      	add	r7, sp, #0
  403eba:	60f8      	str	r0, [r7, #12]
  403ebc:	60b9      	str	r1, [r7, #8]
  403ebe:	4613      	mov	r3, r2
  403ec0:	71fb      	strb	r3, [r7, #7]
	/* Disable interrupts */
	pio->PIO_IDR = mask;
  403ec2:	68fb      	ldr	r3, [r7, #12]
  403ec4:	68ba      	ldr	r2, [r7, #8]
  403ec6:	645a      	str	r2, [r3, #68]	; 0x44

	/* Enable pull-up(s) if necessary */
	if (attribute & PIO_PULLUP)
  403ec8:	79fb      	ldrb	r3, [r7, #7]
  403eca:	f003 0301 	and.w	r3, r3, #1
  403ece:	2b00      	cmp	r3, #0
  403ed0:	d003      	beq.n	403eda <PIO_SetInput+0x26>
		pio->PIO_PUER = mask;
  403ed2:	68fb      	ldr	r3, [r7, #12]
  403ed4:	68ba      	ldr	r2, [r7, #8]
  403ed6:	665a      	str	r2, [r3, #100]	; 0x64
  403ed8:	e002      	b.n	403ee0 <PIO_SetInput+0x2c>
	else
		pio->PIO_PUDR = mask;
  403eda:	68fb      	ldr	r3, [r7, #12]
  403edc:	68ba      	ldr	r2, [r7, #8]
  403ede:	661a      	str	r2, [r3, #96]	; 0x60

	/* Enable Input Filter if necessary */
	if (attribute & (PIO_DEGLITCH | PIO_DEBOUNCE))
  403ee0:	79fb      	ldrb	r3, [r7, #7]
  403ee2:	f003 030a 	and.w	r3, r3, #10
  403ee6:	2b00      	cmp	r3, #0
  403ee8:	d003      	beq.n	403ef2 <PIO_SetInput+0x3e>
		pio->PIO_IFER = mask;
  403eea:	68fb      	ldr	r3, [r7, #12]
  403eec:	68ba      	ldr	r2, [r7, #8]
  403eee:	621a      	str	r2, [r3, #32]
  403ef0:	e002      	b.n	403ef8 <PIO_SetInput+0x44>
	else
		pio->PIO_IFDR = mask;
  403ef2:	68fb      	ldr	r3, [r7, #12]
  403ef4:	68ba      	ldr	r2, [r7, #8]
  403ef6:	625a      	str	r2, [r3, #36]	; 0x24

	/* Enable de-glitch or de-bounce if necessary */
	if (attribute & PIO_DEGLITCH) {
  403ef8:	79fb      	ldrb	r3, [r7, #7]
  403efa:	f003 0302 	and.w	r3, r3, #2
  403efe:	2b00      	cmp	r3, #0
  403f00:	d004      	beq.n	403f0c <PIO_SetInput+0x58>
		pio->PIO_IFSCDR = mask;
  403f02:	68fb      	ldr	r3, [r7, #12]
  403f04:	68ba      	ldr	r2, [r7, #8]
  403f06:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  403f0a:	e008      	b.n	403f1e <PIO_SetInput+0x6a>
	} else {
		if (attribute & PIO_DEBOUNCE) {
  403f0c:	79fb      	ldrb	r3, [r7, #7]
  403f0e:	f003 0308 	and.w	r3, r3, #8
  403f12:	2b00      	cmp	r3, #0
  403f14:	d003      	beq.n	403f1e <PIO_SetInput+0x6a>
			pio->PIO_IFSCER = mask;
  403f16:	68fb      	ldr	r3, [r7, #12]
  403f18:	68ba      	ldr	r2, [r7, #8]
  403f1a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
		}
	}
	/* Configure pin as input */
	pio->PIO_ODR = mask;
  403f1e:	68fb      	ldr	r3, [r7, #12]
  403f20:	68ba      	ldr	r2, [r7, #8]
  403f22:	615a      	str	r2, [r3, #20]
	pio->PIO_PER = mask;
  403f24:	68fb      	ldr	r3, [r7, #12]
  403f26:	68ba      	ldr	r2, [r7, #8]
  403f28:	601a      	str	r2, [r3, #0]
}
  403f2a:	bf00      	nop
  403f2c:	3714      	adds	r7, #20
  403f2e:	46bd      	mov	sp, r7
  403f30:	f85d 7b04 	ldr.w	r7, [sp], #4
  403f34:	4770      	bx	lr
  403f36:	bf00      	nop

00403f38 <PIO_SetOutput>:
		Pio *pio,
		unsigned int mask,
		unsigned char defaultValue,
		unsigned char enableMultiDrive,
		unsigned char enablePullUp)
{
  403f38:	b480      	push	{r7}
  403f3a:	b085      	sub	sp, #20
  403f3c:	af00      	add	r7, sp, #0
  403f3e:	60f8      	str	r0, [r7, #12]
  403f40:	60b9      	str	r1, [r7, #8]
  403f42:	4611      	mov	r1, r2
  403f44:	461a      	mov	r2, r3
  403f46:	460b      	mov	r3, r1
  403f48:	71fb      	strb	r3, [r7, #7]
  403f4a:	4613      	mov	r3, r2
  403f4c:	71bb      	strb	r3, [r7, #6]
	/* Disable interrupts */
	pio->PIO_IDR = mask;
  403f4e:	68fb      	ldr	r3, [r7, #12]
  403f50:	68ba      	ldr	r2, [r7, #8]
  403f52:	645a      	str	r2, [r3, #68]	; 0x44

	/* Enable pull-up(s) if necessary */
	if (enablePullUp) {
  403f54:	7e3b      	ldrb	r3, [r7, #24]
  403f56:	2b00      	cmp	r3, #0
  403f58:	d003      	beq.n	403f62 <PIO_SetOutput+0x2a>
		pio->PIO_PUER = mask;
  403f5a:	68fb      	ldr	r3, [r7, #12]
  403f5c:	68ba      	ldr	r2, [r7, #8]
  403f5e:	665a      	str	r2, [r3, #100]	; 0x64
  403f60:	e002      	b.n	403f68 <PIO_SetOutput+0x30>
	} else {
		pio->PIO_PUDR = mask;
  403f62:	68fb      	ldr	r3, [r7, #12]
  403f64:	68ba      	ldr	r2, [r7, #8]
  403f66:	661a      	str	r2, [r3, #96]	; 0x60
	}

	/* Enable multi-drive if necessary */
	if (enableMultiDrive) {
  403f68:	79bb      	ldrb	r3, [r7, #6]
  403f6a:	2b00      	cmp	r3, #0
  403f6c:	d003      	beq.n	403f76 <PIO_SetOutput+0x3e>
		pio->PIO_MDER = mask;
  403f6e:	68fb      	ldr	r3, [r7, #12]
  403f70:	68ba      	ldr	r2, [r7, #8]
  403f72:	651a      	str	r2, [r3, #80]	; 0x50
  403f74:	e002      	b.n	403f7c <PIO_SetOutput+0x44>
	} else {
		pio->PIO_MDDR = mask;
  403f76:	68fb      	ldr	r3, [r7, #12]
  403f78:	68ba      	ldr	r2, [r7, #8]
  403f7a:	655a      	str	r2, [r3, #84]	; 0x54
	}

	/* Set default value */
	if (defaultValue) {
  403f7c:	79fb      	ldrb	r3, [r7, #7]
  403f7e:	2b00      	cmp	r3, #0
  403f80:	d003      	beq.n	403f8a <PIO_SetOutput+0x52>
		pio->PIO_SODR = mask;
  403f82:	68fb      	ldr	r3, [r7, #12]
  403f84:	68ba      	ldr	r2, [r7, #8]
  403f86:	631a      	str	r2, [r3, #48]	; 0x30
  403f88:	e002      	b.n	403f90 <PIO_SetOutput+0x58>
	} else {
		pio->PIO_CODR = mask;
  403f8a:	68fb      	ldr	r3, [r7, #12]
  403f8c:	68ba      	ldr	r2, [r7, #8]
  403f8e:	635a      	str	r2, [r3, #52]	; 0x34
	}
	/* Configure pin(s) as output(s) */
	pio->PIO_OER = mask;
  403f90:	68fb      	ldr	r3, [r7, #12]
  403f92:	68ba      	ldr	r2, [r7, #8]
  403f94:	611a      	str	r2, [r3, #16]
	pio->PIO_PER = mask;
  403f96:	68fb      	ldr	r3, [r7, #12]
  403f98:	68ba      	ldr	r2, [r7, #8]
  403f9a:	601a      	str	r2, [r3, #0]
}
  403f9c:	bf00      	nop
  403f9e:	3714      	adds	r7, #20
  403fa0:	46bd      	mov	sp, r7
  403fa2:	f85d 7b04 	ldr.w	r7, [sp], #4
  403fa6:	4770      	bx	lr

00403fa8 <PIO_Configure>:
 * \param size  Size of the Pin list (calculated using PIO_LISTSIZE).
 *
 * \return 1 if the pins have been configured properly; otherwise 0.
 */
uint8_t PIO_Configure( const Pin *list, uint32_t size )
{
  403fa8:	b590      	push	{r4, r7, lr}
  403faa:	b085      	sub	sp, #20
  403fac:	af02      	add	r7, sp, #8
  403fae:	6078      	str	r0, [r7, #4]
  403fb0:	6039      	str	r1, [r7, #0]
	/* Configure pins */
	while ( size > 0 ) {
  403fb2:	e094      	b.n	4040de <PIO_Configure+0x136>
		switch ( list->type ) {
  403fb4:	687b      	ldr	r3, [r7, #4]
  403fb6:	7a5b      	ldrb	r3, [r3, #9]
  403fb8:	2b06      	cmp	r3, #6
  403fba:	f200 8088 	bhi.w	4040ce <PIO_Configure+0x126>
  403fbe:	a201      	add	r2, pc, #4	; (adr r2, 403fc4 <PIO_Configure+0x1c>)
  403fc0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  403fc4:	00403fe1 	.word	0x00403fe1
  403fc8:	00404003 	.word	0x00404003
  403fcc:	00404025 	.word	0x00404025
  403fd0:	00404047 	.word	0x00404047
  403fd4:	00404069 	.word	0x00404069
  403fd8:	00404087 	.word	0x00404087
  403fdc:	00404087 	.word	0x00404087
		case PIO_PERIPH_A:
			PIO_SetPeripheralA(list->pio,
  403fe0:	687b      	ldr	r3, [r7, #4]
  403fe2:	6858      	ldr	r0, [r3, #4]
					list->mask,
  403fe4:	687b      	ldr	r3, [r7, #4]
  403fe6:	6819      	ldr	r1, [r3, #0]
					(list->attribute & PIO_PULLUP) ? 1 : 0);
  403fe8:	687b      	ldr	r3, [r7, #4]
  403fea:	7a9b      	ldrb	r3, [r3, #10]
  403fec:	f003 0301 	and.w	r3, r3, #1
{
	/* Configure pins */
	while ( size > 0 ) {
		switch ( list->type ) {
		case PIO_PERIPH_A:
			PIO_SetPeripheralA(list->pio,
  403ff0:	2b00      	cmp	r3, #0
  403ff2:	bf14      	ite	ne
  403ff4:	2301      	movne	r3, #1
  403ff6:	2300      	moveq	r3, #0
  403ff8:	b2db      	uxtb	r3, r3
  403ffa:	461a      	mov	r2, r3
  403ffc:	4b3c      	ldr	r3, [pc, #240]	; (4040f0 <PIO_Configure+0x148>)
  403ffe:	4798      	blx	r3
					list->mask,
					(list->attribute & PIO_PULLUP) ? 1 : 0);
			break;
  404000:	e067      	b.n	4040d2 <PIO_Configure+0x12a>

		case PIO_PERIPH_B:
			PIO_SetPeripheralB(list->pio,
  404002:	687b      	ldr	r3, [r7, #4]
  404004:	6858      	ldr	r0, [r3, #4]
						list->mask,
  404006:	687b      	ldr	r3, [r7, #4]
  404008:	6819      	ldr	r1, [r3, #0]
						(list->attribute & PIO_PULLUP) ? 1 : 0);
  40400a:	687b      	ldr	r3, [r7, #4]
  40400c:	7a9b      	ldrb	r3, [r3, #10]
  40400e:	f003 0301 	and.w	r3, r3, #1
					list->mask,
					(list->attribute & PIO_PULLUP) ? 1 : 0);
			break;

		case PIO_PERIPH_B:
			PIO_SetPeripheralB(list->pio,
  404012:	2b00      	cmp	r3, #0
  404014:	bf14      	ite	ne
  404016:	2301      	movne	r3, #1
  404018:	2300      	moveq	r3, #0
  40401a:	b2db      	uxtb	r3, r3
  40401c:	461a      	mov	r2, r3
  40401e:	4b35      	ldr	r3, [pc, #212]	; (4040f4 <PIO_Configure+0x14c>)
  404020:	4798      	blx	r3
						list->mask,
						(list->attribute & PIO_PULLUP) ? 1 : 0);
			break;
  404022:	e056      	b.n	4040d2 <PIO_Configure+0x12a>

		case PIO_PERIPH_C:
			PIO_SetPeripheralC(list->pio,
  404024:	687b      	ldr	r3, [r7, #4]
  404026:	6858      	ldr	r0, [r3, #4]
						list->mask,
  404028:	687b      	ldr	r3, [r7, #4]
  40402a:	6819      	ldr	r1, [r3, #0]
						(list->attribute & PIO_PULLUP) ? 1 : 0);
  40402c:	687b      	ldr	r3, [r7, #4]
  40402e:	7a9b      	ldrb	r3, [r3, #10]
  404030:	f003 0301 	and.w	r3, r3, #1
						list->mask,
						(list->attribute & PIO_PULLUP) ? 1 : 0);
			break;

		case PIO_PERIPH_C:
			PIO_SetPeripheralC(list->pio,
  404034:	2b00      	cmp	r3, #0
  404036:	bf14      	ite	ne
  404038:	2301      	movne	r3, #1
  40403a:	2300      	moveq	r3, #0
  40403c:	b2db      	uxtb	r3, r3
  40403e:	461a      	mov	r2, r3
  404040:	4b2d      	ldr	r3, [pc, #180]	; (4040f8 <PIO_Configure+0x150>)
  404042:	4798      	blx	r3
						list->mask,
						(list->attribute & PIO_PULLUP) ? 1 : 0);
			break;
  404044:	e045      	b.n	4040d2 <PIO_Configure+0x12a>

		case PIO_PERIPH_D:
				PIO_SetPeripheralD(list->pio,
  404046:	687b      	ldr	r3, [r7, #4]
  404048:	6858      	ldr	r0, [r3, #4]
									list->mask,
  40404a:	687b      	ldr	r3, [r7, #4]
  40404c:	6819      	ldr	r1, [r3, #0]
									(list->attribute & PIO_PULLUP) ? 1 : 0);
  40404e:	687b      	ldr	r3, [r7, #4]
  404050:	7a9b      	ldrb	r3, [r3, #10]
  404052:	f003 0301 	and.w	r3, r3, #1
						list->mask,
						(list->attribute & PIO_PULLUP) ? 1 : 0);
			break;

		case PIO_PERIPH_D:
				PIO_SetPeripheralD(list->pio,
  404056:	2b00      	cmp	r3, #0
  404058:	bf14      	ite	ne
  40405a:	2301      	movne	r3, #1
  40405c:	2300      	moveq	r3, #0
  40405e:	b2db      	uxtb	r3, r3
  404060:	461a      	mov	r2, r3
  404062:	4b26      	ldr	r3, [pc, #152]	; (4040fc <PIO_Configure+0x154>)
  404064:	4798      	blx	r3
									list->mask,
									(list->attribute & PIO_PULLUP) ? 1 : 0);
				break;
  404066:	e034      	b.n	4040d2 <PIO_Configure+0x12a>
		case PIO_INPUT:
#ifndef __FPGA
			PMC_EnablePeripheral(list->id);
  404068:	687b      	ldr	r3, [r7, #4]
  40406a:	7a1b      	ldrb	r3, [r3, #8]
  40406c:	4618      	mov	r0, r3
  40406e:	4b24      	ldr	r3, [pc, #144]	; (404100 <PIO_Configure+0x158>)
  404070:	4798      	blx	r3
#endif
			PIO_SetInput(list->pio,
  404072:	687b      	ldr	r3, [r7, #4]
  404074:	6858      	ldr	r0, [r3, #4]
						list->mask,
  404076:	687b      	ldr	r3, [r7, #4]
  404078:	6819      	ldr	r1, [r3, #0]
				break;
		case PIO_INPUT:
#ifndef __FPGA
			PMC_EnablePeripheral(list->id);
#endif
			PIO_SetInput(list->pio,
  40407a:	687b      	ldr	r3, [r7, #4]
  40407c:	7a9b      	ldrb	r3, [r3, #10]
  40407e:	461a      	mov	r2, r3
  404080:	4b20      	ldr	r3, [pc, #128]	; (404104 <PIO_Configure+0x15c>)
  404082:	4798      	blx	r3
						list->mask,
						list->attribute);
				break;
  404084:	e025      	b.n	4040d2 <PIO_Configure+0x12a>

		case PIO_OUTPUT_0:
		case PIO_OUTPUT_1:
			PIO_SetOutput(list->pio,
  404086:	687b      	ldr	r3, [r7, #4]
  404088:	6858      	ldr	r0, [r3, #4]
						list->mask,
  40408a:	687b      	ldr	r3, [r7, #4]
  40408c:	6819      	ldr	r1, [r3, #0]
						(list->type == PIO_OUTPUT_1),
  40408e:	687b      	ldr	r3, [r7, #4]
  404090:	7a5b      	ldrb	r3, [r3, #9]
						list->attribute);
				break;

		case PIO_OUTPUT_0:
		case PIO_OUTPUT_1:
			PIO_SetOutput(list->pio,
  404092:	2b06      	cmp	r3, #6
  404094:	bf0c      	ite	eq
  404096:	2301      	moveq	r3, #1
  404098:	2300      	movne	r3, #0
  40409a:	b2db      	uxtb	r3, r3
  40409c:	461a      	mov	r2, r3
						list->mask,
						(list->type == PIO_OUTPUT_1),
						(list->attribute & PIO_OPENDRAIN) ? 1 : 0,
  40409e:	687b      	ldr	r3, [r7, #4]
  4040a0:	7a9b      	ldrb	r3, [r3, #10]
  4040a2:	f003 0304 	and.w	r3, r3, #4
						list->attribute);
				break;

		case PIO_OUTPUT_0:
		case PIO_OUTPUT_1:
			PIO_SetOutput(list->pio,
  4040a6:	2b00      	cmp	r3, #0
  4040a8:	bf14      	ite	ne
  4040aa:	2301      	movne	r3, #1
  4040ac:	2300      	moveq	r3, #0
  4040ae:	b2db      	uxtb	r3, r3
  4040b0:	461c      	mov	r4, r3
						list->mask,
						(list->type == PIO_OUTPUT_1),
						(list->attribute & PIO_OPENDRAIN) ? 1 : 0,
						(list->attribute & PIO_PULLUP) ? 1 : 0);
  4040b2:	687b      	ldr	r3, [r7, #4]
  4040b4:	7a9b      	ldrb	r3, [r3, #10]
  4040b6:	f003 0301 	and.w	r3, r3, #1
						list->attribute);
				break;

		case PIO_OUTPUT_0:
		case PIO_OUTPUT_1:
			PIO_SetOutput(list->pio,
  4040ba:	2b00      	cmp	r3, #0
  4040bc:	bf14      	ite	ne
  4040be:	2301      	movne	r3, #1
  4040c0:	2300      	moveq	r3, #0
  4040c2:	b2db      	uxtb	r3, r3
  4040c4:	9300      	str	r3, [sp, #0]
  4040c6:	4623      	mov	r3, r4
  4040c8:	4c0f      	ldr	r4, [pc, #60]	; (404108 <PIO_Configure+0x160>)
  4040ca:	47a0      	blx	r4
						list->mask,
						(list->type == PIO_OUTPUT_1),
						(list->attribute & PIO_OPENDRAIN) ? 1 : 0,
						(list->attribute & PIO_PULLUP) ? 1 : 0);
			break;
  4040cc:	e001      	b.n	4040d2 <PIO_Configure+0x12a>

		default: return 0;
  4040ce:	2300      	movs	r3, #0
  4040d0:	e00a      	b.n	4040e8 <PIO_Configure+0x140>
		}
		list++;
  4040d2:	687b      	ldr	r3, [r7, #4]
  4040d4:	330c      	adds	r3, #12
  4040d6:	607b      	str	r3, [r7, #4]
		size--;
  4040d8:	683b      	ldr	r3, [r7, #0]
  4040da:	3b01      	subs	r3, #1
  4040dc:	603b      	str	r3, [r7, #0]
 * \return 1 if the pins have been configured properly; otherwise 0.
 */
uint8_t PIO_Configure( const Pin *list, uint32_t size )
{
	/* Configure pins */
	while ( size > 0 ) {
  4040de:	683b      	ldr	r3, [r7, #0]
  4040e0:	2b00      	cmp	r3, #0
  4040e2:	f47f af67 	bne.w	403fb4 <PIO_Configure+0xc>
		default: return 0;
		}
		list++;
		size--;
	}
	return 1;
  4040e6:	2301      	movs	r3, #1
}
  4040e8:	4618      	mov	r0, r3
  4040ea:	370c      	adds	r7, #12
  4040ec:	46bd      	mov	sp, r7
  4040ee:	bd90      	pop	{r4, r7, pc}
  4040f0:	00403d25 	.word	0x00403d25
  4040f4:	00403d91 	.word	0x00403d91
  4040f8:	00403df5 	.word	0x00403df5
  4040fc:	00403e59 	.word	0x00403e59
  404100:	00404179 	.word	0x00404179
  404104:	00403eb5 	.word	0x00403eb5
  404108:	00403f39 	.word	0x00403f39

0040410c <PIO_Set>:
 * controller will memorize the value they are changed to outputs.
 *
 * \param pin  Pointer to a Pin instance describing one or more pins.
 */
void PIO_Set(const Pin *pin)
{
  40410c:	b480      	push	{r7}
  40410e:	b083      	sub	sp, #12
  404110:	af00      	add	r7, sp, #0
  404112:	6078      	str	r0, [r7, #4]
	pin->pio->PIO_SODR = pin->mask;
  404114:	687b      	ldr	r3, [r7, #4]
  404116:	685b      	ldr	r3, [r3, #4]
  404118:	687a      	ldr	r2, [r7, #4]
  40411a:	6812      	ldr	r2, [r2, #0]
  40411c:	631a      	str	r2, [r3, #48]	; 0x30
}
  40411e:	bf00      	nop
  404120:	370c      	adds	r7, #12
  404122:	46bd      	mov	sp, r7
  404124:	f85d 7b04 	ldr.w	r7, [sp], #4
  404128:	4770      	bx	lr
  40412a:	bf00      	nop

0040412c <PIO_Clear>:
 * controller will memorize the value they are changed to outputs.
 *
 * \param pin  Pointer to a Pin instance describing one or more pins.
 */
void PIO_Clear(const Pin *pin)
{
  40412c:	b480      	push	{r7}
  40412e:	b083      	sub	sp, #12
  404130:	af00      	add	r7, sp, #0
  404132:	6078      	str	r0, [r7, #4]
	pin->pio->PIO_CODR = pin->mask;
  404134:	687b      	ldr	r3, [r7, #4]
  404136:	685b      	ldr	r3, [r3, #4]
  404138:	687a      	ldr	r2, [r7, #4]
  40413a:	6812      	ldr	r2, [r2, #0]
  40413c:	635a      	str	r2, [r3, #52]	; 0x34
}
  40413e:	bf00      	nop
  404140:	370c      	adds	r7, #12
  404142:	46bd      	mov	sp, r7
  404144:	f85d 7b04 	ldr.w	r7, [sp], #4
  404148:	4770      	bx	lr
  40414a:	bf00      	nop

0040414c <PIO_GetOutputDataStatus>:
 *
 * \return 1 if the Pin instance contains at least one PIO that is configured
 * to output a high level; otherwise 0.
 */
unsigned char PIO_GetOutputDataStatus(const Pin *pin)
{
  40414c:	b480      	push	{r7}
  40414e:	b083      	sub	sp, #12
  404150:	af00      	add	r7, sp, #0
  404152:	6078      	str	r0, [r7, #4]
	if ((pin->pio->PIO_ODSR & pin->mask) == 0) {
  404154:	687b      	ldr	r3, [r7, #4]
  404156:	685b      	ldr	r3, [r3, #4]
  404158:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  40415a:	687b      	ldr	r3, [r7, #4]
  40415c:	681b      	ldr	r3, [r3, #0]
  40415e:	4013      	ands	r3, r2
  404160:	2b00      	cmp	r3, #0
  404162:	d101      	bne.n	404168 <PIO_GetOutputDataStatus+0x1c>
		return 0;
  404164:	2300      	movs	r3, #0
  404166:	e000      	b.n	40416a <PIO_GetOutputDataStatus+0x1e>
	} else {
		return 1;
  404168:	2301      	movs	r3, #1
	}
}
  40416a:	4618      	mov	r0, r3
  40416c:	370c      	adds	r7, #12
  40416e:	46bd      	mov	sp, r7
  404170:	f85d 7b04 	ldr.w	r7, [sp], #4
  404174:	4770      	bx	lr
  404176:	bf00      	nop

00404178 <PMC_EnablePeripheral>:
 * \note The ID must NOT be shifted (i.e. 1 << ID_xxx).
 *
 * \param id  Peripheral ID (ID_xxx).
 */
void PMC_EnablePeripheral( uint32_t dwId )
{
  404178:	b590      	push	{r4, r7, lr}
  40417a:	b083      	sub	sp, #12
  40417c:	af00      	add	r7, sp, #0
  40417e:	6078      	str	r0, [r7, #4]
	assert( dwId < 63 ) ;
  404180:	687b      	ldr	r3, [r7, #4]
  404182:	2b3e      	cmp	r3, #62	; 0x3e
  404184:	d905      	bls.n	404192 <PMC_EnablePeripheral+0x1a>
  404186:	4b1c      	ldr	r3, [pc, #112]	; (4041f8 <PMC_EnablePeripheral+0x80>)
  404188:	4a1c      	ldr	r2, [pc, #112]	; (4041fc <PMC_EnablePeripheral+0x84>)
  40418a:	219c      	movs	r1, #156	; 0x9c
  40418c:	481c      	ldr	r0, [pc, #112]	; (404200 <PMC_EnablePeripheral+0x88>)
  40418e:	4c1d      	ldr	r4, [pc, #116]	; (404204 <PMC_EnablePeripheral+0x8c>)
  404190:	47a0      	blx	r4

	if ( dwId < 32 ) {
  404192:	687b      	ldr	r3, [r7, #4]
  404194:	2b1f      	cmp	r3, #31
  404196:	d813      	bhi.n	4041c0 <PMC_EnablePeripheral+0x48>
		if ( (PMC->PMC_PCSR0 & ((uint32_t)1 << dwId)) == ((uint32_t)1 << dwId) ) {
  404198:	4b1b      	ldr	r3, [pc, #108]	; (404208 <PMC_EnablePeripheral+0x90>)
  40419a:	699a      	ldr	r2, [r3, #24]
  40419c:	2101      	movs	r1, #1
  40419e:	687b      	ldr	r3, [r7, #4]
  4041a0:	fa01 f303 	lsl.w	r3, r1, r3
  4041a4:	401a      	ands	r2, r3
  4041a6:	2101      	movs	r1, #1
  4041a8:	687b      	ldr	r3, [r7, #4]
  4041aa:	fa01 f303 	lsl.w	r3, r1, r3
  4041ae:	429a      	cmp	r2, r3
  4041b0:	d01e      	beq.n	4041f0 <PMC_EnablePeripheral+0x78>
			TRACE_DEBUG( "PMC_EnablePeripheral: clock of peripheral" \
			" %u is already enabled\n\r", (unsigned int)dwId ) ;
		} else {
			PMC->PMC_PCER0 = 1 << dwId ;
  4041b2:	4a15      	ldr	r2, [pc, #84]	; (404208 <PMC_EnablePeripheral+0x90>)
  4041b4:	2101      	movs	r1, #1
  4041b6:	687b      	ldr	r3, [r7, #4]
  4041b8:	fa01 f303 	lsl.w	r3, r1, r3
  4041bc:	6113      	str	r3, [r2, #16]
			" %u is already enabled\n\r", (unsigned int)(dwId + 32) ) ;
		} else {
			PMC->PMC_PCER1 = 1 << dwId ;
		}
	}
}
  4041be:	e017      	b.n	4041f0 <PMC_EnablePeripheral+0x78>
			" %u is already enabled\n\r", (unsigned int)dwId ) ;
		} else {
			PMC->PMC_PCER0 = 1 << dwId ;
		}
	} else {
		dwId -= 32;
  4041c0:	687b      	ldr	r3, [r7, #4]
  4041c2:	3b20      	subs	r3, #32
  4041c4:	607b      	str	r3, [r7, #4]
		if ((PMC->PMC_PCSR1 & ((uint32_t)1 << dwId)) == ((uint32_t)1 << dwId)) {
  4041c6:	4b10      	ldr	r3, [pc, #64]	; (404208 <PMC_EnablePeripheral+0x90>)
  4041c8:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  4041cc:	2101      	movs	r1, #1
  4041ce:	687b      	ldr	r3, [r7, #4]
  4041d0:	fa01 f303 	lsl.w	r3, r1, r3
  4041d4:	401a      	ands	r2, r3
  4041d6:	2101      	movs	r1, #1
  4041d8:	687b      	ldr	r3, [r7, #4]
  4041da:	fa01 f303 	lsl.w	r3, r1, r3
  4041de:	429a      	cmp	r2, r3
  4041e0:	d006      	beq.n	4041f0 <PMC_EnablePeripheral+0x78>
			TRACE_DEBUG( "PMC_EnablePeripheral: clock of peripheral" \
			" %u is already enabled\n\r", (unsigned int)(dwId + 32) ) ;
		} else {
			PMC->PMC_PCER1 = 1 << dwId ;
  4041e2:	4a09      	ldr	r2, [pc, #36]	; (404208 <PMC_EnablePeripheral+0x90>)
  4041e4:	2101      	movs	r1, #1
  4041e6:	687b      	ldr	r3, [r7, #4]
  4041e8:	fa01 f303 	lsl.w	r3, r1, r3
  4041ec:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
		}
	}
}
  4041f0:	bf00      	nop
  4041f2:	370c      	adds	r7, #12
  4041f4:	46bd      	mov	sp, r7
  4041f6:	bd90      	pop	{r4, r7, pc}
  4041f8:	0040ad08 	.word	0x0040ad08
  4041fc:	0040ad4c 	.word	0x0040ad4c
  404200:	0040ad14 	.word	0x0040ad14
  404204:	00404c59 	.word	0x00404c59
  404208:	400e0600 	.word	0x400e0600

0040420c <WDT_Disable>:
 *
 * \note The Watchdog Mode Register (WDT_MR) can be written only once.
 * Only a processor reset resets it.
 */
extern void WDT_Disable( Wdt* pWDT )
{
  40420c:	b480      	push	{r7}
  40420e:	b083      	sub	sp, #12
  404210:	af00      	add	r7, sp, #0
  404212:	6078      	str	r0, [r7, #4]
	pWDT->WDT_MR = WDT_MR_WDDIS;
  404214:	687b      	ldr	r3, [r7, #4]
  404216:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  40421a:	605a      	str	r2, [r3, #4]
}
  40421c:	bf00      	nop
  40421e:	370c      	adds	r7, #12
  404220:	46bd      	mov	sp, r7
  404222:	f85d 7b04 	ldr.w	r7, [sp], #4
  404226:	4770      	bx	lr

00404228 <SCB_EnableICache>:
/** \brief Enable I-Cache

    The function turns on I-Cache
  */
__STATIC_INLINE void SCB_EnableICache(void)
{
  404228:	b480      	push	{r7}
  40422a:	af00      	add	r7, sp, #0
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb");
  40422c:	f3bf 8f4f 	dsb	sy
    so that all instructions following the ISB are fetched from cache or
    memory, after the instruction has been completed.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb");
  404230:	f3bf 8f6f 	isb	sy
  #if (__ICACHE_PRESENT == 1)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0;                       // invalidate I-Cache
  404234:	4b09      	ldr	r3, [pc, #36]	; (40425c <SCB_EnableICache+0x34>)
  404236:	2200      	movs	r2, #0
  404238:	f8c3 2250 	str.w	r2, [r3, #592]	; 0x250
    SCB->CCR |=  SCB_CCR_IC_Msk;            // enable I-Cache
  40423c:	4a07      	ldr	r2, [pc, #28]	; (40425c <SCB_EnableICache+0x34>)
  40423e:	4b07      	ldr	r3, [pc, #28]	; (40425c <SCB_EnableICache+0x34>)
  404240:	695b      	ldr	r3, [r3, #20]
  404242:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  404246:	6153      	str	r3, [r2, #20]
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb");
  404248:	f3bf 8f4f 	dsb	sy
    so that all instructions following the ISB are fetched from cache or
    memory, after the instruction has been completed.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb");
  40424c:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
  #endif
}
  404250:	bf00      	nop
  404252:	46bd      	mov	sp, r7
  404254:	f85d 7b04 	ldr.w	r7, [sp], #4
  404258:	4770      	bx	lr
  40425a:	bf00      	nop
  40425c:	e000ed00 	.word	0xe000ed00

00404260 <SCB_EnableDCache>:
/** \brief Enable D-Cache

    The function turns on D-Cache
  */
__STATIC_INLINE void SCB_EnableDCache(void)
{
  404260:	b480      	push	{r7}
  404262:	b08b      	sub	sp, #44	; 0x2c
  404264:	af00      	add	r7, sp, #0
  #if (__DCACHE_PRESENT == 1)
    uint32_t ccsidr, sshift, wshift, sw;
    uint32_t sets, ways;

    ccsidr  = SCB->CCSIDR;
  404266:	4b26      	ldr	r3, [pc, #152]	; (404300 <SCB_EnableDCache+0xa0>)
  404268:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
  40426c:	61fb      	str	r3, [r7, #28]
    sets    = CCSIDR_SETS(ccsidr);
  40426e:	69fb      	ldr	r3, [r7, #28]
  404270:	0b5b      	lsrs	r3, r3, #13
  404272:	f3c3 030e 	ubfx	r3, r3, #0, #15
  404276:	627b      	str	r3, [r7, #36]	; 0x24
    sshift  = CCSIDR_LSSHIFT(ccsidr) + 4;
  404278:	69fb      	ldr	r3, [r7, #28]
  40427a:	f003 0307 	and.w	r3, r3, #7
  40427e:	3304      	adds	r3, #4
  404280:	61bb      	str	r3, [r7, #24]
    ways    = CCSIDR_WAYS(ccsidr);
  404282:	69fb      	ldr	r3, [r7, #28]
  404284:	08db      	lsrs	r3, r3, #3
  404286:	f3c3 0309 	ubfx	r3, r3, #0, #10
  40428a:	617b      	str	r3, [r7, #20]
  40428c:	697b      	ldr	r3, [r7, #20]
  40428e:	60fb      	str	r3, [r7, #12]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
  uint8_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
  404290:	68fb      	ldr	r3, [r7, #12]
  404292:	fab3 f383 	clz	r3, r3
  404296:	71fb      	strb	r3, [r7, #7]
  return(result);
  404298:	79fb      	ldrb	r3, [r7, #7]
    wshift  = __CLZ(ways) & 0x1f;
  40429a:	f003 031f 	and.w	r3, r3, #31
  40429e:	613b      	str	r3, [r7, #16]
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb");
  4042a0:	f3bf 8f4f 	dsb	sy

    __DSB();

    do {                                    // invalidate D-Cache
         int32_t tmpways = ways;
  4042a4:	697b      	ldr	r3, [r7, #20]
  4042a6:	623b      	str	r3, [r7, #32]
         do {
              sw = ((tmpways << wshift) | (sets << sshift));
  4042a8:	6a3a      	ldr	r2, [r7, #32]
  4042aa:	693b      	ldr	r3, [r7, #16]
  4042ac:	fa02 f303 	lsl.w	r3, r2, r3
  4042b0:	4619      	mov	r1, r3
  4042b2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  4042b4:	69bb      	ldr	r3, [r7, #24]
  4042b6:	fa02 f303 	lsl.w	r3, r2, r3
  4042ba:	430b      	orrs	r3, r1
  4042bc:	60bb      	str	r3, [r7, #8]
              SCB->DCISW = sw;
  4042be:	4a10      	ldr	r2, [pc, #64]	; (404300 <SCB_EnableDCache+0xa0>)
  4042c0:	68bb      	ldr	r3, [r7, #8]
  4042c2:	f8c2 3260 	str.w	r3, [r2, #608]	; 0x260
            } while(tmpways--);
  4042c6:	6a3b      	ldr	r3, [r7, #32]
  4042c8:	1e5a      	subs	r2, r3, #1
  4042ca:	623a      	str	r2, [r7, #32]
  4042cc:	2b00      	cmp	r3, #0
  4042ce:	d1eb      	bne.n	4042a8 <SCB_EnableDCache+0x48>
        } while(sets--);
  4042d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4042d2:	1e5a      	subs	r2, r3, #1
  4042d4:	627a      	str	r2, [r7, #36]	; 0x24
  4042d6:	2b00      	cmp	r3, #0
  4042d8:	d1e4      	bne.n	4042a4 <SCB_EnableDCache+0x44>
  4042da:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  SCB_CCR_DC_Msk;            // enable D-Cache
  4042de:	4a08      	ldr	r2, [pc, #32]	; (404300 <SCB_EnableDCache+0xa0>)
  4042e0:	4b07      	ldr	r3, [pc, #28]	; (404300 <SCB_EnableDCache+0xa0>)
  4042e2:	695b      	ldr	r3, [r3, #20]
  4042e4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  4042e8:	6153      	str	r3, [r2, #20]
  4042ea:	f3bf 8f4f 	dsb	sy
    so that all instructions following the ISB are fetched from cache or
    memory, after the instruction has been completed.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb");
  4042ee:	f3bf 8f6f 	isb	sy

    __DSB();
    __ISB();
  #endif
}
  4042f2:	bf00      	nop
  4042f4:	372c      	adds	r7, #44	; 0x2c
  4042f6:	46bd      	mov	sp, r7
  4042f8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4042fc:	4770      	bx	lr
  4042fe:	bf00      	nop
  404300:	e000ed00 	.word	0xe000ed00

00404304 <main>:
void vApplicationTickHook( void );

/*-----------------------------------------------------------*/

int main( void )
{
  404304:	b580      	push	{r7, lr}
  404306:	af00      	add	r7, sp, #0
	/* Configure the hardware ready to run the demo. */
	prvSetupHardware();
  404308:	4b03      	ldr	r3, [pc, #12]	; (404318 <main+0x14>)
  40430a:	4798      	blx	r3

	/* The mainCREATE_SIMPLE_BLINKY_DEMO_ONLY setting is described at the top
	of this file. */
	#if( mainCREATE_SIMPLE_BLINKY_DEMO_ONLY == 1 )
	{
		main_blinky();
  40430c:	4b03      	ldr	r3, [pc, #12]	; (40431c <main+0x18>)
  40430e:	4798      	blx	r3
	{
		main_full();
	}
	#endif

	return 0;
  404310:	2300      	movs	r3, #0
}
  404312:	4618      	mov	r0, r3
  404314:	bd80      	pop	{r7, pc}
  404316:	bf00      	nop
  404318:	00404321 	.word	0x00404321
  40431c:	00403411 	.word	0x00403411

00404320 <prvSetupHardware>:
/*-----------------------------------------------------------*/

static void prvSetupHardware( void )
{
  404320:	b580      	push	{r7, lr}
  404322:	af00      	add	r7, sp, #0
	/* Disable watchdog. */
	WDT_Disable( WDT );
  404324:	4808      	ldr	r0, [pc, #32]	; (404348 <prvSetupHardware+0x28>)
  404326:	4b09      	ldr	r3, [pc, #36]	; (40434c <prvSetupHardware+0x2c>)
  404328:	4798      	blx	r3
	WDT_Disable( ( Wdt * ) RSWDT );
  40432a:	4809      	ldr	r0, [pc, #36]	; (404350 <prvSetupHardware+0x30>)
  40432c:	4b07      	ldr	r3, [pc, #28]	; (40434c <prvSetupHardware+0x2c>)
  40432e:	4798      	blx	r3

	SCB_EnableICache();
  404330:	4b08      	ldr	r3, [pc, #32]	; (404354 <prvSetupHardware+0x34>)
  404332:	4798      	blx	r3
	SCB_EnableDCache();
  404334:	4b08      	ldr	r3, [pc, #32]	; (404358 <prvSetupHardware+0x38>)
  404336:	4798      	blx	r3

    LED_Configure( 0 );
  404338:	2000      	movs	r0, #0
  40433a:	4b08      	ldr	r3, [pc, #32]	; (40435c <prvSetupHardware+0x3c>)
  40433c:	4798      	blx	r3
    LED_Configure( 1 );
  40433e:	2001      	movs	r0, #1
  404340:	4b06      	ldr	r3, [pc, #24]	; (40435c <prvSetupHardware+0x3c>)
  404342:	4798      	blx	r3
}
  404344:	bf00      	nop
  404346:	bd80      	pop	{r7, pc}
  404348:	400e1850 	.word	0x400e1850
  40434c:	0040420d 	.word	0x0040420d
  404350:	400e1900 	.word	0x400e1900
  404354:	00404229 	.word	0x00404229
  404358:	00404261 	.word	0x00404261
  40435c:	00403a9d 	.word	0x00403a9d

00404360 <vApplicationMallocFailedHook>:
/*-----------------------------------------------------------*/

void vApplicationMallocFailedHook( void )
{
  404360:	b480      	push	{r7}
  404362:	b083      	sub	sp, #12
  404364:	af00      	add	r7, sp, #0

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
  404366:	f04f 0380 	mov.w	r3, #128	; 0x80
  40436a:	b672      	cpsid	i
  40436c:	f383 8811 	msr	BASEPRI, r3
  404370:	f3bf 8f6f 	isb	sy
  404374:	f3bf 8f4f 	dsb	sy
  404378:	b662      	cpsie	i
  40437a:	607b      	str	r3, [r7, #4]
	internally by FreeRTOS API functions that create tasks, queues, software
	timers, and semaphores.  The size of the FreeRTOS heap is set by the
	configTOTAL_HEAP_SIZE configuration constant in FreeRTOSConfig.h. */

	/* Force an assert. */
	configASSERT( ( volatile void * ) NULL );
  40437c:	e7fe      	b.n	40437c <vApplicationMallocFailedHook+0x1c>
  40437e:	bf00      	nop

00404380 <vApplicationStackOverflowHook>:
}
/*-----------------------------------------------------------*/

void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName )
{
  404380:	b480      	push	{r7}
  404382:	b085      	sub	sp, #20
  404384:	af00      	add	r7, sp, #0
  404386:	6078      	str	r0, [r7, #4]
  404388:	6039      	str	r1, [r7, #0]
  40438a:	f04f 0380 	mov.w	r3, #128	; 0x80
  40438e:	b672      	cpsid	i
  404390:	f383 8811 	msr	BASEPRI, r3
  404394:	f3bf 8f6f 	isb	sy
  404398:	f3bf 8f4f 	dsb	sy
  40439c:	b662      	cpsie	i
  40439e:	60fb      	str	r3, [r7, #12]
	/* Run time stack overflow checking is performed if
	configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	function is called if a stack overflow is detected. */

	/* Force an assert. */
	configASSERT( ( volatile void * ) NULL );
  4043a0:	e7fe      	b.n	4043a0 <vApplicationStackOverflowHook+0x20>
  4043a2:	bf00      	nop

004043a4 <vApplicationTickHook>:
	( void ) xFreeHeapSpace;
}
/*-----------------------------------------------------------*/

void vApplicationTickHook( void )
{
  4043a4:	b480      	push	{r7}
  4043a6:	af00      	add	r7, sp, #0

		/* Call the code that 'gives' a task notification from an ISR. */
		xNotifyTaskFromISR();
	}
	#endif
}
  4043a8:	bf00      	nop
  4043aa:	46bd      	mov	sp, r7
  4043ac:	f85d 7b04 	ldr.w	r7, [sp], #4
  4043b0:	4770      	bx	lr
  4043b2:	bf00      	nop

004043b4 <__aeabi_drsub>:
  4043b4:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
  4043b8:	e002      	b.n	4043c0 <__adddf3>
  4043ba:	bf00      	nop

004043bc <__aeabi_dsub>:
  4043bc:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

004043c0 <__adddf3>:
  4043c0:	b530      	push	{r4, r5, lr}
  4043c2:	ea4f 0441 	mov.w	r4, r1, lsl #1
  4043c6:	ea4f 0543 	mov.w	r5, r3, lsl #1
  4043ca:	ea94 0f05 	teq	r4, r5
  4043ce:	bf08      	it	eq
  4043d0:	ea90 0f02 	teqeq	r0, r2
  4043d4:	bf1f      	itttt	ne
  4043d6:	ea54 0c00 	orrsne.w	ip, r4, r0
  4043da:	ea55 0c02 	orrsne.w	ip, r5, r2
  4043de:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
  4043e2:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  4043e6:	f000 80e2 	beq.w	4045ae <__adddf3+0x1ee>
  4043ea:	ea4f 5454 	mov.w	r4, r4, lsr #21
  4043ee:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
  4043f2:	bfb8      	it	lt
  4043f4:	426d      	neglt	r5, r5
  4043f6:	dd0c      	ble.n	404412 <__adddf3+0x52>
  4043f8:	442c      	add	r4, r5
  4043fa:	ea80 0202 	eor.w	r2, r0, r2
  4043fe:	ea81 0303 	eor.w	r3, r1, r3
  404402:	ea82 0000 	eor.w	r0, r2, r0
  404406:	ea83 0101 	eor.w	r1, r3, r1
  40440a:	ea80 0202 	eor.w	r2, r0, r2
  40440e:	ea81 0303 	eor.w	r3, r1, r3
  404412:	2d36      	cmp	r5, #54	; 0x36
  404414:	bf88      	it	hi
  404416:	bd30      	pophi	{r4, r5, pc}
  404418:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  40441c:	ea4f 3101 	mov.w	r1, r1, lsl #12
  404420:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
  404424:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
  404428:	d002      	beq.n	404430 <__adddf3+0x70>
  40442a:	4240      	negs	r0, r0
  40442c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  404430:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
  404434:	ea4f 3303 	mov.w	r3, r3, lsl #12
  404438:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
  40443c:	d002      	beq.n	404444 <__adddf3+0x84>
  40443e:	4252      	negs	r2, r2
  404440:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  404444:	ea94 0f05 	teq	r4, r5
  404448:	f000 80a7 	beq.w	40459a <__adddf3+0x1da>
  40444c:	f1a4 0401 	sub.w	r4, r4, #1
  404450:	f1d5 0e20 	rsbs	lr, r5, #32
  404454:	db0d      	blt.n	404472 <__adddf3+0xb2>
  404456:	fa02 fc0e 	lsl.w	ip, r2, lr
  40445a:	fa22 f205 	lsr.w	r2, r2, r5
  40445e:	1880      	adds	r0, r0, r2
  404460:	f141 0100 	adc.w	r1, r1, #0
  404464:	fa03 f20e 	lsl.w	r2, r3, lr
  404468:	1880      	adds	r0, r0, r2
  40446a:	fa43 f305 	asr.w	r3, r3, r5
  40446e:	4159      	adcs	r1, r3
  404470:	e00e      	b.n	404490 <__adddf3+0xd0>
  404472:	f1a5 0520 	sub.w	r5, r5, #32
  404476:	f10e 0e20 	add.w	lr, lr, #32
  40447a:	2a01      	cmp	r2, #1
  40447c:	fa03 fc0e 	lsl.w	ip, r3, lr
  404480:	bf28      	it	cs
  404482:	f04c 0c02 	orrcs.w	ip, ip, #2
  404486:	fa43 f305 	asr.w	r3, r3, r5
  40448a:	18c0      	adds	r0, r0, r3
  40448c:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
  404490:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  404494:	d507      	bpl.n	4044a6 <__adddf3+0xe6>
  404496:	f04f 0e00 	mov.w	lr, #0
  40449a:	f1dc 0c00 	rsbs	ip, ip, #0
  40449e:	eb7e 0000 	sbcs.w	r0, lr, r0
  4044a2:	eb6e 0101 	sbc.w	r1, lr, r1
  4044a6:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
  4044aa:	d31b      	bcc.n	4044e4 <__adddf3+0x124>
  4044ac:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
  4044b0:	d30c      	bcc.n	4044cc <__adddf3+0x10c>
  4044b2:	0849      	lsrs	r1, r1, #1
  4044b4:	ea5f 0030 	movs.w	r0, r0, rrx
  4044b8:	ea4f 0c3c 	mov.w	ip, ip, rrx
  4044bc:	f104 0401 	add.w	r4, r4, #1
  4044c0:	ea4f 5244 	mov.w	r2, r4, lsl #21
  4044c4:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
  4044c8:	f080 809a 	bcs.w	404600 <__adddf3+0x240>
  4044cc:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
  4044d0:	bf08      	it	eq
  4044d2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  4044d6:	f150 0000 	adcs.w	r0, r0, #0
  4044da:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  4044de:	ea41 0105 	orr.w	r1, r1, r5
  4044e2:	bd30      	pop	{r4, r5, pc}
  4044e4:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
  4044e8:	4140      	adcs	r0, r0
  4044ea:	eb41 0101 	adc.w	r1, r1, r1
  4044ee:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  4044f2:	f1a4 0401 	sub.w	r4, r4, #1
  4044f6:	d1e9      	bne.n	4044cc <__adddf3+0x10c>
  4044f8:	f091 0f00 	teq	r1, #0
  4044fc:	bf04      	itt	eq
  4044fe:	4601      	moveq	r1, r0
  404500:	2000      	moveq	r0, #0
  404502:	fab1 f381 	clz	r3, r1
  404506:	bf08      	it	eq
  404508:	3320      	addeq	r3, #32
  40450a:	f1a3 030b 	sub.w	r3, r3, #11
  40450e:	f1b3 0220 	subs.w	r2, r3, #32
  404512:	da0c      	bge.n	40452e <__adddf3+0x16e>
  404514:	320c      	adds	r2, #12
  404516:	dd08      	ble.n	40452a <__adddf3+0x16a>
  404518:	f102 0c14 	add.w	ip, r2, #20
  40451c:	f1c2 020c 	rsb	r2, r2, #12
  404520:	fa01 f00c 	lsl.w	r0, r1, ip
  404524:	fa21 f102 	lsr.w	r1, r1, r2
  404528:	e00c      	b.n	404544 <__adddf3+0x184>
  40452a:	f102 0214 	add.w	r2, r2, #20
  40452e:	bfd8      	it	le
  404530:	f1c2 0c20 	rsble	ip, r2, #32
  404534:	fa01 f102 	lsl.w	r1, r1, r2
  404538:	fa20 fc0c 	lsr.w	ip, r0, ip
  40453c:	bfdc      	itt	le
  40453e:	ea41 010c 	orrle.w	r1, r1, ip
  404542:	4090      	lslle	r0, r2
  404544:	1ae4      	subs	r4, r4, r3
  404546:	bfa2      	ittt	ge
  404548:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
  40454c:	4329      	orrge	r1, r5
  40454e:	bd30      	popge	{r4, r5, pc}
  404550:	ea6f 0404 	mvn.w	r4, r4
  404554:	3c1f      	subs	r4, #31
  404556:	da1c      	bge.n	404592 <__adddf3+0x1d2>
  404558:	340c      	adds	r4, #12
  40455a:	dc0e      	bgt.n	40457a <__adddf3+0x1ba>
  40455c:	f104 0414 	add.w	r4, r4, #20
  404560:	f1c4 0220 	rsb	r2, r4, #32
  404564:	fa20 f004 	lsr.w	r0, r0, r4
  404568:	fa01 f302 	lsl.w	r3, r1, r2
  40456c:	ea40 0003 	orr.w	r0, r0, r3
  404570:	fa21 f304 	lsr.w	r3, r1, r4
  404574:	ea45 0103 	orr.w	r1, r5, r3
  404578:	bd30      	pop	{r4, r5, pc}
  40457a:	f1c4 040c 	rsb	r4, r4, #12
  40457e:	f1c4 0220 	rsb	r2, r4, #32
  404582:	fa20 f002 	lsr.w	r0, r0, r2
  404586:	fa01 f304 	lsl.w	r3, r1, r4
  40458a:	ea40 0003 	orr.w	r0, r0, r3
  40458e:	4629      	mov	r1, r5
  404590:	bd30      	pop	{r4, r5, pc}
  404592:	fa21 f004 	lsr.w	r0, r1, r4
  404596:	4629      	mov	r1, r5
  404598:	bd30      	pop	{r4, r5, pc}
  40459a:	f094 0f00 	teq	r4, #0
  40459e:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
  4045a2:	bf06      	itte	eq
  4045a4:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
  4045a8:	3401      	addeq	r4, #1
  4045aa:	3d01      	subne	r5, #1
  4045ac:	e74e      	b.n	40444c <__adddf3+0x8c>
  4045ae:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  4045b2:	bf18      	it	ne
  4045b4:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  4045b8:	d029      	beq.n	40460e <__adddf3+0x24e>
  4045ba:	ea94 0f05 	teq	r4, r5
  4045be:	bf08      	it	eq
  4045c0:	ea90 0f02 	teqeq	r0, r2
  4045c4:	d005      	beq.n	4045d2 <__adddf3+0x212>
  4045c6:	ea54 0c00 	orrs.w	ip, r4, r0
  4045ca:	bf04      	itt	eq
  4045cc:	4619      	moveq	r1, r3
  4045ce:	4610      	moveq	r0, r2
  4045d0:	bd30      	pop	{r4, r5, pc}
  4045d2:	ea91 0f03 	teq	r1, r3
  4045d6:	bf1e      	ittt	ne
  4045d8:	2100      	movne	r1, #0
  4045da:	2000      	movne	r0, #0
  4045dc:	bd30      	popne	{r4, r5, pc}
  4045de:	ea5f 5c54 	movs.w	ip, r4, lsr #21
  4045e2:	d105      	bne.n	4045f0 <__adddf3+0x230>
  4045e4:	0040      	lsls	r0, r0, #1
  4045e6:	4149      	adcs	r1, r1
  4045e8:	bf28      	it	cs
  4045ea:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
  4045ee:	bd30      	pop	{r4, r5, pc}
  4045f0:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
  4045f4:	bf3c      	itt	cc
  4045f6:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
  4045fa:	bd30      	popcc	{r4, r5, pc}
  4045fc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  404600:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
  404604:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  404608:	f04f 0000 	mov.w	r0, #0
  40460c:	bd30      	pop	{r4, r5, pc}
  40460e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  404612:	bf1a      	itte	ne
  404614:	4619      	movne	r1, r3
  404616:	4610      	movne	r0, r2
  404618:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
  40461c:	bf1c      	itt	ne
  40461e:	460b      	movne	r3, r1
  404620:	4602      	movne	r2, r0
  404622:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  404626:	bf06      	itte	eq
  404628:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
  40462c:	ea91 0f03 	teqeq	r1, r3
  404630:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
  404634:	bd30      	pop	{r4, r5, pc}
  404636:	bf00      	nop

00404638 <__aeabi_ui2d>:
  404638:	f090 0f00 	teq	r0, #0
  40463c:	bf04      	itt	eq
  40463e:	2100      	moveq	r1, #0
  404640:	4770      	bxeq	lr
  404642:	b530      	push	{r4, r5, lr}
  404644:	f44f 6480 	mov.w	r4, #1024	; 0x400
  404648:	f104 0432 	add.w	r4, r4, #50	; 0x32
  40464c:	f04f 0500 	mov.w	r5, #0
  404650:	f04f 0100 	mov.w	r1, #0
  404654:	e750      	b.n	4044f8 <__adddf3+0x138>
  404656:	bf00      	nop

00404658 <__aeabi_i2d>:
  404658:	f090 0f00 	teq	r0, #0
  40465c:	bf04      	itt	eq
  40465e:	2100      	moveq	r1, #0
  404660:	4770      	bxeq	lr
  404662:	b530      	push	{r4, r5, lr}
  404664:	f44f 6480 	mov.w	r4, #1024	; 0x400
  404668:	f104 0432 	add.w	r4, r4, #50	; 0x32
  40466c:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
  404670:	bf48      	it	mi
  404672:	4240      	negmi	r0, r0
  404674:	f04f 0100 	mov.w	r1, #0
  404678:	e73e      	b.n	4044f8 <__adddf3+0x138>
  40467a:	bf00      	nop

0040467c <__aeabi_f2d>:
  40467c:	0042      	lsls	r2, r0, #1
  40467e:	ea4f 01e2 	mov.w	r1, r2, asr #3
  404682:	ea4f 0131 	mov.w	r1, r1, rrx
  404686:	ea4f 7002 	mov.w	r0, r2, lsl #28
  40468a:	bf1f      	itttt	ne
  40468c:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
  404690:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  404694:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
  404698:	4770      	bxne	lr
  40469a:	f092 0f00 	teq	r2, #0
  40469e:	bf14      	ite	ne
  4046a0:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  4046a4:	4770      	bxeq	lr
  4046a6:	b530      	push	{r4, r5, lr}
  4046a8:	f44f 7460 	mov.w	r4, #896	; 0x380
  4046ac:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  4046b0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  4046b4:	e720      	b.n	4044f8 <__adddf3+0x138>
  4046b6:	bf00      	nop

004046b8 <__aeabi_ul2d>:
  4046b8:	ea50 0201 	orrs.w	r2, r0, r1
  4046bc:	bf08      	it	eq
  4046be:	4770      	bxeq	lr
  4046c0:	b530      	push	{r4, r5, lr}
  4046c2:	f04f 0500 	mov.w	r5, #0
  4046c6:	e00a      	b.n	4046de <__aeabi_l2d+0x16>

004046c8 <__aeabi_l2d>:
  4046c8:	ea50 0201 	orrs.w	r2, r0, r1
  4046cc:	bf08      	it	eq
  4046ce:	4770      	bxeq	lr
  4046d0:	b530      	push	{r4, r5, lr}
  4046d2:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
  4046d6:	d502      	bpl.n	4046de <__aeabi_l2d+0x16>
  4046d8:	4240      	negs	r0, r0
  4046da:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  4046de:	f44f 6480 	mov.w	r4, #1024	; 0x400
  4046e2:	f104 0432 	add.w	r4, r4, #50	; 0x32
  4046e6:	ea5f 5c91 	movs.w	ip, r1, lsr #22
  4046ea:	f43f aedc 	beq.w	4044a6 <__adddf3+0xe6>
  4046ee:	f04f 0203 	mov.w	r2, #3
  4046f2:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  4046f6:	bf18      	it	ne
  4046f8:	3203      	addne	r2, #3
  4046fa:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  4046fe:	bf18      	it	ne
  404700:	3203      	addne	r2, #3
  404702:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
  404706:	f1c2 0320 	rsb	r3, r2, #32
  40470a:	fa00 fc03 	lsl.w	ip, r0, r3
  40470e:	fa20 f002 	lsr.w	r0, r0, r2
  404712:	fa01 fe03 	lsl.w	lr, r1, r3
  404716:	ea40 000e 	orr.w	r0, r0, lr
  40471a:	fa21 f102 	lsr.w	r1, r1, r2
  40471e:	4414      	add	r4, r2
  404720:	e6c1      	b.n	4044a6 <__adddf3+0xe6>
  404722:	bf00      	nop

00404724 <__aeabi_dmul>:
  404724:	b570      	push	{r4, r5, r6, lr}
  404726:	f04f 0cff 	mov.w	ip, #255	; 0xff
  40472a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  40472e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  404732:	bf1d      	ittte	ne
  404734:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  404738:	ea94 0f0c 	teqne	r4, ip
  40473c:	ea95 0f0c 	teqne	r5, ip
  404740:	f000 f8de 	bleq	404900 <__aeabi_dmul+0x1dc>
  404744:	442c      	add	r4, r5
  404746:	ea81 0603 	eor.w	r6, r1, r3
  40474a:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
  40474e:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
  404752:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
  404756:	bf18      	it	ne
  404758:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
  40475c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  404760:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  404764:	d038      	beq.n	4047d8 <__aeabi_dmul+0xb4>
  404766:	fba0 ce02 	umull	ip, lr, r0, r2
  40476a:	f04f 0500 	mov.w	r5, #0
  40476e:	fbe1 e502 	umlal	lr, r5, r1, r2
  404772:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
  404776:	fbe0 e503 	umlal	lr, r5, r0, r3
  40477a:	f04f 0600 	mov.w	r6, #0
  40477e:	fbe1 5603 	umlal	r5, r6, r1, r3
  404782:	f09c 0f00 	teq	ip, #0
  404786:	bf18      	it	ne
  404788:	f04e 0e01 	orrne.w	lr, lr, #1
  40478c:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
  404790:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
  404794:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
  404798:	d204      	bcs.n	4047a4 <__aeabi_dmul+0x80>
  40479a:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
  40479e:	416d      	adcs	r5, r5
  4047a0:	eb46 0606 	adc.w	r6, r6, r6
  4047a4:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
  4047a8:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
  4047ac:	ea4f 20c5 	mov.w	r0, r5, lsl #11
  4047b0:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
  4047b4:	ea4f 2ece 	mov.w	lr, lr, lsl #11
  4047b8:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  4047bc:	bf88      	it	hi
  4047be:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  4047c2:	d81e      	bhi.n	404802 <__aeabi_dmul+0xde>
  4047c4:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
  4047c8:	bf08      	it	eq
  4047ca:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
  4047ce:	f150 0000 	adcs.w	r0, r0, #0
  4047d2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  4047d6:	bd70      	pop	{r4, r5, r6, pc}
  4047d8:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
  4047dc:	ea46 0101 	orr.w	r1, r6, r1
  4047e0:	ea40 0002 	orr.w	r0, r0, r2
  4047e4:	ea81 0103 	eor.w	r1, r1, r3
  4047e8:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
  4047ec:	bfc2      	ittt	gt
  4047ee:	ebd4 050c 	rsbsgt	r5, r4, ip
  4047f2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  4047f6:	bd70      	popgt	{r4, r5, r6, pc}
  4047f8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  4047fc:	f04f 0e00 	mov.w	lr, #0
  404800:	3c01      	subs	r4, #1
  404802:	f300 80ab 	bgt.w	40495c <__aeabi_dmul+0x238>
  404806:	f114 0f36 	cmn.w	r4, #54	; 0x36
  40480a:	bfde      	ittt	le
  40480c:	2000      	movle	r0, #0
  40480e:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
  404812:	bd70      	pople	{r4, r5, r6, pc}
  404814:	f1c4 0400 	rsb	r4, r4, #0
  404818:	3c20      	subs	r4, #32
  40481a:	da35      	bge.n	404888 <__aeabi_dmul+0x164>
  40481c:	340c      	adds	r4, #12
  40481e:	dc1b      	bgt.n	404858 <__aeabi_dmul+0x134>
  404820:	f104 0414 	add.w	r4, r4, #20
  404824:	f1c4 0520 	rsb	r5, r4, #32
  404828:	fa00 f305 	lsl.w	r3, r0, r5
  40482c:	fa20 f004 	lsr.w	r0, r0, r4
  404830:	fa01 f205 	lsl.w	r2, r1, r5
  404834:	ea40 0002 	orr.w	r0, r0, r2
  404838:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
  40483c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  404840:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  404844:	fa21 f604 	lsr.w	r6, r1, r4
  404848:	eb42 0106 	adc.w	r1, r2, r6
  40484c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  404850:	bf08      	it	eq
  404852:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  404856:	bd70      	pop	{r4, r5, r6, pc}
  404858:	f1c4 040c 	rsb	r4, r4, #12
  40485c:	f1c4 0520 	rsb	r5, r4, #32
  404860:	fa00 f304 	lsl.w	r3, r0, r4
  404864:	fa20 f005 	lsr.w	r0, r0, r5
  404868:	fa01 f204 	lsl.w	r2, r1, r4
  40486c:	ea40 0002 	orr.w	r0, r0, r2
  404870:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  404874:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  404878:	f141 0100 	adc.w	r1, r1, #0
  40487c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  404880:	bf08      	it	eq
  404882:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  404886:	bd70      	pop	{r4, r5, r6, pc}
  404888:	f1c4 0520 	rsb	r5, r4, #32
  40488c:	fa00 f205 	lsl.w	r2, r0, r5
  404890:	ea4e 0e02 	orr.w	lr, lr, r2
  404894:	fa20 f304 	lsr.w	r3, r0, r4
  404898:	fa01 f205 	lsl.w	r2, r1, r5
  40489c:	ea43 0302 	orr.w	r3, r3, r2
  4048a0:	fa21 f004 	lsr.w	r0, r1, r4
  4048a4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  4048a8:	fa21 f204 	lsr.w	r2, r1, r4
  4048ac:	ea20 0002 	bic.w	r0, r0, r2
  4048b0:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
  4048b4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  4048b8:	bf08      	it	eq
  4048ba:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  4048be:	bd70      	pop	{r4, r5, r6, pc}
  4048c0:	f094 0f00 	teq	r4, #0
  4048c4:	d10f      	bne.n	4048e6 <__aeabi_dmul+0x1c2>
  4048c6:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
  4048ca:	0040      	lsls	r0, r0, #1
  4048cc:	eb41 0101 	adc.w	r1, r1, r1
  4048d0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  4048d4:	bf08      	it	eq
  4048d6:	3c01      	subeq	r4, #1
  4048d8:	d0f7      	beq.n	4048ca <__aeabi_dmul+0x1a6>
  4048da:	ea41 0106 	orr.w	r1, r1, r6
  4048de:	f095 0f00 	teq	r5, #0
  4048e2:	bf18      	it	ne
  4048e4:	4770      	bxne	lr
  4048e6:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
  4048ea:	0052      	lsls	r2, r2, #1
  4048ec:	eb43 0303 	adc.w	r3, r3, r3
  4048f0:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
  4048f4:	bf08      	it	eq
  4048f6:	3d01      	subeq	r5, #1
  4048f8:	d0f7      	beq.n	4048ea <__aeabi_dmul+0x1c6>
  4048fa:	ea43 0306 	orr.w	r3, r3, r6
  4048fe:	4770      	bx	lr
  404900:	ea94 0f0c 	teq	r4, ip
  404904:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  404908:	bf18      	it	ne
  40490a:	ea95 0f0c 	teqne	r5, ip
  40490e:	d00c      	beq.n	40492a <__aeabi_dmul+0x206>
  404910:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  404914:	bf18      	it	ne
  404916:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  40491a:	d1d1      	bne.n	4048c0 <__aeabi_dmul+0x19c>
  40491c:	ea81 0103 	eor.w	r1, r1, r3
  404920:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  404924:	f04f 0000 	mov.w	r0, #0
  404928:	bd70      	pop	{r4, r5, r6, pc}
  40492a:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  40492e:	bf06      	itte	eq
  404930:	4610      	moveq	r0, r2
  404932:	4619      	moveq	r1, r3
  404934:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  404938:	d019      	beq.n	40496e <__aeabi_dmul+0x24a>
  40493a:	ea94 0f0c 	teq	r4, ip
  40493e:	d102      	bne.n	404946 <__aeabi_dmul+0x222>
  404940:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
  404944:	d113      	bne.n	40496e <__aeabi_dmul+0x24a>
  404946:	ea95 0f0c 	teq	r5, ip
  40494a:	d105      	bne.n	404958 <__aeabi_dmul+0x234>
  40494c:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
  404950:	bf1c      	itt	ne
  404952:	4610      	movne	r0, r2
  404954:	4619      	movne	r1, r3
  404956:	d10a      	bne.n	40496e <__aeabi_dmul+0x24a>
  404958:	ea81 0103 	eor.w	r1, r1, r3
  40495c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  404960:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  404964:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  404968:	f04f 0000 	mov.w	r0, #0
  40496c:	bd70      	pop	{r4, r5, r6, pc}
  40496e:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  404972:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
  404976:	bd70      	pop	{r4, r5, r6, pc}

00404978 <__aeabi_ddiv>:
  404978:	b570      	push	{r4, r5, r6, lr}
  40497a:	f04f 0cff 	mov.w	ip, #255	; 0xff
  40497e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  404982:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  404986:	bf1d      	ittte	ne
  404988:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  40498c:	ea94 0f0c 	teqne	r4, ip
  404990:	ea95 0f0c 	teqne	r5, ip
  404994:	f000 f8a7 	bleq	404ae6 <__aeabi_ddiv+0x16e>
  404998:	eba4 0405 	sub.w	r4, r4, r5
  40499c:	ea81 0e03 	eor.w	lr, r1, r3
  4049a0:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  4049a4:	ea4f 3101 	mov.w	r1, r1, lsl #12
  4049a8:	f000 8088 	beq.w	404abc <__aeabi_ddiv+0x144>
  4049ac:	ea4f 3303 	mov.w	r3, r3, lsl #12
  4049b0:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
  4049b4:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
  4049b8:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
  4049bc:	ea4f 2202 	mov.w	r2, r2, lsl #8
  4049c0:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
  4049c4:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
  4049c8:	ea4f 2600 	mov.w	r6, r0, lsl #8
  4049cc:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
  4049d0:	429d      	cmp	r5, r3
  4049d2:	bf08      	it	eq
  4049d4:	4296      	cmpeq	r6, r2
  4049d6:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
  4049da:	f504 7440 	add.w	r4, r4, #768	; 0x300
  4049de:	d202      	bcs.n	4049e6 <__aeabi_ddiv+0x6e>
  4049e0:	085b      	lsrs	r3, r3, #1
  4049e2:	ea4f 0232 	mov.w	r2, r2, rrx
  4049e6:	1ab6      	subs	r6, r6, r2
  4049e8:	eb65 0503 	sbc.w	r5, r5, r3
  4049ec:	085b      	lsrs	r3, r3, #1
  4049ee:	ea4f 0232 	mov.w	r2, r2, rrx
  4049f2:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  4049f6:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
  4049fa:	ebb6 0e02 	subs.w	lr, r6, r2
  4049fe:	eb75 0e03 	sbcs.w	lr, r5, r3
  404a02:	bf22      	ittt	cs
  404a04:	1ab6      	subcs	r6, r6, r2
  404a06:	4675      	movcs	r5, lr
  404a08:	ea40 000c 	orrcs.w	r0, r0, ip
  404a0c:	085b      	lsrs	r3, r3, #1
  404a0e:	ea4f 0232 	mov.w	r2, r2, rrx
  404a12:	ebb6 0e02 	subs.w	lr, r6, r2
  404a16:	eb75 0e03 	sbcs.w	lr, r5, r3
  404a1a:	bf22      	ittt	cs
  404a1c:	1ab6      	subcs	r6, r6, r2
  404a1e:	4675      	movcs	r5, lr
  404a20:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
  404a24:	085b      	lsrs	r3, r3, #1
  404a26:	ea4f 0232 	mov.w	r2, r2, rrx
  404a2a:	ebb6 0e02 	subs.w	lr, r6, r2
  404a2e:	eb75 0e03 	sbcs.w	lr, r5, r3
  404a32:	bf22      	ittt	cs
  404a34:	1ab6      	subcs	r6, r6, r2
  404a36:	4675      	movcs	r5, lr
  404a38:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
  404a3c:	085b      	lsrs	r3, r3, #1
  404a3e:	ea4f 0232 	mov.w	r2, r2, rrx
  404a42:	ebb6 0e02 	subs.w	lr, r6, r2
  404a46:	eb75 0e03 	sbcs.w	lr, r5, r3
  404a4a:	bf22      	ittt	cs
  404a4c:	1ab6      	subcs	r6, r6, r2
  404a4e:	4675      	movcs	r5, lr
  404a50:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
  404a54:	ea55 0e06 	orrs.w	lr, r5, r6
  404a58:	d018      	beq.n	404a8c <__aeabi_ddiv+0x114>
  404a5a:	ea4f 1505 	mov.w	r5, r5, lsl #4
  404a5e:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
  404a62:	ea4f 1606 	mov.w	r6, r6, lsl #4
  404a66:	ea4f 03c3 	mov.w	r3, r3, lsl #3
  404a6a:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
  404a6e:	ea4f 02c2 	mov.w	r2, r2, lsl #3
  404a72:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
  404a76:	d1c0      	bne.n	4049fa <__aeabi_ddiv+0x82>
  404a78:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  404a7c:	d10b      	bne.n	404a96 <__aeabi_ddiv+0x11e>
  404a7e:	ea41 0100 	orr.w	r1, r1, r0
  404a82:	f04f 0000 	mov.w	r0, #0
  404a86:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
  404a8a:	e7b6      	b.n	4049fa <__aeabi_ddiv+0x82>
  404a8c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  404a90:	bf04      	itt	eq
  404a92:	4301      	orreq	r1, r0
  404a94:	2000      	moveq	r0, #0
  404a96:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  404a9a:	bf88      	it	hi
  404a9c:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  404aa0:	f63f aeaf 	bhi.w	404802 <__aeabi_dmul+0xde>
  404aa4:	ebb5 0c03 	subs.w	ip, r5, r3
  404aa8:	bf04      	itt	eq
  404aaa:	ebb6 0c02 	subseq.w	ip, r6, r2
  404aae:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  404ab2:	f150 0000 	adcs.w	r0, r0, #0
  404ab6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  404aba:	bd70      	pop	{r4, r5, r6, pc}
  404abc:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
  404ac0:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
  404ac4:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
  404ac8:	bfc2      	ittt	gt
  404aca:	ebd4 050c 	rsbsgt	r5, r4, ip
  404ace:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  404ad2:	bd70      	popgt	{r4, r5, r6, pc}
  404ad4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  404ad8:	f04f 0e00 	mov.w	lr, #0
  404adc:	3c01      	subs	r4, #1
  404ade:	e690      	b.n	404802 <__aeabi_dmul+0xde>
  404ae0:	ea45 0e06 	orr.w	lr, r5, r6
  404ae4:	e68d      	b.n	404802 <__aeabi_dmul+0xde>
  404ae6:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  404aea:	ea94 0f0c 	teq	r4, ip
  404aee:	bf08      	it	eq
  404af0:	ea95 0f0c 	teqeq	r5, ip
  404af4:	f43f af3b 	beq.w	40496e <__aeabi_dmul+0x24a>
  404af8:	ea94 0f0c 	teq	r4, ip
  404afc:	d10a      	bne.n	404b14 <__aeabi_ddiv+0x19c>
  404afe:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  404b02:	f47f af34 	bne.w	40496e <__aeabi_dmul+0x24a>
  404b06:	ea95 0f0c 	teq	r5, ip
  404b0a:	f47f af25 	bne.w	404958 <__aeabi_dmul+0x234>
  404b0e:	4610      	mov	r0, r2
  404b10:	4619      	mov	r1, r3
  404b12:	e72c      	b.n	40496e <__aeabi_dmul+0x24a>
  404b14:	ea95 0f0c 	teq	r5, ip
  404b18:	d106      	bne.n	404b28 <__aeabi_ddiv+0x1b0>
  404b1a:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  404b1e:	f43f aefd 	beq.w	40491c <__aeabi_dmul+0x1f8>
  404b22:	4610      	mov	r0, r2
  404b24:	4619      	mov	r1, r3
  404b26:	e722      	b.n	40496e <__aeabi_dmul+0x24a>
  404b28:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  404b2c:	bf18      	it	ne
  404b2e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  404b32:	f47f aec5 	bne.w	4048c0 <__aeabi_dmul+0x19c>
  404b36:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
  404b3a:	f47f af0d 	bne.w	404958 <__aeabi_dmul+0x234>
  404b3e:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
  404b42:	f47f aeeb 	bne.w	40491c <__aeabi_dmul+0x1f8>
  404b46:	e712      	b.n	40496e <__aeabi_dmul+0x24a>

00404b48 <__gedf2>:
  404b48:	f04f 3cff 	mov.w	ip, #4294967295
  404b4c:	e006      	b.n	404b5c <__cmpdf2+0x4>
  404b4e:	bf00      	nop

00404b50 <__ledf2>:
  404b50:	f04f 0c01 	mov.w	ip, #1
  404b54:	e002      	b.n	404b5c <__cmpdf2+0x4>
  404b56:	bf00      	nop

00404b58 <__cmpdf2>:
  404b58:	f04f 0c01 	mov.w	ip, #1
  404b5c:	f84d cd04 	str.w	ip, [sp, #-4]!
  404b60:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  404b64:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  404b68:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  404b6c:	bf18      	it	ne
  404b6e:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
  404b72:	d01b      	beq.n	404bac <__cmpdf2+0x54>
  404b74:	b001      	add	sp, #4
  404b76:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
  404b7a:	bf0c      	ite	eq
  404b7c:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
  404b80:	ea91 0f03 	teqne	r1, r3
  404b84:	bf02      	ittt	eq
  404b86:	ea90 0f02 	teqeq	r0, r2
  404b8a:	2000      	moveq	r0, #0
  404b8c:	4770      	bxeq	lr
  404b8e:	f110 0f00 	cmn.w	r0, #0
  404b92:	ea91 0f03 	teq	r1, r3
  404b96:	bf58      	it	pl
  404b98:	4299      	cmppl	r1, r3
  404b9a:	bf08      	it	eq
  404b9c:	4290      	cmpeq	r0, r2
  404b9e:	bf2c      	ite	cs
  404ba0:	17d8      	asrcs	r0, r3, #31
  404ba2:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
  404ba6:	f040 0001 	orr.w	r0, r0, #1
  404baa:	4770      	bx	lr
  404bac:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  404bb0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  404bb4:	d102      	bne.n	404bbc <__cmpdf2+0x64>
  404bb6:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
  404bba:	d107      	bne.n	404bcc <__cmpdf2+0x74>
  404bbc:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  404bc0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  404bc4:	d1d6      	bne.n	404b74 <__cmpdf2+0x1c>
  404bc6:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
  404bca:	d0d3      	beq.n	404b74 <__cmpdf2+0x1c>
  404bcc:	f85d 0b04 	ldr.w	r0, [sp], #4
  404bd0:	4770      	bx	lr
  404bd2:	bf00      	nop

00404bd4 <__aeabi_cdrcmple>:
  404bd4:	4684      	mov	ip, r0
  404bd6:	4610      	mov	r0, r2
  404bd8:	4662      	mov	r2, ip
  404bda:	468c      	mov	ip, r1
  404bdc:	4619      	mov	r1, r3
  404bde:	4663      	mov	r3, ip
  404be0:	e000      	b.n	404be4 <__aeabi_cdcmpeq>
  404be2:	bf00      	nop

00404be4 <__aeabi_cdcmpeq>:
  404be4:	b501      	push	{r0, lr}
  404be6:	f7ff ffb7 	bl	404b58 <__cmpdf2>
  404bea:	2800      	cmp	r0, #0
  404bec:	bf48      	it	mi
  404bee:	f110 0f00 	cmnmi.w	r0, #0
  404bf2:	bd01      	pop	{r0, pc}

00404bf4 <__aeabi_dcmpeq>:
  404bf4:	f84d ed08 	str.w	lr, [sp, #-8]!
  404bf8:	f7ff fff4 	bl	404be4 <__aeabi_cdcmpeq>
  404bfc:	bf0c      	ite	eq
  404bfe:	2001      	moveq	r0, #1
  404c00:	2000      	movne	r0, #0
  404c02:	f85d fb08 	ldr.w	pc, [sp], #8
  404c06:	bf00      	nop

00404c08 <__aeabi_dcmplt>:
  404c08:	f84d ed08 	str.w	lr, [sp, #-8]!
  404c0c:	f7ff ffea 	bl	404be4 <__aeabi_cdcmpeq>
  404c10:	bf34      	ite	cc
  404c12:	2001      	movcc	r0, #1
  404c14:	2000      	movcs	r0, #0
  404c16:	f85d fb08 	ldr.w	pc, [sp], #8
  404c1a:	bf00      	nop

00404c1c <__aeabi_dcmple>:
  404c1c:	f84d ed08 	str.w	lr, [sp, #-8]!
  404c20:	f7ff ffe0 	bl	404be4 <__aeabi_cdcmpeq>
  404c24:	bf94      	ite	ls
  404c26:	2001      	movls	r0, #1
  404c28:	2000      	movhi	r0, #0
  404c2a:	f85d fb08 	ldr.w	pc, [sp], #8
  404c2e:	bf00      	nop

00404c30 <__aeabi_dcmpge>:
  404c30:	f84d ed08 	str.w	lr, [sp, #-8]!
  404c34:	f7ff ffce 	bl	404bd4 <__aeabi_cdrcmple>
  404c38:	bf94      	ite	ls
  404c3a:	2001      	movls	r0, #1
  404c3c:	2000      	movhi	r0, #0
  404c3e:	f85d fb08 	ldr.w	pc, [sp], #8
  404c42:	bf00      	nop

00404c44 <__aeabi_dcmpgt>:
  404c44:	f84d ed08 	str.w	lr, [sp, #-8]!
  404c48:	f7ff ffc4 	bl	404bd4 <__aeabi_cdrcmple>
  404c4c:	bf34      	ite	cc
  404c4e:	2001      	movcc	r0, #1
  404c50:	2000      	movcs	r0, #0
  404c52:	f85d fb08 	ldr.w	pc, [sp], #8
  404c56:	bf00      	nop

00404c58 <__assert_func>:
  404c58:	b500      	push	{lr}
  404c5a:	4c0a      	ldr	r4, [pc, #40]	; (404c84 <__assert_func+0x2c>)
  404c5c:	6826      	ldr	r6, [r4, #0]
  404c5e:	4605      	mov	r5, r0
  404c60:	b085      	sub	sp, #20
  404c62:	461c      	mov	r4, r3
  404c64:	68f0      	ldr	r0, [r6, #12]
  404c66:	b152      	cbz	r2, 404c7e <__assert_func+0x26>
  404c68:	4b07      	ldr	r3, [pc, #28]	; (404c88 <__assert_func+0x30>)
  404c6a:	9202      	str	r2, [sp, #8]
  404c6c:	e88d 000a 	stmia.w	sp, {r1, r3}
  404c70:	4622      	mov	r2, r4
  404c72:	462b      	mov	r3, r5
  404c74:	4905      	ldr	r1, [pc, #20]	; (404c8c <__assert_func+0x34>)
  404c76:	f000 f80d 	bl	404c94 <fiprintf>
  404c7a:	f002 fe03 	bl	407884 <abort>
  404c7e:	4b04      	ldr	r3, [pc, #16]	; (404c90 <__assert_func+0x38>)
  404c80:	461a      	mov	r2, r3
  404c82:	e7f2      	b.n	404c6a <__assert_func+0x12>
  404c84:	20400438 	.word	0x20400438
  404c88:	0040ad90 	.word	0x0040ad90
  404c8c:	0040ada0 	.word	0x0040ada0
  404c90:	0040ad9c 	.word	0x0040ad9c

00404c94 <fiprintf>:
  404c94:	b40e      	push	{r1, r2, r3}
  404c96:	b510      	push	{r4, lr}
  404c98:	b083      	sub	sp, #12
  404c9a:	ab05      	add	r3, sp, #20
  404c9c:	4c06      	ldr	r4, [pc, #24]	; (404cb8 <fiprintf+0x24>)
  404c9e:	f853 2b04 	ldr.w	r2, [r3], #4
  404ca2:	9301      	str	r3, [sp, #4]
  404ca4:	4601      	mov	r1, r0
  404ca6:	6820      	ldr	r0, [r4, #0]
  404ca8:	f000 fa9e 	bl	4051e8 <_vfiprintf_r>
  404cac:	b003      	add	sp, #12
  404cae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  404cb2:	b003      	add	sp, #12
  404cb4:	4770      	bx	lr
  404cb6:	bf00      	nop
  404cb8:	20400438 	.word	0x20400438

00404cbc <__libc_init_array>:
  404cbc:	b570      	push	{r4, r5, r6, lr}
  404cbe:	4e0f      	ldr	r6, [pc, #60]	; (404cfc <__libc_init_array+0x40>)
  404cc0:	4d0f      	ldr	r5, [pc, #60]	; (404d00 <__libc_init_array+0x44>)
  404cc2:	1b76      	subs	r6, r6, r5
  404cc4:	10b6      	asrs	r6, r6, #2
  404cc6:	bf18      	it	ne
  404cc8:	2400      	movne	r4, #0
  404cca:	d005      	beq.n	404cd8 <__libc_init_array+0x1c>
  404ccc:	3401      	adds	r4, #1
  404cce:	f855 3b04 	ldr.w	r3, [r5], #4
  404cd2:	4798      	blx	r3
  404cd4:	42a6      	cmp	r6, r4
  404cd6:	d1f9      	bne.n	404ccc <__libc_init_array+0x10>
  404cd8:	4e0a      	ldr	r6, [pc, #40]	; (404d04 <__libc_init_array+0x48>)
  404cda:	4d0b      	ldr	r5, [pc, #44]	; (404d08 <__libc_init_array+0x4c>)
  404cdc:	1b76      	subs	r6, r6, r5
  404cde:	f006 f949 	bl	40af74 <_init>
  404ce2:	10b6      	asrs	r6, r6, #2
  404ce4:	bf18      	it	ne
  404ce6:	2400      	movne	r4, #0
  404ce8:	d006      	beq.n	404cf8 <__libc_init_array+0x3c>
  404cea:	3401      	adds	r4, #1
  404cec:	f855 3b04 	ldr.w	r3, [r5], #4
  404cf0:	4798      	blx	r3
  404cf2:	42a6      	cmp	r6, r4
  404cf4:	d1f9      	bne.n	404cea <__libc_init_array+0x2e>
  404cf6:	bd70      	pop	{r4, r5, r6, pc}
  404cf8:	bd70      	pop	{r4, r5, r6, pc}
  404cfa:	bf00      	nop
  404cfc:	0040af80 	.word	0x0040af80
  404d00:	0040af80 	.word	0x0040af80
  404d04:	0040af88 	.word	0x0040af88
  404d08:	0040af80 	.word	0x0040af80

00404d0c <memcpy>:
  404d0c:	4684      	mov	ip, r0
  404d0e:	ea41 0300 	orr.w	r3, r1, r0
  404d12:	f013 0303 	ands.w	r3, r3, #3
  404d16:	d16d      	bne.n	404df4 <memcpy+0xe8>
  404d18:	3a40      	subs	r2, #64	; 0x40
  404d1a:	d341      	bcc.n	404da0 <memcpy+0x94>
  404d1c:	f851 3b04 	ldr.w	r3, [r1], #4
  404d20:	f840 3b04 	str.w	r3, [r0], #4
  404d24:	f851 3b04 	ldr.w	r3, [r1], #4
  404d28:	f840 3b04 	str.w	r3, [r0], #4
  404d2c:	f851 3b04 	ldr.w	r3, [r1], #4
  404d30:	f840 3b04 	str.w	r3, [r0], #4
  404d34:	f851 3b04 	ldr.w	r3, [r1], #4
  404d38:	f840 3b04 	str.w	r3, [r0], #4
  404d3c:	f851 3b04 	ldr.w	r3, [r1], #4
  404d40:	f840 3b04 	str.w	r3, [r0], #4
  404d44:	f851 3b04 	ldr.w	r3, [r1], #4
  404d48:	f840 3b04 	str.w	r3, [r0], #4
  404d4c:	f851 3b04 	ldr.w	r3, [r1], #4
  404d50:	f840 3b04 	str.w	r3, [r0], #4
  404d54:	f851 3b04 	ldr.w	r3, [r1], #4
  404d58:	f840 3b04 	str.w	r3, [r0], #4
  404d5c:	f851 3b04 	ldr.w	r3, [r1], #4
  404d60:	f840 3b04 	str.w	r3, [r0], #4
  404d64:	f851 3b04 	ldr.w	r3, [r1], #4
  404d68:	f840 3b04 	str.w	r3, [r0], #4
  404d6c:	f851 3b04 	ldr.w	r3, [r1], #4
  404d70:	f840 3b04 	str.w	r3, [r0], #4
  404d74:	f851 3b04 	ldr.w	r3, [r1], #4
  404d78:	f840 3b04 	str.w	r3, [r0], #4
  404d7c:	f851 3b04 	ldr.w	r3, [r1], #4
  404d80:	f840 3b04 	str.w	r3, [r0], #4
  404d84:	f851 3b04 	ldr.w	r3, [r1], #4
  404d88:	f840 3b04 	str.w	r3, [r0], #4
  404d8c:	f851 3b04 	ldr.w	r3, [r1], #4
  404d90:	f840 3b04 	str.w	r3, [r0], #4
  404d94:	f851 3b04 	ldr.w	r3, [r1], #4
  404d98:	f840 3b04 	str.w	r3, [r0], #4
  404d9c:	3a40      	subs	r2, #64	; 0x40
  404d9e:	d2bd      	bcs.n	404d1c <memcpy+0x10>
  404da0:	3230      	adds	r2, #48	; 0x30
  404da2:	d311      	bcc.n	404dc8 <memcpy+0xbc>
  404da4:	f851 3b04 	ldr.w	r3, [r1], #4
  404da8:	f840 3b04 	str.w	r3, [r0], #4
  404dac:	f851 3b04 	ldr.w	r3, [r1], #4
  404db0:	f840 3b04 	str.w	r3, [r0], #4
  404db4:	f851 3b04 	ldr.w	r3, [r1], #4
  404db8:	f840 3b04 	str.w	r3, [r0], #4
  404dbc:	f851 3b04 	ldr.w	r3, [r1], #4
  404dc0:	f840 3b04 	str.w	r3, [r0], #4
  404dc4:	3a10      	subs	r2, #16
  404dc6:	d2ed      	bcs.n	404da4 <memcpy+0x98>
  404dc8:	320c      	adds	r2, #12
  404dca:	d305      	bcc.n	404dd8 <memcpy+0xcc>
  404dcc:	f851 3b04 	ldr.w	r3, [r1], #4
  404dd0:	f840 3b04 	str.w	r3, [r0], #4
  404dd4:	3a04      	subs	r2, #4
  404dd6:	d2f9      	bcs.n	404dcc <memcpy+0xc0>
  404dd8:	3204      	adds	r2, #4
  404dda:	d008      	beq.n	404dee <memcpy+0xe2>
  404ddc:	07d2      	lsls	r2, r2, #31
  404dde:	bf1c      	itt	ne
  404de0:	f811 3b01 	ldrbne.w	r3, [r1], #1
  404de4:	f800 3b01 	strbne.w	r3, [r0], #1
  404de8:	d301      	bcc.n	404dee <memcpy+0xe2>
  404dea:	880b      	ldrh	r3, [r1, #0]
  404dec:	8003      	strh	r3, [r0, #0]
  404dee:	4660      	mov	r0, ip
  404df0:	4770      	bx	lr
  404df2:	bf00      	nop
  404df4:	2a08      	cmp	r2, #8
  404df6:	d313      	bcc.n	404e20 <memcpy+0x114>
  404df8:	078b      	lsls	r3, r1, #30
  404dfa:	d08d      	beq.n	404d18 <memcpy+0xc>
  404dfc:	f010 0303 	ands.w	r3, r0, #3
  404e00:	d08a      	beq.n	404d18 <memcpy+0xc>
  404e02:	f1c3 0304 	rsb	r3, r3, #4
  404e06:	1ad2      	subs	r2, r2, r3
  404e08:	07db      	lsls	r3, r3, #31
  404e0a:	bf1c      	itt	ne
  404e0c:	f811 3b01 	ldrbne.w	r3, [r1], #1
  404e10:	f800 3b01 	strbne.w	r3, [r0], #1
  404e14:	d380      	bcc.n	404d18 <memcpy+0xc>
  404e16:	f831 3b02 	ldrh.w	r3, [r1], #2
  404e1a:	f820 3b02 	strh.w	r3, [r0], #2
  404e1e:	e77b      	b.n	404d18 <memcpy+0xc>
  404e20:	3a04      	subs	r2, #4
  404e22:	d3d9      	bcc.n	404dd8 <memcpy+0xcc>
  404e24:	3a01      	subs	r2, #1
  404e26:	f811 3b01 	ldrb.w	r3, [r1], #1
  404e2a:	f800 3b01 	strb.w	r3, [r0], #1
  404e2e:	d2f9      	bcs.n	404e24 <memcpy+0x118>
  404e30:	780b      	ldrb	r3, [r1, #0]
  404e32:	7003      	strb	r3, [r0, #0]
  404e34:	784b      	ldrb	r3, [r1, #1]
  404e36:	7043      	strb	r3, [r0, #1]
  404e38:	788b      	ldrb	r3, [r1, #2]
  404e3a:	7083      	strb	r3, [r0, #2]
  404e3c:	4660      	mov	r0, ip
  404e3e:	4770      	bx	lr

00404e40 <memset>:
  404e40:	b470      	push	{r4, r5, r6}
  404e42:	0784      	lsls	r4, r0, #30
  404e44:	d046      	beq.n	404ed4 <memset+0x94>
  404e46:	1e54      	subs	r4, r2, #1
  404e48:	2a00      	cmp	r2, #0
  404e4a:	d041      	beq.n	404ed0 <memset+0x90>
  404e4c:	b2cd      	uxtb	r5, r1
  404e4e:	4603      	mov	r3, r0
  404e50:	e002      	b.n	404e58 <memset+0x18>
  404e52:	1e62      	subs	r2, r4, #1
  404e54:	b3e4      	cbz	r4, 404ed0 <memset+0x90>
  404e56:	4614      	mov	r4, r2
  404e58:	f803 5b01 	strb.w	r5, [r3], #1
  404e5c:	079a      	lsls	r2, r3, #30
  404e5e:	d1f8      	bne.n	404e52 <memset+0x12>
  404e60:	2c03      	cmp	r4, #3
  404e62:	d92e      	bls.n	404ec2 <memset+0x82>
  404e64:	b2cd      	uxtb	r5, r1
  404e66:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
  404e6a:	2c0f      	cmp	r4, #15
  404e6c:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
  404e70:	d919      	bls.n	404ea6 <memset+0x66>
  404e72:	f103 0210 	add.w	r2, r3, #16
  404e76:	4626      	mov	r6, r4
  404e78:	3e10      	subs	r6, #16
  404e7a:	2e0f      	cmp	r6, #15
  404e7c:	f842 5c10 	str.w	r5, [r2, #-16]
  404e80:	f842 5c0c 	str.w	r5, [r2, #-12]
  404e84:	f842 5c08 	str.w	r5, [r2, #-8]
  404e88:	f842 5c04 	str.w	r5, [r2, #-4]
  404e8c:	f102 0210 	add.w	r2, r2, #16
  404e90:	d8f2      	bhi.n	404e78 <memset+0x38>
  404e92:	f1a4 0210 	sub.w	r2, r4, #16
  404e96:	f022 020f 	bic.w	r2, r2, #15
  404e9a:	f004 040f 	and.w	r4, r4, #15
  404e9e:	3210      	adds	r2, #16
  404ea0:	2c03      	cmp	r4, #3
  404ea2:	4413      	add	r3, r2
  404ea4:	d90d      	bls.n	404ec2 <memset+0x82>
  404ea6:	461e      	mov	r6, r3
  404ea8:	4622      	mov	r2, r4
  404eaa:	3a04      	subs	r2, #4
  404eac:	2a03      	cmp	r2, #3
  404eae:	f846 5b04 	str.w	r5, [r6], #4
  404eb2:	d8fa      	bhi.n	404eaa <memset+0x6a>
  404eb4:	1f22      	subs	r2, r4, #4
  404eb6:	f022 0203 	bic.w	r2, r2, #3
  404eba:	3204      	adds	r2, #4
  404ebc:	4413      	add	r3, r2
  404ebe:	f004 0403 	and.w	r4, r4, #3
  404ec2:	b12c      	cbz	r4, 404ed0 <memset+0x90>
  404ec4:	b2c9      	uxtb	r1, r1
  404ec6:	441c      	add	r4, r3
  404ec8:	f803 1b01 	strb.w	r1, [r3], #1
  404ecc:	42a3      	cmp	r3, r4
  404ece:	d1fb      	bne.n	404ec8 <memset+0x88>
  404ed0:	bc70      	pop	{r4, r5, r6}
  404ed2:	4770      	bx	lr
  404ed4:	4614      	mov	r4, r2
  404ed6:	4603      	mov	r3, r0
  404ed8:	e7c2      	b.n	404e60 <memset+0x20>
  404eda:	bf00      	nop

00404edc <printf>:
  404edc:	b40f      	push	{r0, r1, r2, r3}
  404ede:	b500      	push	{lr}
  404ee0:	4907      	ldr	r1, [pc, #28]	; (404f00 <printf+0x24>)
  404ee2:	b083      	sub	sp, #12
  404ee4:	ab04      	add	r3, sp, #16
  404ee6:	6808      	ldr	r0, [r1, #0]
  404ee8:	f853 2b04 	ldr.w	r2, [r3], #4
  404eec:	6881      	ldr	r1, [r0, #8]
  404eee:	9301      	str	r3, [sp, #4]
  404ef0:	f001 f8ae 	bl	406050 <_vfprintf_r>
  404ef4:	b003      	add	sp, #12
  404ef6:	f85d eb04 	ldr.w	lr, [sp], #4
  404efa:	b004      	add	sp, #16
  404efc:	4770      	bx	lr
  404efe:	bf00      	nop
  404f00:	20400438 	.word	0x20400438

00404f04 <setvbuf>:
  404f04:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  404f08:	4c51      	ldr	r4, [pc, #324]	; (405050 <setvbuf+0x14c>)
  404f0a:	6825      	ldr	r5, [r4, #0]
  404f0c:	b083      	sub	sp, #12
  404f0e:	4604      	mov	r4, r0
  404f10:	460f      	mov	r7, r1
  404f12:	4690      	mov	r8, r2
  404f14:	461e      	mov	r6, r3
  404f16:	b115      	cbz	r5, 404f1e <setvbuf+0x1a>
  404f18:	6bab      	ldr	r3, [r5, #56]	; 0x38
  404f1a:	2b00      	cmp	r3, #0
  404f1c:	d079      	beq.n	405012 <setvbuf+0x10e>
  404f1e:	f1b8 0f02 	cmp.w	r8, #2
  404f22:	d004      	beq.n	404f2e <setvbuf+0x2a>
  404f24:	f1b8 0f01 	cmp.w	r8, #1
  404f28:	d87f      	bhi.n	40502a <setvbuf+0x126>
  404f2a:	2e00      	cmp	r6, #0
  404f2c:	db7d      	blt.n	40502a <setvbuf+0x126>
  404f2e:	4621      	mov	r1, r4
  404f30:	4628      	mov	r0, r5
  404f32:	f003 fd19 	bl	408968 <_fflush_r>
  404f36:	6b21      	ldr	r1, [r4, #48]	; 0x30
  404f38:	b141      	cbz	r1, 404f4c <setvbuf+0x48>
  404f3a:	f104 0340 	add.w	r3, r4, #64	; 0x40
  404f3e:	4299      	cmp	r1, r3
  404f40:	d002      	beq.n	404f48 <setvbuf+0x44>
  404f42:	4628      	mov	r0, r5
  404f44:	f003 fe6e 	bl	408c24 <_free_r>
  404f48:	2300      	movs	r3, #0
  404f4a:	6323      	str	r3, [r4, #48]	; 0x30
  404f4c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  404f50:	2200      	movs	r2, #0
  404f52:	61a2      	str	r2, [r4, #24]
  404f54:	6062      	str	r2, [r4, #4]
  404f56:	061a      	lsls	r2, r3, #24
  404f58:	d454      	bmi.n	405004 <setvbuf+0x100>
  404f5a:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
  404f5e:	f023 0303 	bic.w	r3, r3, #3
  404f62:	f1b8 0f02 	cmp.w	r8, #2
  404f66:	81a3      	strh	r3, [r4, #12]
  404f68:	d039      	beq.n	404fde <setvbuf+0xda>
  404f6a:	ab01      	add	r3, sp, #4
  404f6c:	466a      	mov	r2, sp
  404f6e:	4621      	mov	r1, r4
  404f70:	4628      	mov	r0, r5
  404f72:	f004 f8f9 	bl	409168 <__swhatbuf_r>
  404f76:	89a3      	ldrh	r3, [r4, #12]
  404f78:	4318      	orrs	r0, r3
  404f7a:	81a0      	strh	r0, [r4, #12]
  404f7c:	b326      	cbz	r6, 404fc8 <setvbuf+0xc4>
  404f7e:	b327      	cbz	r7, 404fca <setvbuf+0xc6>
  404f80:	6bab      	ldr	r3, [r5, #56]	; 0x38
  404f82:	2b00      	cmp	r3, #0
  404f84:	d04d      	beq.n	405022 <setvbuf+0x11e>
  404f86:	9b00      	ldr	r3, [sp, #0]
  404f88:	f9b4 000c 	ldrsh.w	r0, [r4, #12]
  404f8c:	6027      	str	r7, [r4, #0]
  404f8e:	429e      	cmp	r6, r3
  404f90:	bf1c      	itt	ne
  404f92:	f440 6000 	orrne.w	r0, r0, #2048	; 0x800
  404f96:	81a0      	strhne	r0, [r4, #12]
  404f98:	f1b8 0f01 	cmp.w	r8, #1
  404f9c:	bf08      	it	eq
  404f9e:	f040 0001 	orreq.w	r0, r0, #1
  404fa2:	b283      	uxth	r3, r0
  404fa4:	bf08      	it	eq
  404fa6:	81a0      	strheq	r0, [r4, #12]
  404fa8:	f003 0008 	and.w	r0, r3, #8
  404fac:	b280      	uxth	r0, r0
  404fae:	6127      	str	r7, [r4, #16]
  404fb0:	6166      	str	r6, [r4, #20]
  404fb2:	b318      	cbz	r0, 404ffc <setvbuf+0xf8>
  404fb4:	f013 0001 	ands.w	r0, r3, #1
  404fb8:	d02f      	beq.n	40501a <setvbuf+0x116>
  404fba:	2000      	movs	r0, #0
  404fbc:	4276      	negs	r6, r6
  404fbe:	61a6      	str	r6, [r4, #24]
  404fc0:	60a0      	str	r0, [r4, #8]
  404fc2:	b003      	add	sp, #12
  404fc4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  404fc8:	9e00      	ldr	r6, [sp, #0]
  404fca:	4630      	mov	r0, r6
  404fcc:	f004 f940 	bl	409250 <malloc>
  404fd0:	4607      	mov	r7, r0
  404fd2:	b368      	cbz	r0, 405030 <setvbuf+0x12c>
  404fd4:	89a3      	ldrh	r3, [r4, #12]
  404fd6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  404fda:	81a3      	strh	r3, [r4, #12]
  404fdc:	e7d0      	b.n	404f80 <setvbuf+0x7c>
  404fde:	2000      	movs	r0, #0
  404fe0:	f104 0243 	add.w	r2, r4, #67	; 0x43
  404fe4:	f043 0302 	orr.w	r3, r3, #2
  404fe8:	2500      	movs	r5, #0
  404fea:	2101      	movs	r1, #1
  404fec:	81a3      	strh	r3, [r4, #12]
  404fee:	60a5      	str	r5, [r4, #8]
  404ff0:	6022      	str	r2, [r4, #0]
  404ff2:	6122      	str	r2, [r4, #16]
  404ff4:	6161      	str	r1, [r4, #20]
  404ff6:	b003      	add	sp, #12
  404ff8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  404ffc:	60a0      	str	r0, [r4, #8]
  404ffe:	b003      	add	sp, #12
  405000:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  405004:	6921      	ldr	r1, [r4, #16]
  405006:	4628      	mov	r0, r5
  405008:	f003 fe0c 	bl	408c24 <_free_r>
  40500c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  405010:	e7a3      	b.n	404f5a <setvbuf+0x56>
  405012:	4628      	mov	r0, r5
  405014:	f003 fd3c 	bl	408a90 <__sinit>
  405018:	e781      	b.n	404f1e <setvbuf+0x1a>
  40501a:	60a6      	str	r6, [r4, #8]
  40501c:	b003      	add	sp, #12
  40501e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  405022:	4628      	mov	r0, r5
  405024:	f003 fd34 	bl	408a90 <__sinit>
  405028:	e7ad      	b.n	404f86 <setvbuf+0x82>
  40502a:	f04f 30ff 	mov.w	r0, #4294967295
  40502e:	e7e2      	b.n	404ff6 <setvbuf+0xf2>
  405030:	f8dd 9000 	ldr.w	r9, [sp]
  405034:	45b1      	cmp	r9, r6
  405036:	d006      	beq.n	405046 <setvbuf+0x142>
  405038:	4648      	mov	r0, r9
  40503a:	f004 f909 	bl	409250 <malloc>
  40503e:	4607      	mov	r7, r0
  405040:	b108      	cbz	r0, 405046 <setvbuf+0x142>
  405042:	464e      	mov	r6, r9
  405044:	e7c6      	b.n	404fd4 <setvbuf+0xd0>
  405046:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  40504a:	f04f 30ff 	mov.w	r0, #4294967295
  40504e:	e7c7      	b.n	404fe0 <setvbuf+0xdc>
  405050:	20400438 	.word	0x20400438
	...

00405080 <strlen>:
  405080:	f890 f000 	pld	[r0]
  405084:	e96d 4502 	strd	r4, r5, [sp, #-8]!
  405088:	f020 0107 	bic.w	r1, r0, #7
  40508c:	f06f 0c00 	mvn.w	ip, #0
  405090:	f010 0407 	ands.w	r4, r0, #7
  405094:	f891 f020 	pld	[r1, #32]
  405098:	f040 8049 	bne.w	40512e <strlen+0xae>
  40509c:	f04f 0400 	mov.w	r4, #0
  4050a0:	f06f 0007 	mvn.w	r0, #7
  4050a4:	e9d1 2300 	ldrd	r2, r3, [r1]
  4050a8:	f891 f040 	pld	[r1, #64]	; 0x40
  4050ac:	f100 0008 	add.w	r0, r0, #8
  4050b0:	fa82 f24c 	uadd8	r2, r2, ip
  4050b4:	faa4 f28c 	sel	r2, r4, ip
  4050b8:	fa83 f34c 	uadd8	r3, r3, ip
  4050bc:	faa2 f38c 	sel	r3, r2, ip
  4050c0:	bb4b      	cbnz	r3, 405116 <strlen+0x96>
  4050c2:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
  4050c6:	fa82 f24c 	uadd8	r2, r2, ip
  4050ca:	f100 0008 	add.w	r0, r0, #8
  4050ce:	faa4 f28c 	sel	r2, r4, ip
  4050d2:	fa83 f34c 	uadd8	r3, r3, ip
  4050d6:	faa2 f38c 	sel	r3, r2, ip
  4050da:	b9e3      	cbnz	r3, 405116 <strlen+0x96>
  4050dc:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
  4050e0:	fa82 f24c 	uadd8	r2, r2, ip
  4050e4:	f100 0008 	add.w	r0, r0, #8
  4050e8:	faa4 f28c 	sel	r2, r4, ip
  4050ec:	fa83 f34c 	uadd8	r3, r3, ip
  4050f0:	faa2 f38c 	sel	r3, r2, ip
  4050f4:	b97b      	cbnz	r3, 405116 <strlen+0x96>
  4050f6:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
  4050fa:	f101 0120 	add.w	r1, r1, #32
  4050fe:	fa82 f24c 	uadd8	r2, r2, ip
  405102:	f100 0008 	add.w	r0, r0, #8
  405106:	faa4 f28c 	sel	r2, r4, ip
  40510a:	fa83 f34c 	uadd8	r3, r3, ip
  40510e:	faa2 f38c 	sel	r3, r2, ip
  405112:	2b00      	cmp	r3, #0
  405114:	d0c6      	beq.n	4050a4 <strlen+0x24>
  405116:	2a00      	cmp	r2, #0
  405118:	bf04      	itt	eq
  40511a:	3004      	addeq	r0, #4
  40511c:	461a      	moveq	r2, r3
  40511e:	ba12      	rev	r2, r2
  405120:	fab2 f282 	clz	r2, r2
  405124:	e8fd 4502 	ldrd	r4, r5, [sp], #8
  405128:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
  40512c:	4770      	bx	lr
  40512e:	e9d1 2300 	ldrd	r2, r3, [r1]
  405132:	f004 0503 	and.w	r5, r4, #3
  405136:	f1c4 0000 	rsb	r0, r4, #0
  40513a:	ea4f 05c5 	mov.w	r5, r5, lsl #3
  40513e:	f014 0f04 	tst.w	r4, #4
  405142:	f891 f040 	pld	[r1, #64]	; 0x40
  405146:	fa0c f505 	lsl.w	r5, ip, r5
  40514a:	ea62 0205 	orn	r2, r2, r5
  40514e:	bf1c      	itt	ne
  405150:	ea63 0305 	ornne	r3, r3, r5
  405154:	4662      	movne	r2, ip
  405156:	f04f 0400 	mov.w	r4, #0
  40515a:	e7a9      	b.n	4050b0 <strlen+0x30>

0040515c <__sprint_r.part.0>:
  40515c:	6e4b      	ldr	r3, [r1, #100]	; 0x64
  40515e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  405162:	049c      	lsls	r4, r3, #18
  405164:	4692      	mov	sl, r2
  405166:	d52c      	bpl.n	4051c2 <__sprint_r.part.0+0x66>
  405168:	6893      	ldr	r3, [r2, #8]
  40516a:	6812      	ldr	r2, [r2, #0]
  40516c:	b33b      	cbz	r3, 4051be <__sprint_r.part.0+0x62>
  40516e:	460f      	mov	r7, r1
  405170:	4680      	mov	r8, r0
  405172:	f102 0908 	add.w	r9, r2, #8
  405176:	e919 0060 	ldmdb	r9, {r5, r6}
  40517a:	08b6      	lsrs	r6, r6, #2
  40517c:	d017      	beq.n	4051ae <__sprint_r.part.0+0x52>
  40517e:	3d04      	subs	r5, #4
  405180:	2400      	movs	r4, #0
  405182:	e001      	b.n	405188 <__sprint_r.part.0+0x2c>
  405184:	42a6      	cmp	r6, r4
  405186:	d010      	beq.n	4051aa <__sprint_r.part.0+0x4e>
  405188:	463a      	mov	r2, r7
  40518a:	f855 1f04 	ldr.w	r1, [r5, #4]!
  40518e:	4640      	mov	r0, r8
  405190:	f003 fce8 	bl	408b64 <_fputwc_r>
  405194:	1c43      	adds	r3, r0, #1
  405196:	f104 0401 	add.w	r4, r4, #1
  40519a:	d1f3      	bne.n	405184 <__sprint_r.part.0+0x28>
  40519c:	2300      	movs	r3, #0
  40519e:	f8ca 3008 	str.w	r3, [sl, #8]
  4051a2:	f8ca 3004 	str.w	r3, [sl, #4]
  4051a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  4051aa:	f8da 3008 	ldr.w	r3, [sl, #8]
  4051ae:	eba3 0386 	sub.w	r3, r3, r6, lsl #2
  4051b2:	f8ca 3008 	str.w	r3, [sl, #8]
  4051b6:	f109 0908 	add.w	r9, r9, #8
  4051ba:	2b00      	cmp	r3, #0
  4051bc:	d1db      	bne.n	405176 <__sprint_r.part.0+0x1a>
  4051be:	2000      	movs	r0, #0
  4051c0:	e7ec      	b.n	40519c <__sprint_r.part.0+0x40>
  4051c2:	f003 fe17 	bl	408df4 <__sfvwrite_r>
  4051c6:	2300      	movs	r3, #0
  4051c8:	f8ca 3008 	str.w	r3, [sl, #8]
  4051cc:	f8ca 3004 	str.w	r3, [sl, #4]
  4051d0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

004051d4 <__sprint_r>:
  4051d4:	6893      	ldr	r3, [r2, #8]
  4051d6:	b10b      	cbz	r3, 4051dc <__sprint_r+0x8>
  4051d8:	f7ff bfc0 	b.w	40515c <__sprint_r.part.0>
  4051dc:	b410      	push	{r4}
  4051de:	4618      	mov	r0, r3
  4051e0:	6053      	str	r3, [r2, #4]
  4051e2:	bc10      	pop	{r4}
  4051e4:	4770      	bx	lr
  4051e6:	bf00      	nop

004051e8 <_vfiprintf_r>:
  4051e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4051ec:	b0ab      	sub	sp, #172	; 0xac
  4051ee:	461c      	mov	r4, r3
  4051f0:	9100      	str	r1, [sp, #0]
  4051f2:	4690      	mov	r8, r2
  4051f4:	9304      	str	r3, [sp, #16]
  4051f6:	9005      	str	r0, [sp, #20]
  4051f8:	b118      	cbz	r0, 405202 <_vfiprintf_r+0x1a>
  4051fa:	6b83      	ldr	r3, [r0, #56]	; 0x38
  4051fc:	2b00      	cmp	r3, #0
  4051fe:	f000 80de 	beq.w	4053be <_vfiprintf_r+0x1d6>
  405202:	9800      	ldr	r0, [sp, #0]
  405204:	f9b0 100c 	ldrsh.w	r1, [r0, #12]
  405208:	b28a      	uxth	r2, r1
  40520a:	0495      	lsls	r5, r2, #18
  40520c:	d407      	bmi.n	40521e <_vfiprintf_r+0x36>
  40520e:	6e43      	ldr	r3, [r0, #100]	; 0x64
  405210:	f441 5200 	orr.w	r2, r1, #8192	; 0x2000
  405214:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  405218:	8182      	strh	r2, [r0, #12]
  40521a:	6643      	str	r3, [r0, #100]	; 0x64
  40521c:	b292      	uxth	r2, r2
  40521e:	0711      	lsls	r1, r2, #28
  405220:	f140 80b1 	bpl.w	405386 <_vfiprintf_r+0x19e>
  405224:	9b00      	ldr	r3, [sp, #0]
  405226:	691b      	ldr	r3, [r3, #16]
  405228:	2b00      	cmp	r3, #0
  40522a:	f000 80ac 	beq.w	405386 <_vfiprintf_r+0x19e>
  40522e:	f002 021a 	and.w	r2, r2, #26
  405232:	2a0a      	cmp	r2, #10
  405234:	f000 80b5 	beq.w	4053a2 <_vfiprintf_r+0x1ba>
  405238:	2300      	movs	r3, #0
  40523a:	f10d 0b68 	add.w	fp, sp, #104	; 0x68
  40523e:	9302      	str	r3, [sp, #8]
  405240:	930f      	str	r3, [sp, #60]	; 0x3c
  405242:	930e      	str	r3, [sp, #56]	; 0x38
  405244:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
  405248:	46da      	mov	sl, fp
  40524a:	f898 3000 	ldrb.w	r3, [r8]
  40524e:	4644      	mov	r4, r8
  405250:	b1fb      	cbz	r3, 405292 <_vfiprintf_r+0xaa>
  405252:	2b25      	cmp	r3, #37	; 0x25
  405254:	d102      	bne.n	40525c <_vfiprintf_r+0x74>
  405256:	e01c      	b.n	405292 <_vfiprintf_r+0xaa>
  405258:	2b25      	cmp	r3, #37	; 0x25
  40525a:	d003      	beq.n	405264 <_vfiprintf_r+0x7c>
  40525c:	f814 3f01 	ldrb.w	r3, [r4, #1]!
  405260:	2b00      	cmp	r3, #0
  405262:	d1f9      	bne.n	405258 <_vfiprintf_r+0x70>
  405264:	ebc8 0504 	rsb	r5, r8, r4
  405268:	b19d      	cbz	r5, 405292 <_vfiprintf_r+0xaa>
  40526a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  40526c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  40526e:	f8ca 8000 	str.w	r8, [sl]
  405272:	3301      	adds	r3, #1
  405274:	442a      	add	r2, r5
  405276:	2b07      	cmp	r3, #7
  405278:	f8ca 5004 	str.w	r5, [sl, #4]
  40527c:	920f      	str	r2, [sp, #60]	; 0x3c
  40527e:	930e      	str	r3, [sp, #56]	; 0x38
  405280:	dd7b      	ble.n	40537a <_vfiprintf_r+0x192>
  405282:	2a00      	cmp	r2, #0
  405284:	f040 8528 	bne.w	405cd8 <_vfiprintf_r+0xaf0>
  405288:	9b02      	ldr	r3, [sp, #8]
  40528a:	920e      	str	r2, [sp, #56]	; 0x38
  40528c:	442b      	add	r3, r5
  40528e:	46da      	mov	sl, fp
  405290:	9302      	str	r3, [sp, #8]
  405292:	7823      	ldrb	r3, [r4, #0]
  405294:	2b00      	cmp	r3, #0
  405296:	f000 843e 	beq.w	405b16 <_vfiprintf_r+0x92e>
  40529a:	2100      	movs	r1, #0
  40529c:	f04f 0300 	mov.w	r3, #0
  4052a0:	f04f 32ff 	mov.w	r2, #4294967295
  4052a4:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
  4052a8:	f104 0801 	add.w	r8, r4, #1
  4052ac:	7863      	ldrb	r3, [r4, #1]
  4052ae:	9201      	str	r2, [sp, #4]
  4052b0:	4608      	mov	r0, r1
  4052b2:	460e      	mov	r6, r1
  4052b4:	460c      	mov	r4, r1
  4052b6:	f108 0801 	add.w	r8, r8, #1
  4052ba:	f1a3 0220 	sub.w	r2, r3, #32
  4052be:	2a58      	cmp	r2, #88	; 0x58
  4052c0:	f200 8393 	bhi.w	4059ea <_vfiprintf_r+0x802>
  4052c4:	e8df f012 	tbh	[pc, r2, lsl #1]
  4052c8:	03910346 	.word	0x03910346
  4052cc:	034e0391 	.word	0x034e0391
  4052d0:	03910391 	.word	0x03910391
  4052d4:	03910391 	.word	0x03910391
  4052d8:	03910391 	.word	0x03910391
  4052dc:	02670289 	.word	0x02670289
  4052e0:	00800391 	.word	0x00800391
  4052e4:	0391026c 	.word	0x0391026c
  4052e8:	025901c6 	.word	0x025901c6
  4052ec:	02590259 	.word	0x02590259
  4052f0:	02590259 	.word	0x02590259
  4052f4:	02590259 	.word	0x02590259
  4052f8:	02590259 	.word	0x02590259
  4052fc:	03910391 	.word	0x03910391
  405300:	03910391 	.word	0x03910391
  405304:	03910391 	.word	0x03910391
  405308:	03910391 	.word	0x03910391
  40530c:	03910391 	.word	0x03910391
  405310:	039101cb 	.word	0x039101cb
  405314:	03910391 	.word	0x03910391
  405318:	03910391 	.word	0x03910391
  40531c:	03910391 	.word	0x03910391
  405320:	03910391 	.word	0x03910391
  405324:	02140391 	.word	0x02140391
  405328:	03910391 	.word	0x03910391
  40532c:	03910391 	.word	0x03910391
  405330:	02ee0391 	.word	0x02ee0391
  405334:	03910391 	.word	0x03910391
  405338:	03910311 	.word	0x03910311
  40533c:	03910391 	.word	0x03910391
  405340:	03910391 	.word	0x03910391
  405344:	03910391 	.word	0x03910391
  405348:	03910391 	.word	0x03910391
  40534c:	03340391 	.word	0x03340391
  405350:	0391038a 	.word	0x0391038a
  405354:	03910391 	.word	0x03910391
  405358:	038a0367 	.word	0x038a0367
  40535c:	03910391 	.word	0x03910391
  405360:	0391036c 	.word	0x0391036c
  405364:	02950379 	.word	0x02950379
  405368:	02e90085 	.word	0x02e90085
  40536c:	029b0391 	.word	0x029b0391
  405370:	02ba0391 	.word	0x02ba0391
  405374:	03910391 	.word	0x03910391
  405378:	0353      	.short	0x0353
  40537a:	f10a 0a08 	add.w	sl, sl, #8
  40537e:	9b02      	ldr	r3, [sp, #8]
  405380:	442b      	add	r3, r5
  405382:	9302      	str	r3, [sp, #8]
  405384:	e785      	b.n	405292 <_vfiprintf_r+0xaa>
  405386:	9900      	ldr	r1, [sp, #0]
  405388:	9805      	ldr	r0, [sp, #20]
  40538a:	f002 fa0d 	bl	4077a8 <__swsetup_r>
  40538e:	2800      	cmp	r0, #0
  405390:	f040 8558 	bne.w	405e44 <_vfiprintf_r+0xc5c>
  405394:	9b00      	ldr	r3, [sp, #0]
  405396:	899a      	ldrh	r2, [r3, #12]
  405398:	f002 021a 	and.w	r2, r2, #26
  40539c:	2a0a      	cmp	r2, #10
  40539e:	f47f af4b 	bne.w	405238 <_vfiprintf_r+0x50>
  4053a2:	9900      	ldr	r1, [sp, #0]
  4053a4:	f9b1 300e 	ldrsh.w	r3, [r1, #14]
  4053a8:	2b00      	cmp	r3, #0
  4053aa:	f6ff af45 	blt.w	405238 <_vfiprintf_r+0x50>
  4053ae:	4623      	mov	r3, r4
  4053b0:	4642      	mov	r2, r8
  4053b2:	9805      	ldr	r0, [sp, #20]
  4053b4:	f000 fe16 	bl	405fe4 <__sbprintf>
  4053b8:	b02b      	add	sp, #172	; 0xac
  4053ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4053be:	f003 fb67 	bl	408a90 <__sinit>
  4053c2:	e71e      	b.n	405202 <_vfiprintf_r+0x1a>
  4053c4:	4264      	negs	r4, r4
  4053c6:	9304      	str	r3, [sp, #16]
  4053c8:	f046 0604 	orr.w	r6, r6, #4
  4053cc:	f898 3000 	ldrb.w	r3, [r8]
  4053d0:	e771      	b.n	4052b6 <_vfiprintf_r+0xce>
  4053d2:	2130      	movs	r1, #48	; 0x30
  4053d4:	9804      	ldr	r0, [sp, #16]
  4053d6:	f88d 1030 	strb.w	r1, [sp, #48]	; 0x30
  4053da:	9901      	ldr	r1, [sp, #4]
  4053dc:	9406      	str	r4, [sp, #24]
  4053de:	f04f 0300 	mov.w	r3, #0
  4053e2:	2278      	movs	r2, #120	; 0x78
  4053e4:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
  4053e8:	2900      	cmp	r1, #0
  4053ea:	4603      	mov	r3, r0
  4053ec:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
  4053f0:	6804      	ldr	r4, [r0, #0]
  4053f2:	f103 0304 	add.w	r3, r3, #4
  4053f6:	f04f 0500 	mov.w	r5, #0
  4053fa:	f046 0202 	orr.w	r2, r6, #2
  4053fe:	f2c0 8525 	blt.w	405e4c <_vfiprintf_r+0xc64>
  405402:	f026 0680 	bic.w	r6, r6, #128	; 0x80
  405406:	ea54 0205 	orrs.w	r2, r4, r5
  40540a:	f046 0602 	orr.w	r6, r6, #2
  40540e:	9304      	str	r3, [sp, #16]
  405410:	f040 84bf 	bne.w	405d92 <_vfiprintf_r+0xbaa>
  405414:	48b3      	ldr	r0, [pc, #716]	; (4056e4 <_vfiprintf_r+0x4fc>)
  405416:	9b01      	ldr	r3, [sp, #4]
  405418:	2b00      	cmp	r3, #0
  40541a:	f040 841c 	bne.w	405c56 <_vfiprintf_r+0xa6e>
  40541e:	4699      	mov	r9, r3
  405420:	2300      	movs	r3, #0
  405422:	9301      	str	r3, [sp, #4]
  405424:	9303      	str	r3, [sp, #12]
  405426:	465f      	mov	r7, fp
  405428:	9b01      	ldr	r3, [sp, #4]
  40542a:	9a03      	ldr	r2, [sp, #12]
  40542c:	4293      	cmp	r3, r2
  40542e:	bfb8      	it	lt
  405430:	4613      	movlt	r3, r2
  405432:	461d      	mov	r5, r3
  405434:	f1b9 0f00 	cmp.w	r9, #0
  405438:	d000      	beq.n	40543c <_vfiprintf_r+0x254>
  40543a:	3501      	adds	r5, #1
  40543c:	f016 0302 	ands.w	r3, r6, #2
  405440:	9307      	str	r3, [sp, #28]
  405442:	bf18      	it	ne
  405444:	3502      	addne	r5, #2
  405446:	f016 0384 	ands.w	r3, r6, #132	; 0x84
  40544a:	9308      	str	r3, [sp, #32]
  40544c:	f040 82f1 	bne.w	405a32 <_vfiprintf_r+0x84a>
  405450:	9b06      	ldr	r3, [sp, #24]
  405452:	1b5c      	subs	r4, r3, r5
  405454:	2c00      	cmp	r4, #0
  405456:	f340 82ec 	ble.w	405a32 <_vfiprintf_r+0x84a>
  40545a:	2c10      	cmp	r4, #16
  40545c:	f340 8556 	ble.w	405f0c <_vfiprintf_r+0xd24>
  405460:	f8df 9284 	ldr.w	r9, [pc, #644]	; 4056e8 <_vfiprintf_r+0x500>
  405464:	f8dd e038 	ldr.w	lr, [sp, #56]	; 0x38
  405468:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  40546a:	46d4      	mov	ip, sl
  40546c:	2310      	movs	r3, #16
  40546e:	46c2      	mov	sl, r8
  405470:	4670      	mov	r0, lr
  405472:	46a8      	mov	r8, r5
  405474:	464d      	mov	r5, r9
  405476:	f8dd 9014 	ldr.w	r9, [sp, #20]
  40547a:	e007      	b.n	40548c <_vfiprintf_r+0x2a4>
  40547c:	f100 0e02 	add.w	lr, r0, #2
  405480:	f10c 0c08 	add.w	ip, ip, #8
  405484:	4608      	mov	r0, r1
  405486:	3c10      	subs	r4, #16
  405488:	2c10      	cmp	r4, #16
  40548a:	dd13      	ble.n	4054b4 <_vfiprintf_r+0x2cc>
  40548c:	1c41      	adds	r1, r0, #1
  40548e:	3210      	adds	r2, #16
  405490:	2907      	cmp	r1, #7
  405492:	920f      	str	r2, [sp, #60]	; 0x3c
  405494:	f8cc 5000 	str.w	r5, [ip]
  405498:	f8cc 3004 	str.w	r3, [ip, #4]
  40549c:	910e      	str	r1, [sp, #56]	; 0x38
  40549e:	dded      	ble.n	40547c <_vfiprintf_r+0x294>
  4054a0:	2a00      	cmp	r2, #0
  4054a2:	f040 82b7 	bne.w	405a14 <_vfiprintf_r+0x82c>
  4054a6:	3c10      	subs	r4, #16
  4054a8:	2c10      	cmp	r4, #16
  4054aa:	4610      	mov	r0, r2
  4054ac:	f04f 0e01 	mov.w	lr, #1
  4054b0:	46dc      	mov	ip, fp
  4054b2:	dceb      	bgt.n	40548c <_vfiprintf_r+0x2a4>
  4054b4:	46a9      	mov	r9, r5
  4054b6:	4670      	mov	r0, lr
  4054b8:	4645      	mov	r5, r8
  4054ba:	46d0      	mov	r8, sl
  4054bc:	46e2      	mov	sl, ip
  4054be:	4422      	add	r2, r4
  4054c0:	2807      	cmp	r0, #7
  4054c2:	920f      	str	r2, [sp, #60]	; 0x3c
  4054c4:	f8ca 9000 	str.w	r9, [sl]
  4054c8:	f8ca 4004 	str.w	r4, [sl, #4]
  4054cc:	900e      	str	r0, [sp, #56]	; 0x38
  4054ce:	f300 8375 	bgt.w	405bbc <_vfiprintf_r+0x9d4>
  4054d2:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
  4054d6:	f10a 0a08 	add.w	sl, sl, #8
  4054da:	f100 0e01 	add.w	lr, r0, #1
  4054de:	2b00      	cmp	r3, #0
  4054e0:	f040 82b0 	bne.w	405a44 <_vfiprintf_r+0x85c>
  4054e4:	9b07      	ldr	r3, [sp, #28]
  4054e6:	2b00      	cmp	r3, #0
  4054e8:	f000 82c3 	beq.w	405a72 <_vfiprintf_r+0x88a>
  4054ec:	3202      	adds	r2, #2
  4054ee:	a90c      	add	r1, sp, #48	; 0x30
  4054f0:	2302      	movs	r3, #2
  4054f2:	f1be 0f07 	cmp.w	lr, #7
  4054f6:	920f      	str	r2, [sp, #60]	; 0x3c
  4054f8:	f8cd e038 	str.w	lr, [sp, #56]	; 0x38
  4054fc:	e88a 000a 	stmia.w	sl, {r1, r3}
  405500:	f340 8378 	ble.w	405bf4 <_vfiprintf_r+0xa0c>
  405504:	2a00      	cmp	r2, #0
  405506:	f040 840a 	bne.w	405d1e <_vfiprintf_r+0xb36>
  40550a:	9b08      	ldr	r3, [sp, #32]
  40550c:	2b80      	cmp	r3, #128	; 0x80
  40550e:	f04f 0e01 	mov.w	lr, #1
  405512:	4610      	mov	r0, r2
  405514:	46da      	mov	sl, fp
  405516:	f040 82b0 	bne.w	405a7a <_vfiprintf_r+0x892>
  40551a:	9b06      	ldr	r3, [sp, #24]
  40551c:	1b5c      	subs	r4, r3, r5
  40551e:	2c00      	cmp	r4, #0
  405520:	f340 82ab 	ble.w	405a7a <_vfiprintf_r+0x892>
  405524:	2c10      	cmp	r4, #16
  405526:	f8df 91c4 	ldr.w	r9, [pc, #452]	; 4056ec <_vfiprintf_r+0x504>
  40552a:	f340 850b 	ble.w	405f44 <_vfiprintf_r+0xd5c>
  40552e:	46d6      	mov	lr, sl
  405530:	2310      	movs	r3, #16
  405532:	46c2      	mov	sl, r8
  405534:	46a8      	mov	r8, r5
  405536:	464d      	mov	r5, r9
  405538:	f8dd 9014 	ldr.w	r9, [sp, #20]
  40553c:	e007      	b.n	40554e <_vfiprintf_r+0x366>
  40553e:	f100 0c02 	add.w	ip, r0, #2
  405542:	f10e 0e08 	add.w	lr, lr, #8
  405546:	4608      	mov	r0, r1
  405548:	3c10      	subs	r4, #16
  40554a:	2c10      	cmp	r4, #16
  40554c:	dd13      	ble.n	405576 <_vfiprintf_r+0x38e>
  40554e:	1c41      	adds	r1, r0, #1
  405550:	3210      	adds	r2, #16
  405552:	2907      	cmp	r1, #7
  405554:	920f      	str	r2, [sp, #60]	; 0x3c
  405556:	f8ce 5000 	str.w	r5, [lr]
  40555a:	f8ce 3004 	str.w	r3, [lr, #4]
  40555e:	910e      	str	r1, [sp, #56]	; 0x38
  405560:	dded      	ble.n	40553e <_vfiprintf_r+0x356>
  405562:	2a00      	cmp	r2, #0
  405564:	f040 8315 	bne.w	405b92 <_vfiprintf_r+0x9aa>
  405568:	3c10      	subs	r4, #16
  40556a:	2c10      	cmp	r4, #16
  40556c:	f04f 0c01 	mov.w	ip, #1
  405570:	4610      	mov	r0, r2
  405572:	46de      	mov	lr, fp
  405574:	dceb      	bgt.n	40554e <_vfiprintf_r+0x366>
  405576:	46a9      	mov	r9, r5
  405578:	4645      	mov	r5, r8
  40557a:	46d0      	mov	r8, sl
  40557c:	46f2      	mov	sl, lr
  40557e:	4422      	add	r2, r4
  405580:	f1bc 0f07 	cmp.w	ip, #7
  405584:	920f      	str	r2, [sp, #60]	; 0x3c
  405586:	f8ca 9000 	str.w	r9, [sl]
  40558a:	f8ca 4004 	str.w	r4, [sl, #4]
  40558e:	f8cd c038 	str.w	ip, [sp, #56]	; 0x38
  405592:	f300 83d2 	bgt.w	405d3a <_vfiprintf_r+0xb52>
  405596:	9b01      	ldr	r3, [sp, #4]
  405598:	9903      	ldr	r1, [sp, #12]
  40559a:	1a5c      	subs	r4, r3, r1
  40559c:	2c00      	cmp	r4, #0
  40559e:	f10a 0a08 	add.w	sl, sl, #8
  4055a2:	f10c 0e01 	add.w	lr, ip, #1
  4055a6:	4660      	mov	r0, ip
  4055a8:	f300 826d 	bgt.w	405a86 <_vfiprintf_r+0x89e>
  4055ac:	9903      	ldr	r1, [sp, #12]
  4055ae:	f8ca 7000 	str.w	r7, [sl]
  4055b2:	440a      	add	r2, r1
  4055b4:	f1be 0f07 	cmp.w	lr, #7
  4055b8:	920f      	str	r2, [sp, #60]	; 0x3c
  4055ba:	f8ca 1004 	str.w	r1, [sl, #4]
  4055be:	f8cd e038 	str.w	lr, [sp, #56]	; 0x38
  4055c2:	f340 82ce 	ble.w	405b62 <_vfiprintf_r+0x97a>
  4055c6:	2a00      	cmp	r2, #0
  4055c8:	f040 833a 	bne.w	405c40 <_vfiprintf_r+0xa58>
  4055cc:	0770      	lsls	r0, r6, #29
  4055ce:	920e      	str	r2, [sp, #56]	; 0x38
  4055d0:	d538      	bpl.n	405644 <_vfiprintf_r+0x45c>
  4055d2:	9b06      	ldr	r3, [sp, #24]
  4055d4:	1b5c      	subs	r4, r3, r5
  4055d6:	2c00      	cmp	r4, #0
  4055d8:	dd34      	ble.n	405644 <_vfiprintf_r+0x45c>
  4055da:	46da      	mov	sl, fp
  4055dc:	2c10      	cmp	r4, #16
  4055de:	f340 84ab 	ble.w	405f38 <_vfiprintf_r+0xd50>
  4055e2:	f8df 9104 	ldr.w	r9, [pc, #260]	; 4056e8 <_vfiprintf_r+0x500>
  4055e6:	990e      	ldr	r1, [sp, #56]	; 0x38
  4055e8:	464f      	mov	r7, r9
  4055ea:	2610      	movs	r6, #16
  4055ec:	f8dd 9014 	ldr.w	r9, [sp, #20]
  4055f0:	e006      	b.n	405600 <_vfiprintf_r+0x418>
  4055f2:	1c88      	adds	r0, r1, #2
  4055f4:	f10a 0a08 	add.w	sl, sl, #8
  4055f8:	4619      	mov	r1, r3
  4055fa:	3c10      	subs	r4, #16
  4055fc:	2c10      	cmp	r4, #16
  4055fe:	dd13      	ble.n	405628 <_vfiprintf_r+0x440>
  405600:	1c4b      	adds	r3, r1, #1
  405602:	3210      	adds	r2, #16
  405604:	2b07      	cmp	r3, #7
  405606:	920f      	str	r2, [sp, #60]	; 0x3c
  405608:	f8ca 7000 	str.w	r7, [sl]
  40560c:	f8ca 6004 	str.w	r6, [sl, #4]
  405610:	930e      	str	r3, [sp, #56]	; 0x38
  405612:	ddee      	ble.n	4055f2 <_vfiprintf_r+0x40a>
  405614:	2a00      	cmp	r2, #0
  405616:	f040 828e 	bne.w	405b36 <_vfiprintf_r+0x94e>
  40561a:	3c10      	subs	r4, #16
  40561c:	2c10      	cmp	r4, #16
  40561e:	f04f 0001 	mov.w	r0, #1
  405622:	4611      	mov	r1, r2
  405624:	46da      	mov	sl, fp
  405626:	dceb      	bgt.n	405600 <_vfiprintf_r+0x418>
  405628:	46b9      	mov	r9, r7
  40562a:	4422      	add	r2, r4
  40562c:	2807      	cmp	r0, #7
  40562e:	920f      	str	r2, [sp, #60]	; 0x3c
  405630:	f8ca 9000 	str.w	r9, [sl]
  405634:	f8ca 4004 	str.w	r4, [sl, #4]
  405638:	900e      	str	r0, [sp, #56]	; 0x38
  40563a:	f340 829b 	ble.w	405b74 <_vfiprintf_r+0x98c>
  40563e:	2a00      	cmp	r2, #0
  405640:	f040 8425 	bne.w	405e8e <_vfiprintf_r+0xca6>
  405644:	9b02      	ldr	r3, [sp, #8]
  405646:	9a06      	ldr	r2, [sp, #24]
  405648:	42aa      	cmp	r2, r5
  40564a:	bfac      	ite	ge
  40564c:	189b      	addge	r3, r3, r2
  40564e:	195b      	addlt	r3, r3, r5
  405650:	9302      	str	r3, [sp, #8]
  405652:	e299      	b.n	405b88 <_vfiprintf_r+0x9a0>
  405654:	f046 0680 	orr.w	r6, r6, #128	; 0x80
  405658:	f898 3000 	ldrb.w	r3, [r8]
  40565c:	e62b      	b.n	4052b6 <_vfiprintf_r+0xce>
  40565e:	9406      	str	r4, [sp, #24]
  405660:	2900      	cmp	r1, #0
  405662:	f040 84af 	bne.w	405fc4 <_vfiprintf_r+0xddc>
  405666:	f046 0610 	orr.w	r6, r6, #16
  40566a:	06b3      	lsls	r3, r6, #26
  40566c:	f140 8312 	bpl.w	405c94 <_vfiprintf_r+0xaac>
  405670:	9904      	ldr	r1, [sp, #16]
  405672:	3107      	adds	r1, #7
  405674:	f021 0107 	bic.w	r1, r1, #7
  405678:	e9d1 2300 	ldrd	r2, r3, [r1]
  40567c:	3108      	adds	r1, #8
  40567e:	9104      	str	r1, [sp, #16]
  405680:	4614      	mov	r4, r2
  405682:	461d      	mov	r5, r3
  405684:	2a00      	cmp	r2, #0
  405686:	f173 0300 	sbcs.w	r3, r3, #0
  40568a:	f2c0 8386 	blt.w	405d9a <_vfiprintf_r+0xbb2>
  40568e:	9b01      	ldr	r3, [sp, #4]
  405690:	f89d 902f 	ldrb.w	r9, [sp, #47]	; 0x2f
  405694:	2b00      	cmp	r3, #0
  405696:	f2c0 831a 	blt.w	405cce <_vfiprintf_r+0xae6>
  40569a:	ea54 0305 	orrs.w	r3, r4, r5
  40569e:	f026 0680 	bic.w	r6, r6, #128	; 0x80
  4056a2:	f000 80ed 	beq.w	405880 <_vfiprintf_r+0x698>
  4056a6:	2d00      	cmp	r5, #0
  4056a8:	bf08      	it	eq
  4056aa:	2c0a      	cmpeq	r4, #10
  4056ac:	f0c0 80ed 	bcc.w	40588a <_vfiprintf_r+0x6a2>
  4056b0:	465f      	mov	r7, fp
  4056b2:	4620      	mov	r0, r4
  4056b4:	4629      	mov	r1, r5
  4056b6:	220a      	movs	r2, #10
  4056b8:	2300      	movs	r3, #0
  4056ba:	f005 f8e9 	bl	40a890 <__aeabi_uldivmod>
  4056be:	3230      	adds	r2, #48	; 0x30
  4056c0:	f807 2d01 	strb.w	r2, [r7, #-1]!
  4056c4:	4620      	mov	r0, r4
  4056c6:	4629      	mov	r1, r5
  4056c8:	2300      	movs	r3, #0
  4056ca:	220a      	movs	r2, #10
  4056cc:	f005 f8e0 	bl	40a890 <__aeabi_uldivmod>
  4056d0:	4604      	mov	r4, r0
  4056d2:	460d      	mov	r5, r1
  4056d4:	ea54 0305 	orrs.w	r3, r4, r5
  4056d8:	d1eb      	bne.n	4056b2 <_vfiprintf_r+0x4ca>
  4056da:	ebc7 030b 	rsb	r3, r7, fp
  4056de:	9303      	str	r3, [sp, #12]
  4056e0:	e6a2      	b.n	405428 <_vfiprintf_r+0x240>
  4056e2:	bf00      	nop
  4056e4:	0040adfc 	.word	0x0040adfc
  4056e8:	0040ae18 	.word	0x0040ae18
  4056ec:	0040add8 	.word	0x0040add8
  4056f0:	9406      	str	r4, [sp, #24]
  4056f2:	2900      	cmp	r1, #0
  4056f4:	f040 8462 	bne.w	405fbc <_vfiprintf_r+0xdd4>
  4056f8:	f046 0610 	orr.w	r6, r6, #16
  4056fc:	f016 0320 	ands.w	r3, r6, #32
  405700:	f000 82ae 	beq.w	405c60 <_vfiprintf_r+0xa78>
  405704:	9b04      	ldr	r3, [sp, #16]
  405706:	3307      	adds	r3, #7
  405708:	f023 0307 	bic.w	r3, r3, #7
  40570c:	f04f 0200 	mov.w	r2, #0
  405710:	f88d 202f 	strb.w	r2, [sp, #47]	; 0x2f
  405714:	e9d3 4500 	ldrd	r4, r5, [r3]
  405718:	f103 0208 	add.w	r2, r3, #8
  40571c:	9b01      	ldr	r3, [sp, #4]
  40571e:	9204      	str	r2, [sp, #16]
  405720:	2b00      	cmp	r3, #0
  405722:	f2c0 8174 	blt.w	405a0e <_vfiprintf_r+0x826>
  405726:	ea54 0305 	orrs.w	r3, r4, r5
  40572a:	f026 0680 	bic.w	r6, r6, #128	; 0x80
  40572e:	f040 816e 	bne.w	405a0e <_vfiprintf_r+0x826>
  405732:	9b01      	ldr	r3, [sp, #4]
  405734:	2b00      	cmp	r3, #0
  405736:	f000 8430 	beq.w	405f9a <_vfiprintf_r+0xdb2>
  40573a:	f04f 0900 	mov.w	r9, #0
  40573e:	2400      	movs	r4, #0
  405740:	2500      	movs	r5, #0
  405742:	465f      	mov	r7, fp
  405744:	08e2      	lsrs	r2, r4, #3
  405746:	ea42 7245 	orr.w	r2, r2, r5, lsl #29
  40574a:	08e9      	lsrs	r1, r5, #3
  40574c:	f004 0307 	and.w	r3, r4, #7
  405750:	460d      	mov	r5, r1
  405752:	4614      	mov	r4, r2
  405754:	3330      	adds	r3, #48	; 0x30
  405756:	ea54 0205 	orrs.w	r2, r4, r5
  40575a:	f807 3d01 	strb.w	r3, [r7, #-1]!
  40575e:	d1f1      	bne.n	405744 <_vfiprintf_r+0x55c>
  405760:	07f4      	lsls	r4, r6, #31
  405762:	d5ba      	bpl.n	4056da <_vfiprintf_r+0x4f2>
  405764:	2b30      	cmp	r3, #48	; 0x30
  405766:	d0b8      	beq.n	4056da <_vfiprintf_r+0x4f2>
  405768:	2230      	movs	r2, #48	; 0x30
  40576a:	1e7b      	subs	r3, r7, #1
  40576c:	f807 2c01 	strb.w	r2, [r7, #-1]
  405770:	ebc3 020b 	rsb	r2, r3, fp
  405774:	9203      	str	r2, [sp, #12]
  405776:	461f      	mov	r7, r3
  405778:	e656      	b.n	405428 <_vfiprintf_r+0x240>
  40577a:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
  40577e:	2400      	movs	r4, #0
  405780:	f818 3b01 	ldrb.w	r3, [r8], #1
  405784:	eb04 0484 	add.w	r4, r4, r4, lsl #2
  405788:	eb02 0444 	add.w	r4, r2, r4, lsl #1
  40578c:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
  405790:	2a09      	cmp	r2, #9
  405792:	d9f5      	bls.n	405780 <_vfiprintf_r+0x598>
  405794:	e591      	b.n	4052ba <_vfiprintf_r+0xd2>
  405796:	f898 3000 	ldrb.w	r3, [r8]
  40579a:	2101      	movs	r1, #1
  40579c:	202b      	movs	r0, #43	; 0x2b
  40579e:	e58a      	b.n	4052b6 <_vfiprintf_r+0xce>
  4057a0:	f898 3000 	ldrb.w	r3, [r8]
  4057a4:	2b2a      	cmp	r3, #42	; 0x2a
  4057a6:	f108 0501 	add.w	r5, r8, #1
  4057aa:	f000 83dd 	beq.w	405f68 <_vfiprintf_r+0xd80>
  4057ae:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
  4057b2:	2a09      	cmp	r2, #9
  4057b4:	46a8      	mov	r8, r5
  4057b6:	bf98      	it	ls
  4057b8:	2500      	movls	r5, #0
  4057ba:	f200 83ce 	bhi.w	405f5a <_vfiprintf_r+0xd72>
  4057be:	f818 3b01 	ldrb.w	r3, [r8], #1
  4057c2:	eb05 0585 	add.w	r5, r5, r5, lsl #2
  4057c6:	eb02 0545 	add.w	r5, r2, r5, lsl #1
  4057ca:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
  4057ce:	2a09      	cmp	r2, #9
  4057d0:	d9f5      	bls.n	4057be <_vfiprintf_r+0x5d6>
  4057d2:	ea45 72e5 	orr.w	r2, r5, r5, asr #31
  4057d6:	9201      	str	r2, [sp, #4]
  4057d8:	e56f      	b.n	4052ba <_vfiprintf_r+0xd2>
  4057da:	9a04      	ldr	r2, [sp, #16]
  4057dc:	6814      	ldr	r4, [r2, #0]
  4057de:	4613      	mov	r3, r2
  4057e0:	2c00      	cmp	r4, #0
  4057e2:	f103 0304 	add.w	r3, r3, #4
  4057e6:	f6ff aded 	blt.w	4053c4 <_vfiprintf_r+0x1dc>
  4057ea:	9304      	str	r3, [sp, #16]
  4057ec:	f898 3000 	ldrb.w	r3, [r8]
  4057f0:	e561      	b.n	4052b6 <_vfiprintf_r+0xce>
  4057f2:	9406      	str	r4, [sp, #24]
  4057f4:	2900      	cmp	r1, #0
  4057f6:	d081      	beq.n	4056fc <_vfiprintf_r+0x514>
  4057f8:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
  4057fc:	e77e      	b.n	4056fc <_vfiprintf_r+0x514>
  4057fe:	9a04      	ldr	r2, [sp, #16]
  405800:	9406      	str	r4, [sp, #24]
  405802:	6817      	ldr	r7, [r2, #0]
  405804:	f04f 0300 	mov.w	r3, #0
  405808:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
  40580c:	1d14      	adds	r4, r2, #4
  40580e:	9b01      	ldr	r3, [sp, #4]
  405810:	2f00      	cmp	r7, #0
  405812:	f000 8386 	beq.w	405f22 <_vfiprintf_r+0xd3a>
  405816:	2b00      	cmp	r3, #0
  405818:	f2c0 835f 	blt.w	405eda <_vfiprintf_r+0xcf2>
  40581c:	461a      	mov	r2, r3
  40581e:	2100      	movs	r1, #0
  405820:	4638      	mov	r0, r7
  405822:	f003 ffd5 	bl	4097d0 <memchr>
  405826:	2800      	cmp	r0, #0
  405828:	f000 838f 	beq.w	405f4a <_vfiprintf_r+0xd62>
  40582c:	1bc3      	subs	r3, r0, r7
  40582e:	9303      	str	r3, [sp, #12]
  405830:	2300      	movs	r3, #0
  405832:	9404      	str	r4, [sp, #16]
  405834:	f89d 902f 	ldrb.w	r9, [sp, #47]	; 0x2f
  405838:	9301      	str	r3, [sp, #4]
  40583a:	e5f5      	b.n	405428 <_vfiprintf_r+0x240>
  40583c:	9406      	str	r4, [sp, #24]
  40583e:	2900      	cmp	r1, #0
  405840:	f040 83b9 	bne.w	405fb6 <_vfiprintf_r+0xdce>
  405844:	f016 0920 	ands.w	r9, r6, #32
  405848:	d135      	bne.n	4058b6 <_vfiprintf_r+0x6ce>
  40584a:	f016 0310 	ands.w	r3, r6, #16
  40584e:	d103      	bne.n	405858 <_vfiprintf_r+0x670>
  405850:	f016 0940 	ands.w	r9, r6, #64	; 0x40
  405854:	f040 832a 	bne.w	405eac <_vfiprintf_r+0xcc4>
  405858:	9a04      	ldr	r2, [sp, #16]
  40585a:	4613      	mov	r3, r2
  40585c:	6814      	ldr	r4, [r2, #0]
  40585e:	9a01      	ldr	r2, [sp, #4]
  405860:	f88d 902f 	strb.w	r9, [sp, #47]	; 0x2f
  405864:	2a00      	cmp	r2, #0
  405866:	f103 0304 	add.w	r3, r3, #4
  40586a:	f04f 0500 	mov.w	r5, #0
  40586e:	f2c0 8332 	blt.w	405ed6 <_vfiprintf_r+0xcee>
  405872:	ea54 0205 	orrs.w	r2, r4, r5
  405876:	f026 0680 	bic.w	r6, r6, #128	; 0x80
  40587a:	9304      	str	r3, [sp, #16]
  40587c:	f47f af13 	bne.w	4056a6 <_vfiprintf_r+0x4be>
  405880:	9b01      	ldr	r3, [sp, #4]
  405882:	2b00      	cmp	r3, #0
  405884:	f43f adcc 	beq.w	405420 <_vfiprintf_r+0x238>
  405888:	2400      	movs	r4, #0
  40588a:	af2a      	add	r7, sp, #168	; 0xa8
  40588c:	3430      	adds	r4, #48	; 0x30
  40588e:	f807 4d41 	strb.w	r4, [r7, #-65]!
  405892:	ebc7 030b 	rsb	r3, r7, fp
  405896:	9303      	str	r3, [sp, #12]
  405898:	e5c6      	b.n	405428 <_vfiprintf_r+0x240>
  40589a:	f046 0620 	orr.w	r6, r6, #32
  40589e:	f898 3000 	ldrb.w	r3, [r8]
  4058a2:	e508      	b.n	4052b6 <_vfiprintf_r+0xce>
  4058a4:	9406      	str	r4, [sp, #24]
  4058a6:	2900      	cmp	r1, #0
  4058a8:	f040 836e 	bne.w	405f88 <_vfiprintf_r+0xda0>
  4058ac:	f046 0610 	orr.w	r6, r6, #16
  4058b0:	f016 0920 	ands.w	r9, r6, #32
  4058b4:	d0c9      	beq.n	40584a <_vfiprintf_r+0x662>
  4058b6:	9b04      	ldr	r3, [sp, #16]
  4058b8:	3307      	adds	r3, #7
  4058ba:	f023 0307 	bic.w	r3, r3, #7
  4058be:	f04f 0200 	mov.w	r2, #0
  4058c2:	f88d 202f 	strb.w	r2, [sp, #47]	; 0x2f
  4058c6:	e9d3 4500 	ldrd	r4, r5, [r3]
  4058ca:	f103 0208 	add.w	r2, r3, #8
  4058ce:	9b01      	ldr	r3, [sp, #4]
  4058d0:	9204      	str	r2, [sp, #16]
  4058d2:	2b00      	cmp	r3, #0
  4058d4:	f2c0 81f9 	blt.w	405cca <_vfiprintf_r+0xae2>
  4058d8:	ea54 0305 	orrs.w	r3, r4, r5
  4058dc:	f026 0680 	bic.w	r6, r6, #128	; 0x80
  4058e0:	f04f 0900 	mov.w	r9, #0
  4058e4:	f47f aedf 	bne.w	4056a6 <_vfiprintf_r+0x4be>
  4058e8:	e7ca      	b.n	405880 <_vfiprintf_r+0x698>
  4058ea:	9406      	str	r4, [sp, #24]
  4058ec:	2900      	cmp	r1, #0
  4058ee:	f040 8351 	bne.w	405f94 <_vfiprintf_r+0xdac>
  4058f2:	06b2      	lsls	r2, r6, #26
  4058f4:	48ae      	ldr	r0, [pc, #696]	; (405bb0 <_vfiprintf_r+0x9c8>)
  4058f6:	d541      	bpl.n	40597c <_vfiprintf_r+0x794>
  4058f8:	9a04      	ldr	r2, [sp, #16]
  4058fa:	3207      	adds	r2, #7
  4058fc:	f022 0207 	bic.w	r2, r2, #7
  405900:	e9d2 4500 	ldrd	r4, r5, [r2]
  405904:	f102 0108 	add.w	r1, r2, #8
  405908:	9104      	str	r1, [sp, #16]
  40590a:	f016 0901 	ands.w	r9, r6, #1
  40590e:	f000 8177 	beq.w	405c00 <_vfiprintf_r+0xa18>
  405912:	ea54 0205 	orrs.w	r2, r4, r5
  405916:	f040 8226 	bne.w	405d66 <_vfiprintf_r+0xb7e>
  40591a:	f04f 0300 	mov.w	r3, #0
  40591e:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
  405922:	9b01      	ldr	r3, [sp, #4]
  405924:	2b00      	cmp	r3, #0
  405926:	f2c0 8196 	blt.w	405c56 <_vfiprintf_r+0xa6e>
  40592a:	f026 0680 	bic.w	r6, r6, #128	; 0x80
  40592e:	e572      	b.n	405416 <_vfiprintf_r+0x22e>
  405930:	9a04      	ldr	r2, [sp, #16]
  405932:	9406      	str	r4, [sp, #24]
  405934:	6813      	ldr	r3, [r2, #0]
  405936:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
  40593a:	4613      	mov	r3, r2
  40593c:	f04f 0100 	mov.w	r1, #0
  405940:	2501      	movs	r5, #1
  405942:	3304      	adds	r3, #4
  405944:	f88d 102f 	strb.w	r1, [sp, #47]	; 0x2f
  405948:	9304      	str	r3, [sp, #16]
  40594a:	9503      	str	r5, [sp, #12]
  40594c:	af10      	add	r7, sp, #64	; 0x40
  40594e:	2300      	movs	r3, #0
  405950:	9301      	str	r3, [sp, #4]
  405952:	e573      	b.n	40543c <_vfiprintf_r+0x254>
  405954:	f898 3000 	ldrb.w	r3, [r8]
  405958:	2800      	cmp	r0, #0
  40595a:	f47f acac 	bne.w	4052b6 <_vfiprintf_r+0xce>
  40595e:	2101      	movs	r1, #1
  405960:	2020      	movs	r0, #32
  405962:	e4a8      	b.n	4052b6 <_vfiprintf_r+0xce>
  405964:	f046 0601 	orr.w	r6, r6, #1
  405968:	f898 3000 	ldrb.w	r3, [r8]
  40596c:	e4a3      	b.n	4052b6 <_vfiprintf_r+0xce>
  40596e:	9406      	str	r4, [sp, #24]
  405970:	2900      	cmp	r1, #0
  405972:	f040 830c 	bne.w	405f8e <_vfiprintf_r+0xda6>
  405976:	06b2      	lsls	r2, r6, #26
  405978:	488e      	ldr	r0, [pc, #568]	; (405bb4 <_vfiprintf_r+0x9cc>)
  40597a:	d4bd      	bmi.n	4058f8 <_vfiprintf_r+0x710>
  40597c:	9904      	ldr	r1, [sp, #16]
  40597e:	06f7      	lsls	r7, r6, #27
  405980:	460a      	mov	r2, r1
  405982:	f100 819d 	bmi.w	405cc0 <_vfiprintf_r+0xad8>
  405986:	0675      	lsls	r5, r6, #25
  405988:	f140 819a 	bpl.w	405cc0 <_vfiprintf_r+0xad8>
  40598c:	3204      	adds	r2, #4
  40598e:	880c      	ldrh	r4, [r1, #0]
  405990:	9204      	str	r2, [sp, #16]
  405992:	2500      	movs	r5, #0
  405994:	e7b9      	b.n	40590a <_vfiprintf_r+0x722>
  405996:	f046 0640 	orr.w	r6, r6, #64	; 0x40
  40599a:	f898 3000 	ldrb.w	r3, [r8]
  40599e:	e48a      	b.n	4052b6 <_vfiprintf_r+0xce>
  4059a0:	f898 3000 	ldrb.w	r3, [r8]
  4059a4:	2b6c      	cmp	r3, #108	; 0x6c
  4059a6:	bf03      	ittte	eq
  4059a8:	f898 3001 	ldrbeq.w	r3, [r8, #1]
  4059ac:	f046 0620 	orreq.w	r6, r6, #32
  4059b0:	f108 0801 	addeq.w	r8, r8, #1
  4059b4:	f046 0610 	orrne.w	r6, r6, #16
  4059b8:	e47d      	b.n	4052b6 <_vfiprintf_r+0xce>
  4059ba:	2900      	cmp	r1, #0
  4059bc:	f040 8309 	bne.w	405fd2 <_vfiprintf_r+0xdea>
  4059c0:	06b4      	lsls	r4, r6, #26
  4059c2:	f140 821c 	bpl.w	405dfe <_vfiprintf_r+0xc16>
  4059c6:	9a04      	ldr	r2, [sp, #16]
  4059c8:	9902      	ldr	r1, [sp, #8]
  4059ca:	6813      	ldr	r3, [r2, #0]
  4059cc:	17cd      	asrs	r5, r1, #31
  4059ce:	4608      	mov	r0, r1
  4059d0:	3204      	adds	r2, #4
  4059d2:	4629      	mov	r1, r5
  4059d4:	9204      	str	r2, [sp, #16]
  4059d6:	e9c3 0100 	strd	r0, r1, [r3]
  4059da:	e436      	b.n	40524a <_vfiprintf_r+0x62>
  4059dc:	9406      	str	r4, [sp, #24]
  4059de:	2900      	cmp	r1, #0
  4059e0:	f43f ae43 	beq.w	40566a <_vfiprintf_r+0x482>
  4059e4:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
  4059e8:	e63f      	b.n	40566a <_vfiprintf_r+0x482>
  4059ea:	9406      	str	r4, [sp, #24]
  4059ec:	2900      	cmp	r1, #0
  4059ee:	f040 82ed 	bne.w	405fcc <_vfiprintf_r+0xde4>
  4059f2:	2b00      	cmp	r3, #0
  4059f4:	f000 808f 	beq.w	405b16 <_vfiprintf_r+0x92e>
  4059f8:	2501      	movs	r5, #1
  4059fa:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
  4059fe:	f04f 0300 	mov.w	r3, #0
  405a02:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
  405a06:	9503      	str	r5, [sp, #12]
  405a08:	af10      	add	r7, sp, #64	; 0x40
  405a0a:	e7a0      	b.n	40594e <_vfiprintf_r+0x766>
  405a0c:	9304      	str	r3, [sp, #16]
  405a0e:	f04f 0900 	mov.w	r9, #0
  405a12:	e696      	b.n	405742 <_vfiprintf_r+0x55a>
  405a14:	aa0d      	add	r2, sp, #52	; 0x34
  405a16:	9900      	ldr	r1, [sp, #0]
  405a18:	9309      	str	r3, [sp, #36]	; 0x24
  405a1a:	4648      	mov	r0, r9
  405a1c:	f7ff fb9e 	bl	40515c <__sprint_r.part.0>
  405a20:	2800      	cmp	r0, #0
  405a22:	d17f      	bne.n	405b24 <_vfiprintf_r+0x93c>
  405a24:	980e      	ldr	r0, [sp, #56]	; 0x38
  405a26:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  405a28:	9b09      	ldr	r3, [sp, #36]	; 0x24
  405a2a:	f100 0e01 	add.w	lr, r0, #1
  405a2e:	46dc      	mov	ip, fp
  405a30:	e529      	b.n	405486 <_vfiprintf_r+0x29e>
  405a32:	980e      	ldr	r0, [sp, #56]	; 0x38
  405a34:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  405a36:	f100 0e01 	add.w	lr, r0, #1
  405a3a:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
  405a3e:	2b00      	cmp	r3, #0
  405a40:	f43f ad50 	beq.w	4054e4 <_vfiprintf_r+0x2fc>
  405a44:	3201      	adds	r2, #1
  405a46:	f10d 012f 	add.w	r1, sp, #47	; 0x2f
  405a4a:	2301      	movs	r3, #1
  405a4c:	f1be 0f07 	cmp.w	lr, #7
  405a50:	920f      	str	r2, [sp, #60]	; 0x3c
  405a52:	f8cd e038 	str.w	lr, [sp, #56]	; 0x38
  405a56:	e88a 000a 	stmia.w	sl, {r1, r3}
  405a5a:	f340 80bf 	ble.w	405bdc <_vfiprintf_r+0x9f4>
  405a5e:	2a00      	cmp	r2, #0
  405a60:	f040 814e 	bne.w	405d00 <_vfiprintf_r+0xb18>
  405a64:	9907      	ldr	r1, [sp, #28]
  405a66:	2900      	cmp	r1, #0
  405a68:	f040 80be 	bne.w	405be8 <_vfiprintf_r+0xa00>
  405a6c:	469e      	mov	lr, r3
  405a6e:	4610      	mov	r0, r2
  405a70:	46da      	mov	sl, fp
  405a72:	9b08      	ldr	r3, [sp, #32]
  405a74:	2b80      	cmp	r3, #128	; 0x80
  405a76:	f43f ad50 	beq.w	40551a <_vfiprintf_r+0x332>
  405a7a:	9b01      	ldr	r3, [sp, #4]
  405a7c:	9903      	ldr	r1, [sp, #12]
  405a7e:	1a5c      	subs	r4, r3, r1
  405a80:	2c00      	cmp	r4, #0
  405a82:	f77f ad93 	ble.w	4055ac <_vfiprintf_r+0x3c4>
  405a86:	2c10      	cmp	r4, #16
  405a88:	f8df 912c 	ldr.w	r9, [pc, #300]	; 405bb8 <_vfiprintf_r+0x9d0>
  405a8c:	dd25      	ble.n	405ada <_vfiprintf_r+0x8f2>
  405a8e:	46d4      	mov	ip, sl
  405a90:	2310      	movs	r3, #16
  405a92:	46c2      	mov	sl, r8
  405a94:	46a8      	mov	r8, r5
  405a96:	464d      	mov	r5, r9
  405a98:	f8dd 9014 	ldr.w	r9, [sp, #20]
  405a9c:	e007      	b.n	405aae <_vfiprintf_r+0x8c6>
  405a9e:	f100 0e02 	add.w	lr, r0, #2
  405aa2:	f10c 0c08 	add.w	ip, ip, #8
  405aa6:	4608      	mov	r0, r1
  405aa8:	3c10      	subs	r4, #16
  405aaa:	2c10      	cmp	r4, #16
  405aac:	dd11      	ble.n	405ad2 <_vfiprintf_r+0x8ea>
  405aae:	1c41      	adds	r1, r0, #1
  405ab0:	3210      	adds	r2, #16
  405ab2:	2907      	cmp	r1, #7
  405ab4:	920f      	str	r2, [sp, #60]	; 0x3c
  405ab6:	f8cc 5000 	str.w	r5, [ip]
  405aba:	f8cc 3004 	str.w	r3, [ip, #4]
  405abe:	910e      	str	r1, [sp, #56]	; 0x38
  405ac0:	dded      	ble.n	405a9e <_vfiprintf_r+0x8b6>
  405ac2:	b9d2      	cbnz	r2, 405afa <_vfiprintf_r+0x912>
  405ac4:	3c10      	subs	r4, #16
  405ac6:	2c10      	cmp	r4, #16
  405ac8:	f04f 0e01 	mov.w	lr, #1
  405acc:	4610      	mov	r0, r2
  405ace:	46dc      	mov	ip, fp
  405ad0:	dced      	bgt.n	405aae <_vfiprintf_r+0x8c6>
  405ad2:	46a9      	mov	r9, r5
  405ad4:	4645      	mov	r5, r8
  405ad6:	46d0      	mov	r8, sl
  405ad8:	46e2      	mov	sl, ip
  405ada:	4422      	add	r2, r4
  405adc:	f1be 0f07 	cmp.w	lr, #7
  405ae0:	920f      	str	r2, [sp, #60]	; 0x3c
  405ae2:	f8ca 9000 	str.w	r9, [sl]
  405ae6:	f8ca 4004 	str.w	r4, [sl, #4]
  405aea:	f8cd e038 	str.w	lr, [sp, #56]	; 0x38
  405aee:	dc2e      	bgt.n	405b4e <_vfiprintf_r+0x966>
  405af0:	f10a 0a08 	add.w	sl, sl, #8
  405af4:	f10e 0e01 	add.w	lr, lr, #1
  405af8:	e558      	b.n	4055ac <_vfiprintf_r+0x3c4>
  405afa:	aa0d      	add	r2, sp, #52	; 0x34
  405afc:	9900      	ldr	r1, [sp, #0]
  405afe:	9301      	str	r3, [sp, #4]
  405b00:	4648      	mov	r0, r9
  405b02:	f7ff fb2b 	bl	40515c <__sprint_r.part.0>
  405b06:	b968      	cbnz	r0, 405b24 <_vfiprintf_r+0x93c>
  405b08:	980e      	ldr	r0, [sp, #56]	; 0x38
  405b0a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  405b0c:	9b01      	ldr	r3, [sp, #4]
  405b0e:	f100 0e01 	add.w	lr, r0, #1
  405b12:	46dc      	mov	ip, fp
  405b14:	e7c8      	b.n	405aa8 <_vfiprintf_r+0x8c0>
  405b16:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  405b18:	b123      	cbz	r3, 405b24 <_vfiprintf_r+0x93c>
  405b1a:	9805      	ldr	r0, [sp, #20]
  405b1c:	9900      	ldr	r1, [sp, #0]
  405b1e:	aa0d      	add	r2, sp, #52	; 0x34
  405b20:	f7ff fb1c 	bl	40515c <__sprint_r.part.0>
  405b24:	9b00      	ldr	r3, [sp, #0]
  405b26:	899b      	ldrh	r3, [r3, #12]
  405b28:	065a      	lsls	r2, r3, #25
  405b2a:	f100 818b 	bmi.w	405e44 <_vfiprintf_r+0xc5c>
  405b2e:	9802      	ldr	r0, [sp, #8]
  405b30:	b02b      	add	sp, #172	; 0xac
  405b32:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  405b36:	aa0d      	add	r2, sp, #52	; 0x34
  405b38:	9900      	ldr	r1, [sp, #0]
  405b3a:	4648      	mov	r0, r9
  405b3c:	f7ff fb0e 	bl	40515c <__sprint_r.part.0>
  405b40:	2800      	cmp	r0, #0
  405b42:	d1ef      	bne.n	405b24 <_vfiprintf_r+0x93c>
  405b44:	990e      	ldr	r1, [sp, #56]	; 0x38
  405b46:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  405b48:	1c48      	adds	r0, r1, #1
  405b4a:	46da      	mov	sl, fp
  405b4c:	e555      	b.n	4055fa <_vfiprintf_r+0x412>
  405b4e:	2a00      	cmp	r2, #0
  405b50:	f040 80fb 	bne.w	405d4a <_vfiprintf_r+0xb62>
  405b54:	9a03      	ldr	r2, [sp, #12]
  405b56:	921b      	str	r2, [sp, #108]	; 0x6c
  405b58:	2301      	movs	r3, #1
  405b5a:	920f      	str	r2, [sp, #60]	; 0x3c
  405b5c:	971a      	str	r7, [sp, #104]	; 0x68
  405b5e:	930e      	str	r3, [sp, #56]	; 0x38
  405b60:	46da      	mov	sl, fp
  405b62:	f10a 0a08 	add.w	sl, sl, #8
  405b66:	0771      	lsls	r1, r6, #29
  405b68:	d504      	bpl.n	405b74 <_vfiprintf_r+0x98c>
  405b6a:	9b06      	ldr	r3, [sp, #24]
  405b6c:	1b5c      	subs	r4, r3, r5
  405b6e:	2c00      	cmp	r4, #0
  405b70:	f73f ad34 	bgt.w	4055dc <_vfiprintf_r+0x3f4>
  405b74:	9b02      	ldr	r3, [sp, #8]
  405b76:	9906      	ldr	r1, [sp, #24]
  405b78:	42a9      	cmp	r1, r5
  405b7a:	bfac      	ite	ge
  405b7c:	185b      	addge	r3, r3, r1
  405b7e:	195b      	addlt	r3, r3, r5
  405b80:	9302      	str	r3, [sp, #8]
  405b82:	2a00      	cmp	r2, #0
  405b84:	f040 80b3 	bne.w	405cee <_vfiprintf_r+0xb06>
  405b88:	2300      	movs	r3, #0
  405b8a:	930e      	str	r3, [sp, #56]	; 0x38
  405b8c:	46da      	mov	sl, fp
  405b8e:	f7ff bb5c 	b.w	40524a <_vfiprintf_r+0x62>
  405b92:	aa0d      	add	r2, sp, #52	; 0x34
  405b94:	9900      	ldr	r1, [sp, #0]
  405b96:	9307      	str	r3, [sp, #28]
  405b98:	4648      	mov	r0, r9
  405b9a:	f7ff fadf 	bl	40515c <__sprint_r.part.0>
  405b9e:	2800      	cmp	r0, #0
  405ba0:	d1c0      	bne.n	405b24 <_vfiprintf_r+0x93c>
  405ba2:	980e      	ldr	r0, [sp, #56]	; 0x38
  405ba4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  405ba6:	9b07      	ldr	r3, [sp, #28]
  405ba8:	f100 0c01 	add.w	ip, r0, #1
  405bac:	46de      	mov	lr, fp
  405bae:	e4cb      	b.n	405548 <_vfiprintf_r+0x360>
  405bb0:	0040ade8 	.word	0x0040ade8
  405bb4:	0040adfc 	.word	0x0040adfc
  405bb8:	0040add8 	.word	0x0040add8
  405bbc:	2a00      	cmp	r2, #0
  405bbe:	f040 8133 	bne.w	405e28 <_vfiprintf_r+0xc40>
  405bc2:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
  405bc6:	2b00      	cmp	r3, #0
  405bc8:	f000 80f5 	beq.w	405db6 <_vfiprintf_r+0xbce>
  405bcc:	2301      	movs	r3, #1
  405bce:	f10d 012f 	add.w	r1, sp, #47	; 0x2f
  405bd2:	461a      	mov	r2, r3
  405bd4:	931b      	str	r3, [sp, #108]	; 0x6c
  405bd6:	469e      	mov	lr, r3
  405bd8:	911a      	str	r1, [sp, #104]	; 0x68
  405bda:	46da      	mov	sl, fp
  405bdc:	4670      	mov	r0, lr
  405bde:	f10a 0a08 	add.w	sl, sl, #8
  405be2:	f10e 0e01 	add.w	lr, lr, #1
  405be6:	e47d      	b.n	4054e4 <_vfiprintf_r+0x2fc>
  405be8:	a90c      	add	r1, sp, #48	; 0x30
  405bea:	2202      	movs	r2, #2
  405bec:	469e      	mov	lr, r3
  405bee:	911a      	str	r1, [sp, #104]	; 0x68
  405bf0:	921b      	str	r2, [sp, #108]	; 0x6c
  405bf2:	46da      	mov	sl, fp
  405bf4:	4670      	mov	r0, lr
  405bf6:	f10a 0a08 	add.w	sl, sl, #8
  405bfa:	f10e 0e01 	add.w	lr, lr, #1
  405bfe:	e738      	b.n	405a72 <_vfiprintf_r+0x88a>
  405c00:	9b01      	ldr	r3, [sp, #4]
  405c02:	f88d 902f 	strb.w	r9, [sp, #47]	; 0x2f
  405c06:	2b00      	cmp	r3, #0
  405c08:	f2c0 812a 	blt.w	405e60 <_vfiprintf_r+0xc78>
  405c0c:	ea54 0305 	orrs.w	r3, r4, r5
  405c10:	f026 0680 	bic.w	r6, r6, #128	; 0x80
  405c14:	f43f abff 	beq.w	405416 <_vfiprintf_r+0x22e>
  405c18:	465f      	mov	r7, fp
  405c1a:	0923      	lsrs	r3, r4, #4
  405c1c:	f004 010f 	and.w	r1, r4, #15
  405c20:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
  405c24:	092a      	lsrs	r2, r5, #4
  405c26:	461c      	mov	r4, r3
  405c28:	4615      	mov	r5, r2
  405c2a:	5c43      	ldrb	r3, [r0, r1]
  405c2c:	f807 3d01 	strb.w	r3, [r7, #-1]!
  405c30:	ea54 0305 	orrs.w	r3, r4, r5
  405c34:	d1f1      	bne.n	405c1a <_vfiprintf_r+0xa32>
  405c36:	ebc7 030b 	rsb	r3, r7, fp
  405c3a:	9303      	str	r3, [sp, #12]
  405c3c:	f7ff bbf4 	b.w	405428 <_vfiprintf_r+0x240>
  405c40:	aa0d      	add	r2, sp, #52	; 0x34
  405c42:	9900      	ldr	r1, [sp, #0]
  405c44:	9805      	ldr	r0, [sp, #20]
  405c46:	f7ff fa89 	bl	40515c <__sprint_r.part.0>
  405c4a:	2800      	cmp	r0, #0
  405c4c:	f47f af6a 	bne.w	405b24 <_vfiprintf_r+0x93c>
  405c50:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  405c52:	46da      	mov	sl, fp
  405c54:	e787      	b.n	405b66 <_vfiprintf_r+0x97e>
  405c56:	f04f 0900 	mov.w	r9, #0
  405c5a:	2400      	movs	r4, #0
  405c5c:	2500      	movs	r5, #0
  405c5e:	e7db      	b.n	405c18 <_vfiprintf_r+0xa30>
  405c60:	f016 0210 	ands.w	r2, r6, #16
  405c64:	f000 80b2 	beq.w	405dcc <_vfiprintf_r+0xbe4>
  405c68:	9904      	ldr	r1, [sp, #16]
  405c6a:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
  405c6e:	460a      	mov	r2, r1
  405c70:	680c      	ldr	r4, [r1, #0]
  405c72:	9901      	ldr	r1, [sp, #4]
  405c74:	2900      	cmp	r1, #0
  405c76:	f102 0204 	add.w	r2, r2, #4
  405c7a:	f04f 0500 	mov.w	r5, #0
  405c7e:	f2c0 8159 	blt.w	405f34 <_vfiprintf_r+0xd4c>
  405c82:	ea54 0105 	orrs.w	r1, r4, r5
  405c86:	f026 0680 	bic.w	r6, r6, #128	; 0x80
  405c8a:	9204      	str	r2, [sp, #16]
  405c8c:	f43f ad51 	beq.w	405732 <_vfiprintf_r+0x54a>
  405c90:	4699      	mov	r9, r3
  405c92:	e556      	b.n	405742 <_vfiprintf_r+0x55a>
  405c94:	06f7      	lsls	r7, r6, #27
  405c96:	d40a      	bmi.n	405cae <_vfiprintf_r+0xac6>
  405c98:	0675      	lsls	r5, r6, #25
  405c9a:	d508      	bpl.n	405cae <_vfiprintf_r+0xac6>
  405c9c:	9904      	ldr	r1, [sp, #16]
  405c9e:	f9b1 4000 	ldrsh.w	r4, [r1]
  405ca2:	3104      	adds	r1, #4
  405ca4:	17e5      	asrs	r5, r4, #31
  405ca6:	4622      	mov	r2, r4
  405ca8:	462b      	mov	r3, r5
  405caa:	9104      	str	r1, [sp, #16]
  405cac:	e4ea      	b.n	405684 <_vfiprintf_r+0x49c>
  405cae:	9a04      	ldr	r2, [sp, #16]
  405cb0:	6814      	ldr	r4, [r2, #0]
  405cb2:	4613      	mov	r3, r2
  405cb4:	3304      	adds	r3, #4
  405cb6:	17e5      	asrs	r5, r4, #31
  405cb8:	9304      	str	r3, [sp, #16]
  405cba:	4622      	mov	r2, r4
  405cbc:	462b      	mov	r3, r5
  405cbe:	e4e1      	b.n	405684 <_vfiprintf_r+0x49c>
  405cc0:	6814      	ldr	r4, [r2, #0]
  405cc2:	3204      	adds	r2, #4
  405cc4:	9204      	str	r2, [sp, #16]
  405cc6:	2500      	movs	r5, #0
  405cc8:	e61f      	b.n	40590a <_vfiprintf_r+0x722>
  405cca:	f04f 0900 	mov.w	r9, #0
  405cce:	ea54 0305 	orrs.w	r3, r4, r5
  405cd2:	f47f ace8 	bne.w	4056a6 <_vfiprintf_r+0x4be>
  405cd6:	e5d8      	b.n	40588a <_vfiprintf_r+0x6a2>
  405cd8:	aa0d      	add	r2, sp, #52	; 0x34
  405cda:	9900      	ldr	r1, [sp, #0]
  405cdc:	9805      	ldr	r0, [sp, #20]
  405cde:	f7ff fa3d 	bl	40515c <__sprint_r.part.0>
  405ce2:	2800      	cmp	r0, #0
  405ce4:	f47f af1e 	bne.w	405b24 <_vfiprintf_r+0x93c>
  405ce8:	46da      	mov	sl, fp
  405cea:	f7ff bb48 	b.w	40537e <_vfiprintf_r+0x196>
  405cee:	aa0d      	add	r2, sp, #52	; 0x34
  405cf0:	9900      	ldr	r1, [sp, #0]
  405cf2:	9805      	ldr	r0, [sp, #20]
  405cf4:	f7ff fa32 	bl	40515c <__sprint_r.part.0>
  405cf8:	2800      	cmp	r0, #0
  405cfa:	f43f af45 	beq.w	405b88 <_vfiprintf_r+0x9a0>
  405cfe:	e711      	b.n	405b24 <_vfiprintf_r+0x93c>
  405d00:	aa0d      	add	r2, sp, #52	; 0x34
  405d02:	9900      	ldr	r1, [sp, #0]
  405d04:	9805      	ldr	r0, [sp, #20]
  405d06:	f7ff fa29 	bl	40515c <__sprint_r.part.0>
  405d0a:	2800      	cmp	r0, #0
  405d0c:	f47f af0a 	bne.w	405b24 <_vfiprintf_r+0x93c>
  405d10:	980e      	ldr	r0, [sp, #56]	; 0x38
  405d12:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  405d14:	f100 0e01 	add.w	lr, r0, #1
  405d18:	46da      	mov	sl, fp
  405d1a:	f7ff bbe3 	b.w	4054e4 <_vfiprintf_r+0x2fc>
  405d1e:	aa0d      	add	r2, sp, #52	; 0x34
  405d20:	9900      	ldr	r1, [sp, #0]
  405d22:	9805      	ldr	r0, [sp, #20]
  405d24:	f7ff fa1a 	bl	40515c <__sprint_r.part.0>
  405d28:	2800      	cmp	r0, #0
  405d2a:	f47f aefb 	bne.w	405b24 <_vfiprintf_r+0x93c>
  405d2e:	980e      	ldr	r0, [sp, #56]	; 0x38
  405d30:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  405d32:	f100 0e01 	add.w	lr, r0, #1
  405d36:	46da      	mov	sl, fp
  405d38:	e69b      	b.n	405a72 <_vfiprintf_r+0x88a>
  405d3a:	2a00      	cmp	r2, #0
  405d3c:	f040 80d8 	bne.w	405ef0 <_vfiprintf_r+0xd08>
  405d40:	f04f 0e01 	mov.w	lr, #1
  405d44:	4610      	mov	r0, r2
  405d46:	46da      	mov	sl, fp
  405d48:	e697      	b.n	405a7a <_vfiprintf_r+0x892>
  405d4a:	aa0d      	add	r2, sp, #52	; 0x34
  405d4c:	9900      	ldr	r1, [sp, #0]
  405d4e:	9805      	ldr	r0, [sp, #20]
  405d50:	f7ff fa04 	bl	40515c <__sprint_r.part.0>
  405d54:	2800      	cmp	r0, #0
  405d56:	f47f aee5 	bne.w	405b24 <_vfiprintf_r+0x93c>
  405d5a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  405d5c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  405d5e:	f103 0e01 	add.w	lr, r3, #1
  405d62:	46da      	mov	sl, fp
  405d64:	e422      	b.n	4055ac <_vfiprintf_r+0x3c4>
  405d66:	2230      	movs	r2, #48	; 0x30
  405d68:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
  405d6c:	9a01      	ldr	r2, [sp, #4]
  405d6e:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
  405d72:	2a00      	cmp	r2, #0
  405d74:	f04f 0300 	mov.w	r3, #0
  405d78:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
  405d7c:	f046 0302 	orr.w	r3, r6, #2
  405d80:	f2c0 80cb 	blt.w	405f1a <_vfiprintf_r+0xd32>
  405d84:	f026 0680 	bic.w	r6, r6, #128	; 0x80
  405d88:	f046 0602 	orr.w	r6, r6, #2
  405d8c:	f04f 0900 	mov.w	r9, #0
  405d90:	e742      	b.n	405c18 <_vfiprintf_r+0xa30>
  405d92:	f04f 0900 	mov.w	r9, #0
  405d96:	4890      	ldr	r0, [pc, #576]	; (405fd8 <_vfiprintf_r+0xdf0>)
  405d98:	e73e      	b.n	405c18 <_vfiprintf_r+0xa30>
  405d9a:	9b01      	ldr	r3, [sp, #4]
  405d9c:	4264      	negs	r4, r4
  405d9e:	f04f 092d 	mov.w	r9, #45	; 0x2d
  405da2:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
  405da6:	2b00      	cmp	r3, #0
  405da8:	f88d 902f 	strb.w	r9, [sp, #47]	; 0x2f
  405dac:	f6ff ac7b 	blt.w	4056a6 <_vfiprintf_r+0x4be>
  405db0:	f026 0680 	bic.w	r6, r6, #128	; 0x80
  405db4:	e477      	b.n	4056a6 <_vfiprintf_r+0x4be>
  405db6:	9b07      	ldr	r3, [sp, #28]
  405db8:	2b00      	cmp	r3, #0
  405dba:	d072      	beq.n	405ea2 <_vfiprintf_r+0xcba>
  405dbc:	ab0c      	add	r3, sp, #48	; 0x30
  405dbe:	2202      	movs	r2, #2
  405dc0:	931a      	str	r3, [sp, #104]	; 0x68
  405dc2:	921b      	str	r2, [sp, #108]	; 0x6c
  405dc4:	f04f 0e01 	mov.w	lr, #1
  405dc8:	46da      	mov	sl, fp
  405dca:	e713      	b.n	405bf4 <_vfiprintf_r+0xa0c>
  405dcc:	f016 0940 	ands.w	r9, r6, #64	; 0x40
  405dd0:	d048      	beq.n	405e64 <_vfiprintf_r+0xc7c>
  405dd2:	9904      	ldr	r1, [sp, #16]
  405dd4:	f88d 202f 	strb.w	r2, [sp, #47]	; 0x2f
  405dd8:	460b      	mov	r3, r1
  405dda:	880c      	ldrh	r4, [r1, #0]
  405ddc:	9901      	ldr	r1, [sp, #4]
  405dde:	2900      	cmp	r1, #0
  405de0:	f103 0304 	add.w	r3, r3, #4
  405de4:	f04f 0500 	mov.w	r5, #0
  405de8:	f6ff ae10 	blt.w	405a0c <_vfiprintf_r+0x824>
  405dec:	ea54 0105 	orrs.w	r1, r4, r5
  405df0:	f026 0680 	bic.w	r6, r6, #128	; 0x80
  405df4:	9304      	str	r3, [sp, #16]
  405df6:	f43f ac9c 	beq.w	405732 <_vfiprintf_r+0x54a>
  405dfa:	4691      	mov	r9, r2
  405dfc:	e4a1      	b.n	405742 <_vfiprintf_r+0x55a>
  405dfe:	06f0      	lsls	r0, r6, #27
  405e00:	d40a      	bmi.n	405e18 <_vfiprintf_r+0xc30>
  405e02:	0671      	lsls	r1, r6, #25
  405e04:	d508      	bpl.n	405e18 <_vfiprintf_r+0xc30>
  405e06:	9a04      	ldr	r2, [sp, #16]
  405e08:	6813      	ldr	r3, [r2, #0]
  405e0a:	3204      	adds	r2, #4
  405e0c:	9204      	str	r2, [sp, #16]
  405e0e:	f8bd 2008 	ldrh.w	r2, [sp, #8]
  405e12:	801a      	strh	r2, [r3, #0]
  405e14:	f7ff ba19 	b.w	40524a <_vfiprintf_r+0x62>
  405e18:	9a04      	ldr	r2, [sp, #16]
  405e1a:	6813      	ldr	r3, [r2, #0]
  405e1c:	3204      	adds	r2, #4
  405e1e:	9204      	str	r2, [sp, #16]
  405e20:	9a02      	ldr	r2, [sp, #8]
  405e22:	601a      	str	r2, [r3, #0]
  405e24:	f7ff ba11 	b.w	40524a <_vfiprintf_r+0x62>
  405e28:	aa0d      	add	r2, sp, #52	; 0x34
  405e2a:	9900      	ldr	r1, [sp, #0]
  405e2c:	9805      	ldr	r0, [sp, #20]
  405e2e:	f7ff f995 	bl	40515c <__sprint_r.part.0>
  405e32:	2800      	cmp	r0, #0
  405e34:	f47f ae76 	bne.w	405b24 <_vfiprintf_r+0x93c>
  405e38:	980e      	ldr	r0, [sp, #56]	; 0x38
  405e3a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  405e3c:	f100 0e01 	add.w	lr, r0, #1
  405e40:	46da      	mov	sl, fp
  405e42:	e5fa      	b.n	405a3a <_vfiprintf_r+0x852>
  405e44:	f04f 30ff 	mov.w	r0, #4294967295
  405e48:	f7ff bab6 	b.w	4053b8 <_vfiprintf_r+0x1d0>
  405e4c:	4862      	ldr	r0, [pc, #392]	; (405fd8 <_vfiprintf_r+0xdf0>)
  405e4e:	4616      	mov	r6, r2
  405e50:	ea54 0205 	orrs.w	r2, r4, r5
  405e54:	9304      	str	r3, [sp, #16]
  405e56:	f04f 0900 	mov.w	r9, #0
  405e5a:	f47f aedd 	bne.w	405c18 <_vfiprintf_r+0xa30>
  405e5e:	e6fc      	b.n	405c5a <_vfiprintf_r+0xa72>
  405e60:	9b04      	ldr	r3, [sp, #16]
  405e62:	e7f5      	b.n	405e50 <_vfiprintf_r+0xc68>
  405e64:	9a04      	ldr	r2, [sp, #16]
  405e66:	f88d 902f 	strb.w	r9, [sp, #47]	; 0x2f
  405e6a:	4613      	mov	r3, r2
  405e6c:	6814      	ldr	r4, [r2, #0]
  405e6e:	9a01      	ldr	r2, [sp, #4]
  405e70:	2a00      	cmp	r2, #0
  405e72:	f103 0304 	add.w	r3, r3, #4
  405e76:	f04f 0500 	mov.w	r5, #0
  405e7a:	f6ff adc7 	blt.w	405a0c <_vfiprintf_r+0x824>
  405e7e:	ea54 0205 	orrs.w	r2, r4, r5
  405e82:	f026 0680 	bic.w	r6, r6, #128	; 0x80
  405e86:	9304      	str	r3, [sp, #16]
  405e88:	f47f ac5b 	bne.w	405742 <_vfiprintf_r+0x55a>
  405e8c:	e451      	b.n	405732 <_vfiprintf_r+0x54a>
  405e8e:	aa0d      	add	r2, sp, #52	; 0x34
  405e90:	9900      	ldr	r1, [sp, #0]
  405e92:	9805      	ldr	r0, [sp, #20]
  405e94:	f7ff f962 	bl	40515c <__sprint_r.part.0>
  405e98:	2800      	cmp	r0, #0
  405e9a:	f47f ae43 	bne.w	405b24 <_vfiprintf_r+0x93c>
  405e9e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  405ea0:	e668      	b.n	405b74 <_vfiprintf_r+0x98c>
  405ea2:	4610      	mov	r0, r2
  405ea4:	f04f 0e01 	mov.w	lr, #1
  405ea8:	46da      	mov	sl, fp
  405eaa:	e5e6      	b.n	405a7a <_vfiprintf_r+0x892>
  405eac:	9904      	ldr	r1, [sp, #16]
  405eae:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
  405eb2:	460a      	mov	r2, r1
  405eb4:	880c      	ldrh	r4, [r1, #0]
  405eb6:	9901      	ldr	r1, [sp, #4]
  405eb8:	2900      	cmp	r1, #0
  405eba:	f102 0204 	add.w	r2, r2, #4
  405ebe:	f04f 0500 	mov.w	r5, #0
  405ec2:	db4e      	blt.n	405f62 <_vfiprintf_r+0xd7a>
  405ec4:	ea54 0105 	orrs.w	r1, r4, r5
  405ec8:	f026 0680 	bic.w	r6, r6, #128	; 0x80
  405ecc:	9204      	str	r2, [sp, #16]
  405ece:	4699      	mov	r9, r3
  405ed0:	f47f abe9 	bne.w	4056a6 <_vfiprintf_r+0x4be>
  405ed4:	e4d4      	b.n	405880 <_vfiprintf_r+0x698>
  405ed6:	9304      	str	r3, [sp, #16]
  405ed8:	e6f9      	b.n	405cce <_vfiprintf_r+0xae6>
  405eda:	4638      	mov	r0, r7
  405edc:	9404      	str	r4, [sp, #16]
  405ede:	f7ff f8cf 	bl	405080 <strlen>
  405ee2:	2300      	movs	r3, #0
  405ee4:	9003      	str	r0, [sp, #12]
  405ee6:	f89d 902f 	ldrb.w	r9, [sp, #47]	; 0x2f
  405eea:	9301      	str	r3, [sp, #4]
  405eec:	f7ff ba9c 	b.w	405428 <_vfiprintf_r+0x240>
  405ef0:	aa0d      	add	r2, sp, #52	; 0x34
  405ef2:	9900      	ldr	r1, [sp, #0]
  405ef4:	9805      	ldr	r0, [sp, #20]
  405ef6:	f7ff f931 	bl	40515c <__sprint_r.part.0>
  405efa:	2800      	cmp	r0, #0
  405efc:	f47f ae12 	bne.w	405b24 <_vfiprintf_r+0x93c>
  405f00:	980e      	ldr	r0, [sp, #56]	; 0x38
  405f02:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  405f04:	f100 0e01 	add.w	lr, r0, #1
  405f08:	46da      	mov	sl, fp
  405f0a:	e5b6      	b.n	405a7a <_vfiprintf_r+0x892>
  405f0c:	980e      	ldr	r0, [sp, #56]	; 0x38
  405f0e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  405f10:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 405fe0 <_vfiprintf_r+0xdf8>
  405f14:	3001      	adds	r0, #1
  405f16:	f7ff bad2 	b.w	4054be <_vfiprintf_r+0x2d6>
  405f1a:	461e      	mov	r6, r3
  405f1c:	f04f 0900 	mov.w	r9, #0
  405f20:	e67a      	b.n	405c18 <_vfiprintf_r+0xa30>
  405f22:	2b06      	cmp	r3, #6
  405f24:	bf28      	it	cs
  405f26:	2306      	movcs	r3, #6
  405f28:	9303      	str	r3, [sp, #12]
  405f2a:	9404      	str	r4, [sp, #16]
  405f2c:	ea23 75e3 	bic.w	r5, r3, r3, asr #31
  405f30:	4f2a      	ldr	r7, [pc, #168]	; (405fdc <_vfiprintf_r+0xdf4>)
  405f32:	e50c      	b.n	40594e <_vfiprintf_r+0x766>
  405f34:	9204      	str	r2, [sp, #16]
  405f36:	e56a      	b.n	405a0e <_vfiprintf_r+0x826>
  405f38:	980e      	ldr	r0, [sp, #56]	; 0x38
  405f3a:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 405fe0 <_vfiprintf_r+0xdf8>
  405f3e:	3001      	adds	r0, #1
  405f40:	f7ff bb73 	b.w	40562a <_vfiprintf_r+0x442>
  405f44:	46f4      	mov	ip, lr
  405f46:	f7ff bb1a 	b.w	40557e <_vfiprintf_r+0x396>
  405f4a:	9b01      	ldr	r3, [sp, #4]
  405f4c:	f89d 902f 	ldrb.w	r9, [sp, #47]	; 0x2f
  405f50:	9303      	str	r3, [sp, #12]
  405f52:	9404      	str	r4, [sp, #16]
  405f54:	9001      	str	r0, [sp, #4]
  405f56:	f7ff ba67 	b.w	405428 <_vfiprintf_r+0x240>
  405f5a:	2200      	movs	r2, #0
  405f5c:	9201      	str	r2, [sp, #4]
  405f5e:	f7ff b9ac 	b.w	4052ba <_vfiprintf_r+0xd2>
  405f62:	9204      	str	r2, [sp, #16]
  405f64:	4699      	mov	r9, r3
  405f66:	e6b2      	b.n	405cce <_vfiprintf_r+0xae6>
  405f68:	9a04      	ldr	r2, [sp, #16]
  405f6a:	6813      	ldr	r3, [r2, #0]
  405f6c:	9301      	str	r3, [sp, #4]
  405f6e:	3204      	adds	r2, #4
  405f70:	2b00      	cmp	r3, #0
  405f72:	9204      	str	r2, [sp, #16]
  405f74:	f898 3001 	ldrb.w	r3, [r8, #1]
  405f78:	46a8      	mov	r8, r5
  405f7a:	f6bf a99c 	bge.w	4052b6 <_vfiprintf_r+0xce>
  405f7e:	f04f 32ff 	mov.w	r2, #4294967295
  405f82:	9201      	str	r2, [sp, #4]
  405f84:	f7ff b997 	b.w	4052b6 <_vfiprintf_r+0xce>
  405f88:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
  405f8c:	e48e      	b.n	4058ac <_vfiprintf_r+0x6c4>
  405f8e:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
  405f92:	e4f0      	b.n	405976 <_vfiprintf_r+0x78e>
  405f94:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
  405f98:	e4ab      	b.n	4058f2 <_vfiprintf_r+0x70a>
  405f9a:	4699      	mov	r9, r3
  405f9c:	07f3      	lsls	r3, r6, #31
  405f9e:	d505      	bpl.n	405fac <_vfiprintf_r+0xdc4>
  405fa0:	af2a      	add	r7, sp, #168	; 0xa8
  405fa2:	2330      	movs	r3, #48	; 0x30
  405fa4:	f807 3d41 	strb.w	r3, [r7, #-65]!
  405fa8:	f7ff bb97 	b.w	4056da <_vfiprintf_r+0x4f2>
  405fac:	9b01      	ldr	r3, [sp, #4]
  405fae:	9303      	str	r3, [sp, #12]
  405fb0:	465f      	mov	r7, fp
  405fb2:	f7ff ba39 	b.w	405428 <_vfiprintf_r+0x240>
  405fb6:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
  405fba:	e443      	b.n	405844 <_vfiprintf_r+0x65c>
  405fbc:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
  405fc0:	f7ff bb9a 	b.w	4056f8 <_vfiprintf_r+0x510>
  405fc4:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
  405fc8:	f7ff bb4d 	b.w	405666 <_vfiprintf_r+0x47e>
  405fcc:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
  405fd0:	e50f      	b.n	4059f2 <_vfiprintf_r+0x80a>
  405fd2:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
  405fd6:	e4f3      	b.n	4059c0 <_vfiprintf_r+0x7d8>
  405fd8:	0040adfc 	.word	0x0040adfc
  405fdc:	0040ae10 	.word	0x0040ae10
  405fe0:	0040ae18 	.word	0x0040ae18

00405fe4 <__sbprintf>:
  405fe4:	b5f0      	push	{r4, r5, r6, r7, lr}
  405fe6:	460c      	mov	r4, r1
  405fe8:	f2ad 4d6c 	subw	sp, sp, #1132	; 0x46c
  405fec:	8989      	ldrh	r1, [r1, #12]
  405fee:	6e66      	ldr	r6, [r4, #100]	; 0x64
  405ff0:	89e5      	ldrh	r5, [r4, #14]
  405ff2:	9619      	str	r6, [sp, #100]	; 0x64
  405ff4:	f021 0102 	bic.w	r1, r1, #2
  405ff8:	6a66      	ldr	r6, [r4, #36]	; 0x24
  405ffa:	f8ad 500e 	strh.w	r5, [sp, #14]
  405ffe:	2500      	movs	r5, #0
  406000:	69e7      	ldr	r7, [r4, #28]
  406002:	f8ad 100c 	strh.w	r1, [sp, #12]
  406006:	9609      	str	r6, [sp, #36]	; 0x24
  406008:	9506      	str	r5, [sp, #24]
  40600a:	ae1a      	add	r6, sp, #104	; 0x68
  40600c:	f44f 6580 	mov.w	r5, #1024	; 0x400
  406010:	4669      	mov	r1, sp
  406012:	9600      	str	r6, [sp, #0]
  406014:	9604      	str	r6, [sp, #16]
  406016:	9502      	str	r5, [sp, #8]
  406018:	9505      	str	r5, [sp, #20]
  40601a:	9707      	str	r7, [sp, #28]
  40601c:	4606      	mov	r6, r0
  40601e:	f7ff f8e3 	bl	4051e8 <_vfiprintf_r>
  406022:	1e05      	subs	r5, r0, #0
  406024:	db07      	blt.n	406036 <__sbprintf+0x52>
  406026:	4630      	mov	r0, r6
  406028:	4669      	mov	r1, sp
  40602a:	f002 fc9d 	bl	408968 <_fflush_r>
  40602e:	2800      	cmp	r0, #0
  406030:	bf18      	it	ne
  406032:	f04f 35ff 	movne.w	r5, #4294967295
  406036:	f8bd 300c 	ldrh.w	r3, [sp, #12]
  40603a:	065b      	lsls	r3, r3, #25
  40603c:	d503      	bpl.n	406046 <__sbprintf+0x62>
  40603e:	89a3      	ldrh	r3, [r4, #12]
  406040:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  406044:	81a3      	strh	r3, [r4, #12]
  406046:	4628      	mov	r0, r5
  406048:	f20d 4d6c 	addw	sp, sp, #1132	; 0x46c
  40604c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  40604e:	bf00      	nop

00406050 <_vfprintf_r>:
  406050:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  406054:	b0c1      	sub	sp, #260	; 0x104
  406056:	461c      	mov	r4, r3
  406058:	9108      	str	r1, [sp, #32]
  40605a:	4616      	mov	r6, r2
  40605c:	4605      	mov	r5, r0
  40605e:	900a      	str	r0, [sp, #40]	; 0x28
  406060:	f003 f87e 	bl	409160 <_localeconv_r>
  406064:	6803      	ldr	r3, [r0, #0]
  406066:	9317      	str	r3, [sp, #92]	; 0x5c
  406068:	4618      	mov	r0, r3
  40606a:	f7ff f809 	bl	405080 <strlen>
  40606e:	940e      	str	r4, [sp, #56]	; 0x38
  406070:	9016      	str	r0, [sp, #88]	; 0x58
  406072:	b11d      	cbz	r5, 40607c <_vfprintf_r+0x2c>
  406074:	6bab      	ldr	r3, [r5, #56]	; 0x38
  406076:	2b00      	cmp	r3, #0
  406078:	f000 8122 	beq.w	4062c0 <_vfprintf_r+0x270>
  40607c:	9808      	ldr	r0, [sp, #32]
  40607e:	f9b0 200c 	ldrsh.w	r2, [r0, #12]
  406082:	b293      	uxth	r3, r2
  406084:	0499      	lsls	r1, r3, #18
  406086:	d407      	bmi.n	406098 <_vfprintf_r+0x48>
  406088:	6e41      	ldr	r1, [r0, #100]	; 0x64
  40608a:	f442 5300 	orr.w	r3, r2, #8192	; 0x2000
  40608e:	f421 5100 	bic.w	r1, r1, #8192	; 0x2000
  406092:	8183      	strh	r3, [r0, #12]
  406094:	6641      	str	r1, [r0, #100]	; 0x64
  406096:	b29b      	uxth	r3, r3
  406098:	071a      	lsls	r2, r3, #28
  40609a:	f140 80dc 	bpl.w	406256 <_vfprintf_r+0x206>
  40609e:	9a08      	ldr	r2, [sp, #32]
  4060a0:	6912      	ldr	r2, [r2, #16]
  4060a2:	2a00      	cmp	r2, #0
  4060a4:	f000 80d7 	beq.w	406256 <_vfprintf_r+0x206>
  4060a8:	f003 031a 	and.w	r3, r3, #26
  4060ac:	2b0a      	cmp	r3, #10
  4060ae:	f000 80e0 	beq.w	406272 <_vfprintf_r+0x222>
  4060b2:	2300      	movs	r3, #0
  4060b4:	461a      	mov	r2, r3
  4060b6:	9312      	str	r3, [sp, #72]	; 0x48
  4060b8:	9325      	str	r3, [sp, #148]	; 0x94
  4060ba:	9324      	str	r3, [sp, #144]	; 0x90
  4060bc:	9319      	str	r3, [sp, #100]	; 0x64
  4060be:	930b      	str	r3, [sp, #44]	; 0x2c
  4060c0:	f8df a3fc 	ldr.w	sl, [pc, #1020]	; 4064c0 <_vfprintf_r+0x470>
  4060c4:	9214      	str	r2, [sp, #80]	; 0x50
  4060c6:	ab30      	add	r3, sp, #192	; 0xc0
  4060c8:	9323      	str	r3, [sp, #140]	; 0x8c
  4060ca:	4699      	mov	r9, r3
  4060cc:	9215      	str	r2, [sp, #84]	; 0x54
  4060ce:	46b0      	mov	r8, r6
  4060d0:	f898 3000 	ldrb.w	r3, [r8]
  4060d4:	4644      	mov	r4, r8
  4060d6:	b1eb      	cbz	r3, 406114 <_vfprintf_r+0xc4>
  4060d8:	2b25      	cmp	r3, #37	; 0x25
  4060da:	d102      	bne.n	4060e2 <_vfprintf_r+0x92>
  4060dc:	e01a      	b.n	406114 <_vfprintf_r+0xc4>
  4060de:	2b25      	cmp	r3, #37	; 0x25
  4060e0:	d003      	beq.n	4060ea <_vfprintf_r+0x9a>
  4060e2:	f814 3f01 	ldrb.w	r3, [r4, #1]!
  4060e6:	2b00      	cmp	r3, #0
  4060e8:	d1f9      	bne.n	4060de <_vfprintf_r+0x8e>
  4060ea:	ebc8 0504 	rsb	r5, r8, r4
  4060ee:	b18d      	cbz	r5, 406114 <_vfprintf_r+0xc4>
  4060f0:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4060f2:	9a25      	ldr	r2, [sp, #148]	; 0x94
  4060f4:	f8c9 8000 	str.w	r8, [r9]
  4060f8:	3301      	adds	r3, #1
  4060fa:	442a      	add	r2, r5
  4060fc:	2b07      	cmp	r3, #7
  4060fe:	f8c9 5004 	str.w	r5, [r9, #4]
  406102:	9225      	str	r2, [sp, #148]	; 0x94
  406104:	9324      	str	r3, [sp, #144]	; 0x90
  406106:	f300 80c2 	bgt.w	40628e <_vfprintf_r+0x23e>
  40610a:	f109 0908 	add.w	r9, r9, #8
  40610e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  406110:	442b      	add	r3, r5
  406112:	930b      	str	r3, [sp, #44]	; 0x2c
  406114:	7823      	ldrb	r3, [r4, #0]
  406116:	2b00      	cmp	r3, #0
  406118:	f000 80c2 	beq.w	4062a0 <_vfprintf_r+0x250>
  40611c:	2300      	movs	r3, #0
  40611e:	461a      	mov	r2, r3
  406120:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
  406124:	4619      	mov	r1, r3
  406126:	930c      	str	r3, [sp, #48]	; 0x30
  406128:	9307      	str	r3, [sp, #28]
  40612a:	f04f 3bff 	mov.w	fp, #4294967295
  40612e:	7863      	ldrb	r3, [r4, #1]
  406130:	f104 0801 	add.w	r8, r4, #1
  406134:	465d      	mov	r5, fp
  406136:	f108 0801 	add.w	r8, r8, #1
  40613a:	f1a3 0020 	sub.w	r0, r3, #32
  40613e:	2858      	cmp	r0, #88	; 0x58
  406140:	f200 844b 	bhi.w	4069da <_vfprintf_r+0x98a>
  406144:	e8df f010 	tbh	[pc, r0, lsl #1]
  406148:	04490401 	.word	0x04490401
  40614c:	040a0449 	.word	0x040a0449
  406150:	04490449 	.word	0x04490449
  406154:	04490449 	.word	0x04490449
  406158:	04490449 	.word	0x04490449
  40615c:	043b035d 	.word	0x043b035d
  406160:	005d0449 	.word	0x005d0449
  406164:	044900fe 	.word	0x044900fe
  406168:	036b011a 	.word	0x036b011a
  40616c:	036b036b 	.word	0x036b036b
  406170:	036b036b 	.word	0x036b036b
  406174:	036b036b 	.word	0x036b036b
  406178:	036b036b 	.word	0x036b036b
  40617c:	04490449 	.word	0x04490449
  406180:	04490449 	.word	0x04490449
  406184:	04490449 	.word	0x04490449
  406188:	04490449 	.word	0x04490449
  40618c:	04490449 	.word	0x04490449
  406190:	0398037b 	.word	0x0398037b
  406194:	03980449 	.word	0x03980449
  406198:	04490449 	.word	0x04490449
  40619c:	04490449 	.word	0x04490449
  4061a0:	044903dd 	.word	0x044903dd
  4061a4:	01210449 	.word	0x01210449
  4061a8:	04490449 	.word	0x04490449
  4061ac:	04490449 	.word	0x04490449
  4061b0:	014a0449 	.word	0x014a0449
  4061b4:	04490449 	.word	0x04490449
  4061b8:	044902b0 	.word	0x044902b0
  4061bc:	04490449 	.word	0x04490449
  4061c0:	04490449 	.word	0x04490449
  4061c4:	04490449 	.word	0x04490449
  4061c8:	04490449 	.word	0x04490449
  4061cc:	02f10449 	.word	0x02f10449
  4061d0:	03980304 	.word	0x03980304
  4061d4:	03980398 	.word	0x03980398
  4061d8:	0304033a 	.word	0x0304033a
  4061dc:	04490449 	.word	0x04490449
  4061e0:	04490341 	.word	0x04490341
  4061e4:	00c0034b 	.word	0x00c0034b
  4061e8:	04120064 	.word	0x04120064
  4061ec:	041a0449 	.word	0x041a0449
  4061f0:	03e40449 	.word	0x03e40449
  4061f4:	04490449 	.word	0x04490449
  4061f8:	03ec      	.short	0x03ec
  4061fa:	980c      	ldr	r0, [sp, #48]	; 0x30
  4061fc:	930e      	str	r3, [sp, #56]	; 0x38
  4061fe:	4240      	negs	r0, r0
  406200:	900c      	str	r0, [sp, #48]	; 0x30
  406202:	9b07      	ldr	r3, [sp, #28]
  406204:	f043 0304 	orr.w	r3, r3, #4
  406208:	9307      	str	r3, [sp, #28]
  40620a:	f898 3000 	ldrb.w	r3, [r8]
  40620e:	e792      	b.n	406136 <_vfprintf_r+0xe6>
  406210:	980e      	ldr	r0, [sp, #56]	; 0x38
  406212:	46ab      	mov	fp, r5
  406214:	2100      	movs	r1, #0
  406216:	6804      	ldr	r4, [r0, #0]
  406218:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  40621c:	1d07      	adds	r7, r0, #4
  40621e:	9807      	ldr	r0, [sp, #28]
  406220:	2330      	movs	r3, #48	; 0x30
  406222:	2278      	movs	r2, #120	; 0x78
  406224:	458b      	cmp	fp, r1
  406226:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
  40622a:	f04f 0500 	mov.w	r5, #0
  40622e:	f88d 2071 	strb.w	r2, [sp, #113]	; 0x71
  406232:	f040 0302 	orr.w	r3, r0, #2
  406236:	f2c0 83ed 	blt.w	406a14 <_vfprintf_r+0x9c4>
  40623a:	f020 0380 	bic.w	r3, r0, #128	; 0x80
  40623e:	f043 0302 	orr.w	r3, r3, #2
  406242:	9307      	str	r3, [sp, #28]
  406244:	ea54 0305 	orrs.w	r3, r4, r5
  406248:	970e      	str	r7, [sp, #56]	; 0x38
  40624a:	f000 83be 	beq.w	4069ca <_vfprintf_r+0x97a>
  40624e:	460f      	mov	r7, r1
  406250:	9211      	str	r2, [sp, #68]	; 0x44
  406252:	4899      	ldr	r0, [pc, #612]	; (4064b8 <_vfprintf_r+0x468>)
  406254:	e259      	b.n	40670a <_vfprintf_r+0x6ba>
  406256:	9908      	ldr	r1, [sp, #32]
  406258:	980a      	ldr	r0, [sp, #40]	; 0x28
  40625a:	f001 faa5 	bl	4077a8 <__swsetup_r>
  40625e:	2800      	cmp	r0, #0
  406260:	f041 8017 	bne.w	407292 <_vfprintf_r+0x1242>
  406264:	9b08      	ldr	r3, [sp, #32]
  406266:	899b      	ldrh	r3, [r3, #12]
  406268:	f003 031a 	and.w	r3, r3, #26
  40626c:	2b0a      	cmp	r3, #10
  40626e:	f47f af20 	bne.w	4060b2 <_vfprintf_r+0x62>
  406272:	9908      	ldr	r1, [sp, #32]
  406274:	f9b1 300e 	ldrsh.w	r3, [r1, #14]
  406278:	2b00      	cmp	r3, #0
  40627a:	f6ff af1a 	blt.w	4060b2 <_vfprintf_r+0x62>
  40627e:	4623      	mov	r3, r4
  406280:	4632      	mov	r2, r6
  406282:	980a      	ldr	r0, [sp, #40]	; 0x28
  406284:	f001 fa5a 	bl	40773c <__sbprintf>
  406288:	b041      	add	sp, #260	; 0x104
  40628a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40628e:	aa23      	add	r2, sp, #140	; 0x8c
  406290:	9908      	ldr	r1, [sp, #32]
  406292:	980a      	ldr	r0, [sp, #40]	; 0x28
  406294:	f7fe ff9e 	bl	4051d4 <__sprint_r>
  406298:	b948      	cbnz	r0, 4062ae <_vfprintf_r+0x25e>
  40629a:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  40629e:	e736      	b.n	40610e <_vfprintf_r+0xbe>
  4062a0:	9b25      	ldr	r3, [sp, #148]	; 0x94
  4062a2:	b123      	cbz	r3, 4062ae <_vfprintf_r+0x25e>
  4062a4:	980a      	ldr	r0, [sp, #40]	; 0x28
  4062a6:	9908      	ldr	r1, [sp, #32]
  4062a8:	aa23      	add	r2, sp, #140	; 0x8c
  4062aa:	f7fe ff93 	bl	4051d4 <__sprint_r>
  4062ae:	9b08      	ldr	r3, [sp, #32]
  4062b0:	899b      	ldrh	r3, [r3, #12]
  4062b2:	0659      	lsls	r1, r3, #25
  4062b4:	f100 87ed 	bmi.w	407292 <_vfprintf_r+0x1242>
  4062b8:	980b      	ldr	r0, [sp, #44]	; 0x2c
  4062ba:	b041      	add	sp, #260	; 0x104
  4062bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4062c0:	980a      	ldr	r0, [sp, #40]	; 0x28
  4062c2:	f002 fbe5 	bl	408a90 <__sinit>
  4062c6:	e6d9      	b.n	40607c <_vfprintf_r+0x2c>
  4062c8:	9311      	str	r3, [sp, #68]	; 0x44
  4062ca:	46ab      	mov	fp, r5
  4062cc:	2a00      	cmp	r2, #0
  4062ce:	f041 8214 	bne.w	4076fa <_vfprintf_r+0x16aa>
  4062d2:	9a07      	ldr	r2, [sp, #28]
  4062d4:	f012 0320 	ands.w	r3, r2, #32
  4062d8:	d064      	beq.n	4063a4 <_vfprintf_r+0x354>
  4062da:	9f0e      	ldr	r7, [sp, #56]	; 0x38
  4062dc:	3707      	adds	r7, #7
  4062de:	f027 0307 	bic.w	r3, r7, #7
  4062e2:	2700      	movs	r7, #0
  4062e4:	f103 0108 	add.w	r1, r3, #8
  4062e8:	45bb      	cmp	fp, r7
  4062ea:	910e      	str	r1, [sp, #56]	; 0x38
  4062ec:	e9d3 4500 	ldrd	r4, r5, [r3]
  4062f0:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
  4062f4:	f2c0 873c 	blt.w	407170 <_vfprintf_r+0x1120>
  4062f8:	f022 0380 	bic.w	r3, r2, #128	; 0x80
  4062fc:	9307      	str	r3, [sp, #28]
  4062fe:	ea54 0305 	orrs.w	r3, r4, r5
  406302:	f000 837f 	beq.w	406a04 <_vfprintf_r+0x9b4>
  406306:	ae30      	add	r6, sp, #192	; 0xc0
  406308:	08e2      	lsrs	r2, r4, #3
  40630a:	ea42 7245 	orr.w	r2, r2, r5, lsl #29
  40630e:	08e9      	lsrs	r1, r5, #3
  406310:	f004 0307 	and.w	r3, r4, #7
  406314:	460d      	mov	r5, r1
  406316:	4614      	mov	r4, r2
  406318:	3330      	adds	r3, #48	; 0x30
  40631a:	ea54 0205 	orrs.w	r2, r4, r5
  40631e:	f806 3d01 	strb.w	r3, [r6, #-1]!
  406322:	d1f1      	bne.n	406308 <_vfprintf_r+0x2b8>
  406324:	9a07      	ldr	r2, [sp, #28]
  406326:	07d2      	lsls	r2, r2, #31
  406328:	f140 8096 	bpl.w	406458 <_vfprintf_r+0x408>
  40632c:	2b30      	cmp	r3, #48	; 0x30
  40632e:	f000 8093 	beq.w	406458 <_vfprintf_r+0x408>
  406332:	2230      	movs	r2, #48	; 0x30
  406334:	1e73      	subs	r3, r6, #1
  406336:	f806 2c01 	strb.w	r2, [r6, #-1]
  40633a:	aa30      	add	r2, sp, #192	; 0xc0
  40633c:	1ad2      	subs	r2, r2, r3
  40633e:	920d      	str	r2, [sp, #52]	; 0x34
  406340:	461e      	mov	r6, r3
  406342:	e08c      	b.n	40645e <_vfprintf_r+0x40e>
  406344:	f898 3000 	ldrb.w	r3, [r8]
  406348:	2b2a      	cmp	r3, #42	; 0x2a
  40634a:	f108 0401 	add.w	r4, r8, #1
  40634e:	f001 81b6 	beq.w	4076be <_vfprintf_r+0x166e>
  406352:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
  406356:	2809      	cmp	r0, #9
  406358:	bf98      	it	ls
  40635a:	2500      	movls	r5, #0
  40635c:	f201 8147 	bhi.w	4075ee <_vfprintf_r+0x159e>
  406360:	f814 3b01 	ldrb.w	r3, [r4], #1
  406364:	eb05 0585 	add.w	r5, r5, r5, lsl #2
  406368:	eb00 0545 	add.w	r5, r0, r5, lsl #1
  40636c:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
  406370:	2809      	cmp	r0, #9
  406372:	d9f5      	bls.n	406360 <_vfprintf_r+0x310>
  406374:	ea45 75e5 	orr.w	r5, r5, r5, asr #31
  406378:	46a0      	mov	r8, r4
  40637a:	e6de      	b.n	40613a <_vfprintf_r+0xea>
  40637c:	9b07      	ldr	r3, [sp, #28]
  40637e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  406382:	9307      	str	r3, [sp, #28]
  406384:	f898 3000 	ldrb.w	r3, [r8]
  406388:	e6d5      	b.n	406136 <_vfprintf_r+0xe6>
  40638a:	9311      	str	r3, [sp, #68]	; 0x44
  40638c:	46ab      	mov	fp, r5
  40638e:	2a00      	cmp	r2, #0
  406390:	f041 81be 	bne.w	407710 <_vfprintf_r+0x16c0>
  406394:	9b07      	ldr	r3, [sp, #28]
  406396:	f043 0310 	orr.w	r3, r3, #16
  40639a:	9307      	str	r3, [sp, #28]
  40639c:	9a07      	ldr	r2, [sp, #28]
  40639e:	f012 0320 	ands.w	r3, r2, #32
  4063a2:	d19a      	bne.n	4062da <_vfprintf_r+0x28a>
  4063a4:	9907      	ldr	r1, [sp, #28]
  4063a6:	f011 0210 	ands.w	r2, r1, #16
  4063aa:	f000 86d0 	beq.w	40714e <_vfprintf_r+0x10fe>
  4063ae:	980e      	ldr	r0, [sp, #56]	; 0x38
  4063b0:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
  4063b4:	f1bb 0f00 	cmp.w	fp, #0
  4063b8:	6804      	ldr	r4, [r0, #0]
  4063ba:	f100 0704 	add.w	r7, r0, #4
  4063be:	f04f 0500 	mov.w	r5, #0
  4063c2:	f2c0 86d4 	blt.w	40716e <_vfprintf_r+0x111e>
  4063c6:	460a      	mov	r2, r1
  4063c8:	f022 0280 	bic.w	r2, r2, #128	; 0x80
  4063cc:	9207      	str	r2, [sp, #28]
  4063ce:	ea54 0205 	orrs.w	r2, r4, r5
  4063d2:	970e      	str	r7, [sp, #56]	; 0x38
  4063d4:	f000 8316 	beq.w	406a04 <_vfprintf_r+0x9b4>
  4063d8:	461f      	mov	r7, r3
  4063da:	e794      	b.n	406306 <_vfprintf_r+0x2b6>
  4063dc:	9311      	str	r3, [sp, #68]	; 0x44
  4063de:	46ab      	mov	fp, r5
  4063e0:	2a00      	cmp	r2, #0
  4063e2:	f041 817e 	bne.w	4076e2 <_vfprintf_r+0x1692>
  4063e6:	9b07      	ldr	r3, [sp, #28]
  4063e8:	f043 0310 	orr.w	r3, r3, #16
  4063ec:	9307      	str	r3, [sp, #28]
  4063ee:	9a07      	ldr	r2, [sp, #28]
  4063f0:	f012 0320 	ands.w	r3, r2, #32
  4063f4:	f000 84f8 	beq.w	406de8 <_vfprintf_r+0xd98>
  4063f8:	9f0e      	ldr	r7, [sp, #56]	; 0x38
  4063fa:	3707      	adds	r7, #7
  4063fc:	f027 0307 	bic.w	r3, r7, #7
  406400:	2700      	movs	r7, #0
  406402:	f103 0108 	add.w	r1, r3, #8
  406406:	45bb      	cmp	fp, r7
  406408:	910e      	str	r1, [sp, #56]	; 0x38
  40640a:	e9d3 4500 	ldrd	r4, r5, [r3]
  40640e:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
  406412:	f2c0 8516 	blt.w	406e42 <_vfprintf_r+0xdf2>
  406416:	f022 0380 	bic.w	r3, r2, #128	; 0x80
  40641a:	9307      	str	r3, [sp, #28]
  40641c:	ea54 0305 	orrs.w	r3, r4, r5
  406420:	f000 81bc 	beq.w	40679c <_vfprintf_r+0x74c>
  406424:	2d00      	cmp	r5, #0
  406426:	bf08      	it	eq
  406428:	2c0a      	cmpeq	r4, #10
  40642a:	f0c0 850e 	bcc.w	406e4a <_vfprintf_r+0xdfa>
  40642e:	ae30      	add	r6, sp, #192	; 0xc0
  406430:	4620      	mov	r0, r4
  406432:	4629      	mov	r1, r5
  406434:	220a      	movs	r2, #10
  406436:	2300      	movs	r3, #0
  406438:	f004 fa2a 	bl	40a890 <__aeabi_uldivmod>
  40643c:	3230      	adds	r2, #48	; 0x30
  40643e:	f806 2d01 	strb.w	r2, [r6, #-1]!
  406442:	4620      	mov	r0, r4
  406444:	4629      	mov	r1, r5
  406446:	2300      	movs	r3, #0
  406448:	220a      	movs	r2, #10
  40644a:	f004 fa21 	bl	40a890 <__aeabi_uldivmod>
  40644e:	4604      	mov	r4, r0
  406450:	460d      	mov	r5, r1
  406452:	ea54 0305 	orrs.w	r3, r4, r5
  406456:	d1eb      	bne.n	406430 <_vfprintf_r+0x3e0>
  406458:	ab30      	add	r3, sp, #192	; 0xc0
  40645a:	1b9b      	subs	r3, r3, r6
  40645c:	930d      	str	r3, [sp, #52]	; 0x34
  40645e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  406460:	455b      	cmp	r3, fp
  406462:	bfb8      	it	lt
  406464:	465b      	movlt	r3, fp
  406466:	9309      	str	r3, [sp, #36]	; 0x24
  406468:	2300      	movs	r3, #0
  40646a:	9313      	str	r3, [sp, #76]	; 0x4c
  40646c:	b117      	cbz	r7, 406474 <_vfprintf_r+0x424>
  40646e:	9b09      	ldr	r3, [sp, #36]	; 0x24
  406470:	3301      	adds	r3, #1
  406472:	9309      	str	r3, [sp, #36]	; 0x24
  406474:	9b07      	ldr	r3, [sp, #28]
  406476:	f013 0302 	ands.w	r3, r3, #2
  40647a:	930f      	str	r3, [sp, #60]	; 0x3c
  40647c:	d002      	beq.n	406484 <_vfprintf_r+0x434>
  40647e:	9b09      	ldr	r3, [sp, #36]	; 0x24
  406480:	3302      	adds	r3, #2
  406482:	9309      	str	r3, [sp, #36]	; 0x24
  406484:	9b07      	ldr	r3, [sp, #28]
  406486:	f013 0384 	ands.w	r3, r3, #132	; 0x84
  40648a:	9310      	str	r3, [sp, #64]	; 0x40
  40648c:	f040 82cf 	bne.w	406a2e <_vfprintf_r+0x9de>
  406490:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  406492:	9a09      	ldr	r2, [sp, #36]	; 0x24
  406494:	1a9d      	subs	r5, r3, r2
  406496:	2d00      	cmp	r5, #0
  406498:	f340 82c9 	ble.w	406a2e <_vfprintf_r+0x9de>
  40649c:	2d10      	cmp	r5, #16
  40649e:	9925      	ldr	r1, [sp, #148]	; 0x94
  4064a0:	9a24      	ldr	r2, [sp, #144]	; 0x90
  4064a2:	4f06      	ldr	r7, [pc, #24]	; (4064bc <_vfprintf_r+0x46c>)
  4064a4:	dd2e      	ble.n	406504 <_vfprintf_r+0x4b4>
  4064a6:	9618      	str	r6, [sp, #96]	; 0x60
  4064a8:	4648      	mov	r0, r9
  4064aa:	2410      	movs	r4, #16
  4064ac:	46b9      	mov	r9, r7
  4064ae:	9e08      	ldr	r6, [sp, #32]
  4064b0:	462f      	mov	r7, r5
  4064b2:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  4064b4:	e00b      	b.n	4064ce <_vfprintf_r+0x47e>
  4064b6:	bf00      	nop
  4064b8:	0040adfc 	.word	0x0040adfc
  4064bc:	0040ae4c 	.word	0x0040ae4c
  4064c0:	0040ae28 	.word	0x0040ae28
  4064c4:	3f10      	subs	r7, #16
  4064c6:	2f10      	cmp	r7, #16
  4064c8:	f100 0008 	add.w	r0, r0, #8
  4064cc:	dd16      	ble.n	4064fc <_vfprintf_r+0x4ac>
  4064ce:	3201      	adds	r2, #1
  4064d0:	4bb7      	ldr	r3, [pc, #732]	; (4067b0 <_vfprintf_r+0x760>)
  4064d2:	9224      	str	r2, [sp, #144]	; 0x90
  4064d4:	3110      	adds	r1, #16
  4064d6:	2a07      	cmp	r2, #7
  4064d8:	9125      	str	r1, [sp, #148]	; 0x94
  4064da:	e880 0018 	stmia.w	r0, {r3, r4}
  4064de:	ddf1      	ble.n	4064c4 <_vfprintf_r+0x474>
  4064e0:	aa23      	add	r2, sp, #140	; 0x8c
  4064e2:	4631      	mov	r1, r6
  4064e4:	4628      	mov	r0, r5
  4064e6:	f7fe fe75 	bl	4051d4 <__sprint_r>
  4064ea:	2800      	cmp	r0, #0
  4064ec:	f47f aedf 	bne.w	4062ae <_vfprintf_r+0x25e>
  4064f0:	3f10      	subs	r7, #16
  4064f2:	2f10      	cmp	r7, #16
  4064f4:	9925      	ldr	r1, [sp, #148]	; 0x94
  4064f6:	9a24      	ldr	r2, [sp, #144]	; 0x90
  4064f8:	a830      	add	r0, sp, #192	; 0xc0
  4064fa:	dce8      	bgt.n	4064ce <_vfprintf_r+0x47e>
  4064fc:	9e18      	ldr	r6, [sp, #96]	; 0x60
  4064fe:	463d      	mov	r5, r7
  406500:	464f      	mov	r7, r9
  406502:	4681      	mov	r9, r0
  406504:	3201      	adds	r2, #1
  406506:	186c      	adds	r4, r5, r1
  406508:	2a07      	cmp	r2, #7
  40650a:	9425      	str	r4, [sp, #148]	; 0x94
  40650c:	9224      	str	r2, [sp, #144]	; 0x90
  40650e:	f8c9 7000 	str.w	r7, [r9]
  406512:	f8c9 5004 	str.w	r5, [r9, #4]
  406516:	f300 841f 	bgt.w	406d58 <_vfprintf_r+0xd08>
  40651a:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
  40651e:	f109 0908 	add.w	r9, r9, #8
  406522:	b177      	cbz	r7, 406542 <_vfprintf_r+0x4f2>
  406524:	9b24      	ldr	r3, [sp, #144]	; 0x90
  406526:	3301      	adds	r3, #1
  406528:	3401      	adds	r4, #1
  40652a:	f10d 016f 	add.w	r1, sp, #111	; 0x6f
  40652e:	2201      	movs	r2, #1
  406530:	2b07      	cmp	r3, #7
  406532:	9425      	str	r4, [sp, #148]	; 0x94
  406534:	9324      	str	r3, [sp, #144]	; 0x90
  406536:	e889 0006 	stmia.w	r9, {r1, r2}
  40653a:	f300 8397 	bgt.w	406c6c <_vfprintf_r+0xc1c>
  40653e:	f109 0908 	add.w	r9, r9, #8
  406542:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  406544:	b16b      	cbz	r3, 406562 <_vfprintf_r+0x512>
  406546:	9b24      	ldr	r3, [sp, #144]	; 0x90
  406548:	3301      	adds	r3, #1
  40654a:	3402      	adds	r4, #2
  40654c:	a91c      	add	r1, sp, #112	; 0x70
  40654e:	2202      	movs	r2, #2
  406550:	2b07      	cmp	r3, #7
  406552:	9425      	str	r4, [sp, #148]	; 0x94
  406554:	9324      	str	r3, [sp, #144]	; 0x90
  406556:	e889 0006 	stmia.w	r9, {r1, r2}
  40655a:	f300 8393 	bgt.w	406c84 <_vfprintf_r+0xc34>
  40655e:	f109 0908 	add.w	r9, r9, #8
  406562:	9b10      	ldr	r3, [sp, #64]	; 0x40
  406564:	2b80      	cmp	r3, #128	; 0x80
  406566:	f000 82c6 	beq.w	406af6 <_vfprintf_r+0xaa6>
  40656a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  40656c:	ebc3 070b 	rsb	r7, r3, fp
  406570:	2f00      	cmp	r7, #0
  406572:	dd33      	ble.n	4065dc <_vfprintf_r+0x58c>
  406574:	4a8f      	ldr	r2, [pc, #572]	; (4067b4 <_vfprintf_r+0x764>)
  406576:	9b24      	ldr	r3, [sp, #144]	; 0x90
  406578:	920f      	str	r2, [sp, #60]	; 0x3c
  40657a:	2f10      	cmp	r7, #16
  40657c:	dd22      	ble.n	4065c4 <_vfprintf_r+0x574>
  40657e:	4622      	mov	r2, r4
  406580:	f04f 0b10 	mov.w	fp, #16
  406584:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  406586:	9c08      	ldr	r4, [sp, #32]
  406588:	e004      	b.n	406594 <_vfprintf_r+0x544>
  40658a:	3f10      	subs	r7, #16
  40658c:	2f10      	cmp	r7, #16
  40658e:	f109 0908 	add.w	r9, r9, #8
  406592:	dd16      	ble.n	4065c2 <_vfprintf_r+0x572>
  406594:	3301      	adds	r3, #1
  406596:	3210      	adds	r2, #16
  406598:	2b07      	cmp	r3, #7
  40659a:	9225      	str	r2, [sp, #148]	; 0x94
  40659c:	9324      	str	r3, [sp, #144]	; 0x90
  40659e:	e889 0c00 	stmia.w	r9, {sl, fp}
  4065a2:	ddf2      	ble.n	40658a <_vfprintf_r+0x53a>
  4065a4:	aa23      	add	r2, sp, #140	; 0x8c
  4065a6:	4621      	mov	r1, r4
  4065a8:	4628      	mov	r0, r5
  4065aa:	f7fe fe13 	bl	4051d4 <__sprint_r>
  4065ae:	2800      	cmp	r0, #0
  4065b0:	f47f ae7d 	bne.w	4062ae <_vfprintf_r+0x25e>
  4065b4:	3f10      	subs	r7, #16
  4065b6:	2f10      	cmp	r7, #16
  4065b8:	9a25      	ldr	r2, [sp, #148]	; 0x94
  4065ba:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4065bc:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  4065c0:	dce8      	bgt.n	406594 <_vfprintf_r+0x544>
  4065c2:	4614      	mov	r4, r2
  4065c4:	3301      	adds	r3, #1
  4065c6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  4065c8:	9324      	str	r3, [sp, #144]	; 0x90
  4065ca:	443c      	add	r4, r7
  4065cc:	2b07      	cmp	r3, #7
  4065ce:	9425      	str	r4, [sp, #148]	; 0x94
  4065d0:	e889 0084 	stmia.w	r9, {r2, r7}
  4065d4:	f300 833e 	bgt.w	406c54 <_vfprintf_r+0xc04>
  4065d8:	f109 0908 	add.w	r9, r9, #8
  4065dc:	9b07      	ldr	r3, [sp, #28]
  4065de:	05dd      	lsls	r5, r3, #23
  4065e0:	f100 8227 	bmi.w	406a32 <_vfprintf_r+0x9e2>
  4065e4:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4065e6:	990d      	ldr	r1, [sp, #52]	; 0x34
  4065e8:	f8c9 6000 	str.w	r6, [r9]
  4065ec:	3301      	adds	r3, #1
  4065ee:	440c      	add	r4, r1
  4065f0:	2b07      	cmp	r3, #7
  4065f2:	9425      	str	r4, [sp, #148]	; 0x94
  4065f4:	f8c9 1004 	str.w	r1, [r9, #4]
  4065f8:	9324      	str	r3, [sp, #144]	; 0x90
  4065fa:	f300 8315 	bgt.w	406c28 <_vfprintf_r+0xbd8>
  4065fe:	f109 0908 	add.w	r9, r9, #8
  406602:	9b07      	ldr	r3, [sp, #28]
  406604:	0758      	lsls	r0, r3, #29
  406606:	d53f      	bpl.n	406688 <_vfprintf_r+0x638>
  406608:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  40660a:	9a09      	ldr	r2, [sp, #36]	; 0x24
  40660c:	1a9d      	subs	r5, r3, r2
  40660e:	2d00      	cmp	r5, #0
  406610:	dd3a      	ble.n	406688 <_vfprintf_r+0x638>
  406612:	2d10      	cmp	r5, #16
  406614:	9b24      	ldr	r3, [sp, #144]	; 0x90
  406616:	4f66      	ldr	r7, [pc, #408]	; (4067b0 <_vfprintf_r+0x760>)
  406618:	dd23      	ble.n	406662 <_vfprintf_r+0x612>
  40661a:	4622      	mov	r2, r4
  40661c:	2610      	movs	r6, #16
  40661e:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
  406622:	9c08      	ldr	r4, [sp, #32]
  406624:	e004      	b.n	406630 <_vfprintf_r+0x5e0>
  406626:	3d10      	subs	r5, #16
  406628:	2d10      	cmp	r5, #16
  40662a:	f109 0908 	add.w	r9, r9, #8
  40662e:	dd17      	ble.n	406660 <_vfprintf_r+0x610>
  406630:	3301      	adds	r3, #1
  406632:	495f      	ldr	r1, [pc, #380]	; (4067b0 <_vfprintf_r+0x760>)
  406634:	9324      	str	r3, [sp, #144]	; 0x90
  406636:	3210      	adds	r2, #16
  406638:	2b07      	cmp	r3, #7
  40663a:	9225      	str	r2, [sp, #148]	; 0x94
  40663c:	e889 0042 	stmia.w	r9, {r1, r6}
  406640:	ddf1      	ble.n	406626 <_vfprintf_r+0x5d6>
  406642:	aa23      	add	r2, sp, #140	; 0x8c
  406644:	4621      	mov	r1, r4
  406646:	4658      	mov	r0, fp
  406648:	f7fe fdc4 	bl	4051d4 <__sprint_r>
  40664c:	2800      	cmp	r0, #0
  40664e:	f47f ae2e 	bne.w	4062ae <_vfprintf_r+0x25e>
  406652:	3d10      	subs	r5, #16
  406654:	2d10      	cmp	r5, #16
  406656:	9a25      	ldr	r2, [sp, #148]	; 0x94
  406658:	9b24      	ldr	r3, [sp, #144]	; 0x90
  40665a:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  40665e:	dce7      	bgt.n	406630 <_vfprintf_r+0x5e0>
  406660:	4614      	mov	r4, r2
  406662:	3301      	adds	r3, #1
  406664:	442c      	add	r4, r5
  406666:	2b07      	cmp	r3, #7
  406668:	9425      	str	r4, [sp, #148]	; 0x94
  40666a:	9324      	str	r3, [sp, #144]	; 0x90
  40666c:	f8c9 7000 	str.w	r7, [r9]
  406670:	f8c9 5004 	str.w	r5, [r9, #4]
  406674:	dd08      	ble.n	406688 <_vfprintf_r+0x638>
  406676:	aa23      	add	r2, sp, #140	; 0x8c
  406678:	9908      	ldr	r1, [sp, #32]
  40667a:	980a      	ldr	r0, [sp, #40]	; 0x28
  40667c:	f7fe fdaa 	bl	4051d4 <__sprint_r>
  406680:	2800      	cmp	r0, #0
  406682:	f47f ae14 	bne.w	4062ae <_vfprintf_r+0x25e>
  406686:	9c25      	ldr	r4, [sp, #148]	; 0x94
  406688:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  40668a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  40668c:	9909      	ldr	r1, [sp, #36]	; 0x24
  40668e:	428a      	cmp	r2, r1
  406690:	bfac      	ite	ge
  406692:	189b      	addge	r3, r3, r2
  406694:	185b      	addlt	r3, r3, r1
  406696:	930b      	str	r3, [sp, #44]	; 0x2c
  406698:	2c00      	cmp	r4, #0
  40669a:	f040 82d1 	bne.w	406c40 <_vfprintf_r+0xbf0>
  40669e:	2300      	movs	r3, #0
  4066a0:	9324      	str	r3, [sp, #144]	; 0x90
  4066a2:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  4066a6:	e513      	b.n	4060d0 <_vfprintf_r+0x80>
  4066a8:	9311      	str	r3, [sp, #68]	; 0x44
  4066aa:	46ab      	mov	fp, r5
  4066ac:	2a00      	cmp	r2, #0
  4066ae:	f041 8014 	bne.w	4076da <_vfprintf_r+0x168a>
  4066b2:	9b07      	ldr	r3, [sp, #28]
  4066b4:	4840      	ldr	r0, [pc, #256]	; (4067b8 <_vfprintf_r+0x768>)
  4066b6:	069c      	lsls	r4, r3, #26
  4066b8:	f140 813c 	bpl.w	406934 <_vfprintf_r+0x8e4>
  4066bc:	9f0e      	ldr	r7, [sp, #56]	; 0x38
  4066be:	3707      	adds	r7, #7
  4066c0:	f027 0307 	bic.w	r3, r7, #7
  4066c4:	e9d3 4500 	ldrd	r4, r5, [r3]
  4066c8:	f103 0208 	add.w	r2, r3, #8
  4066cc:	920e      	str	r2, [sp, #56]	; 0x38
  4066ce:	9a07      	ldr	r2, [sp, #28]
  4066d0:	f012 0701 	ands.w	r7, r2, #1
  4066d4:	f000 82e2 	beq.w	406c9c <_vfprintf_r+0xc4c>
  4066d8:	ea54 0305 	orrs.w	r3, r4, r5
  4066dc:	f000 856c 	beq.w	4071b8 <_vfprintf_r+0x1168>
  4066e0:	f89d 2044 	ldrb.w	r2, [sp, #68]	; 0x44
  4066e4:	f88d 2071 	strb.w	r2, [sp, #113]	; 0x71
  4066e8:	2700      	movs	r7, #0
  4066ea:	9a07      	ldr	r2, [sp, #28]
  4066ec:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
  4066f0:	2330      	movs	r3, #48	; 0x30
  4066f2:	45bb      	cmp	fp, r7
  4066f4:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
  4066f8:	f042 0302 	orr.w	r3, r2, #2
  4066fc:	f2c0 8715 	blt.w	40752a <_vfprintf_r+0x14da>
  406700:	f022 0380 	bic.w	r3, r2, #128	; 0x80
  406704:	f043 0302 	orr.w	r3, r3, #2
  406708:	9307      	str	r3, [sp, #28]
  40670a:	ae30      	add	r6, sp, #192	; 0xc0
  40670c:	0923      	lsrs	r3, r4, #4
  40670e:	f004 010f 	and.w	r1, r4, #15
  406712:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
  406716:	092a      	lsrs	r2, r5, #4
  406718:	461c      	mov	r4, r3
  40671a:	4615      	mov	r5, r2
  40671c:	5c43      	ldrb	r3, [r0, r1]
  40671e:	f806 3d01 	strb.w	r3, [r6, #-1]!
  406722:	ea54 0305 	orrs.w	r3, r4, r5
  406726:	d1f1      	bne.n	40670c <_vfprintf_r+0x6bc>
  406728:	e696      	b.n	406458 <_vfprintf_r+0x408>
  40672a:	990e      	ldr	r1, [sp, #56]	; 0x38
  40672c:	9311      	str	r3, [sp, #68]	; 0x44
  40672e:	680a      	ldr	r2, [r1, #0]
  406730:	f88d 2098 	strb.w	r2, [sp, #152]	; 0x98
  406734:	2300      	movs	r3, #0
  406736:	460a      	mov	r2, r1
  406738:	461f      	mov	r7, r3
  40673a:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
  40673e:	3204      	adds	r2, #4
  406740:	2301      	movs	r3, #1
  406742:	9309      	str	r3, [sp, #36]	; 0x24
  406744:	46bb      	mov	fp, r7
  406746:	9713      	str	r7, [sp, #76]	; 0x4c
  406748:	920e      	str	r2, [sp, #56]	; 0x38
  40674a:	930d      	str	r3, [sp, #52]	; 0x34
  40674c:	ae26      	add	r6, sp, #152	; 0x98
  40674e:	e691      	b.n	406474 <_vfprintf_r+0x424>
  406750:	9311      	str	r3, [sp, #68]	; 0x44
  406752:	46ab      	mov	fp, r5
  406754:	2a00      	cmp	r2, #0
  406756:	f040 87d7 	bne.w	407708 <_vfprintf_r+0x16b8>
  40675a:	9b07      	ldr	r3, [sp, #28]
  40675c:	069f      	lsls	r7, r3, #26
  40675e:	d57a      	bpl.n	406856 <_vfprintf_r+0x806>
  406760:	9f0e      	ldr	r7, [sp, #56]	; 0x38
  406762:	3707      	adds	r7, #7
  406764:	f027 0707 	bic.w	r7, r7, #7
  406768:	e9d7 2300 	ldrd	r2, r3, [r7]
  40676c:	f107 0108 	add.w	r1, r7, #8
  406770:	910e      	str	r1, [sp, #56]	; 0x38
  406772:	4614      	mov	r4, r2
  406774:	461d      	mov	r5, r3
  406776:	2a00      	cmp	r2, #0
  406778:	f173 0300 	sbcs.w	r3, r3, #0
  40677c:	f2c0 8438 	blt.w	406ff0 <_vfprintf_r+0xfa0>
  406780:	f1bb 0f00 	cmp.w	fp, #0
  406784:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
  406788:	f2c0 835b 	blt.w	406e42 <_vfprintf_r+0xdf2>
  40678c:	9b07      	ldr	r3, [sp, #28]
  40678e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  406792:	9307      	str	r3, [sp, #28]
  406794:	ea54 0305 	orrs.w	r3, r4, r5
  406798:	f47f ae44 	bne.w	406424 <_vfprintf_r+0x3d4>
  40679c:	f1bb 0f00 	cmp.w	fp, #0
  4067a0:	f040 8414 	bne.w	406fcc <_vfprintf_r+0xf7c>
  4067a4:	f04f 0b00 	mov.w	fp, #0
  4067a8:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
  4067ac:	ae30      	add	r6, sp, #192	; 0xc0
  4067ae:	e656      	b.n	40645e <_vfprintf_r+0x40e>
  4067b0:	0040ae4c 	.word	0x0040ae4c
  4067b4:	0040ae28 	.word	0x0040ae28
  4067b8:	0040ade8 	.word	0x0040ade8
  4067bc:	9b07      	ldr	r3, [sp, #28]
  4067be:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  4067c2:	9307      	str	r3, [sp, #28]
  4067c4:	f898 3000 	ldrb.w	r3, [r8]
  4067c8:	e4b5      	b.n	406136 <_vfprintf_r+0xe6>
  4067ca:	f898 3000 	ldrb.w	r3, [r8]
  4067ce:	2b6c      	cmp	r3, #108	; 0x6c
  4067d0:	f000 85c2 	beq.w	407358 <_vfprintf_r+0x1308>
  4067d4:	9807      	ldr	r0, [sp, #28]
  4067d6:	f040 0010 	orr.w	r0, r0, #16
  4067da:	9007      	str	r0, [sp, #28]
  4067dc:	e4ab      	b.n	406136 <_vfprintf_r+0xe6>
  4067de:	2a00      	cmp	r2, #0
  4067e0:	f040 87a2 	bne.w	407728 <_vfprintf_r+0x16d8>
  4067e4:	9b07      	ldr	r3, [sp, #28]
  4067e6:	069f      	lsls	r7, r3, #26
  4067e8:	f140 8413 	bpl.w	407012 <_vfprintf_r+0xfc2>
  4067ec:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  4067ee:	990b      	ldr	r1, [sp, #44]	; 0x2c
  4067f0:	6813      	ldr	r3, [r2, #0]
  4067f2:	17cd      	asrs	r5, r1, #31
  4067f4:	4608      	mov	r0, r1
  4067f6:	3204      	adds	r2, #4
  4067f8:	4629      	mov	r1, r5
  4067fa:	920e      	str	r2, [sp, #56]	; 0x38
  4067fc:	e9c3 0100 	strd	r0, r1, [r3]
  406800:	e466      	b.n	4060d0 <_vfprintf_r+0x80>
  406802:	9c0e      	ldr	r4, [sp, #56]	; 0x38
  406804:	6823      	ldr	r3, [r4, #0]
  406806:	930c      	str	r3, [sp, #48]	; 0x30
  406808:	4618      	mov	r0, r3
  40680a:	2800      	cmp	r0, #0
  40680c:	4623      	mov	r3, r4
  40680e:	f103 0304 	add.w	r3, r3, #4
  406812:	f6ff acf2 	blt.w	4061fa <_vfprintf_r+0x1aa>
  406816:	930e      	str	r3, [sp, #56]	; 0x38
  406818:	f898 3000 	ldrb.w	r3, [r8]
  40681c:	e48b      	b.n	406136 <_vfprintf_r+0xe6>
  40681e:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
  406822:	2300      	movs	r3, #0
  406824:	461c      	mov	r4, r3
  406826:	f818 3b01 	ldrb.w	r3, [r8], #1
  40682a:	eb04 0484 	add.w	r4, r4, r4, lsl #2
  40682e:	eb00 0444 	add.w	r4, r0, r4, lsl #1
  406832:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
  406836:	2809      	cmp	r0, #9
  406838:	d9f5      	bls.n	406826 <_vfprintf_r+0x7d6>
  40683a:	940c      	str	r4, [sp, #48]	; 0x30
  40683c:	e47d      	b.n	40613a <_vfprintf_r+0xea>
  40683e:	9311      	str	r3, [sp, #68]	; 0x44
  406840:	46ab      	mov	fp, r5
  406842:	2a00      	cmp	r2, #0
  406844:	f040 876c 	bne.w	407720 <_vfprintf_r+0x16d0>
  406848:	9b07      	ldr	r3, [sp, #28]
  40684a:	f043 0310 	orr.w	r3, r3, #16
  40684e:	9307      	str	r3, [sp, #28]
  406850:	9b07      	ldr	r3, [sp, #28]
  406852:	069f      	lsls	r7, r3, #26
  406854:	d484      	bmi.n	406760 <_vfprintf_r+0x710>
  406856:	9b07      	ldr	r3, [sp, #28]
  406858:	06de      	lsls	r6, r3, #27
  40685a:	f100 82bc 	bmi.w	406dd6 <_vfprintf_r+0xd86>
  40685e:	9b07      	ldr	r3, [sp, #28]
  406860:	065d      	lsls	r5, r3, #25
  406862:	f140 82b8 	bpl.w	406dd6 <_vfprintf_r+0xd86>
  406866:	990e      	ldr	r1, [sp, #56]	; 0x38
  406868:	f9b1 4000 	ldrsh.w	r4, [r1]
  40686c:	3104      	adds	r1, #4
  40686e:	17e5      	asrs	r5, r4, #31
  406870:	4622      	mov	r2, r4
  406872:	462b      	mov	r3, r5
  406874:	910e      	str	r1, [sp, #56]	; 0x38
  406876:	e77e      	b.n	406776 <_vfprintf_r+0x726>
  406878:	9311      	str	r3, [sp, #68]	; 0x44
  40687a:	46ab      	mov	fp, r5
  40687c:	2a00      	cmp	r2, #0
  40687e:	f040 8738 	bne.w	4076f2 <_vfprintf_r+0x16a2>
  406882:	9f0e      	ldr	r7, [sp, #56]	; 0x38
  406884:	3707      	adds	r7, #7
  406886:	f027 0307 	bic.w	r3, r7, #7
  40688a:	f103 0208 	add.w	r2, r3, #8
  40688e:	920e      	str	r2, [sp, #56]	; 0x38
  406890:	681a      	ldr	r2, [r3, #0]
  406892:	9214      	str	r2, [sp, #80]	; 0x50
  406894:	685b      	ldr	r3, [r3, #4]
  406896:	9315      	str	r3, [sp, #84]	; 0x54
  406898:	9b15      	ldr	r3, [sp, #84]	; 0x54
  40689a:	9d14      	ldr	r5, [sp, #80]	; 0x50
  40689c:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
  4068a0:	4628      	mov	r0, r5
  4068a2:	4621      	mov	r1, r4
  4068a4:	f04f 32ff 	mov.w	r2, #4294967295
  4068a8:	4bb5      	ldr	r3, [pc, #724]	; (406b80 <_vfprintf_r+0xb30>)
  4068aa:	f003 ffb3 	bl	40a814 <__aeabi_dcmpun>
  4068ae:	2800      	cmp	r0, #0
  4068b0:	f040 83c6 	bne.w	407040 <_vfprintf_r+0xff0>
  4068b4:	4628      	mov	r0, r5
  4068b6:	4621      	mov	r1, r4
  4068b8:	f04f 32ff 	mov.w	r2, #4294967295
  4068bc:	4bb0      	ldr	r3, [pc, #704]	; (406b80 <_vfprintf_r+0xb30>)
  4068be:	f7fe f9ad 	bl	404c1c <__aeabi_dcmple>
  4068c2:	2800      	cmp	r0, #0
  4068c4:	f040 83bc 	bne.w	407040 <_vfprintf_r+0xff0>
  4068c8:	9814      	ldr	r0, [sp, #80]	; 0x50
  4068ca:	9915      	ldr	r1, [sp, #84]	; 0x54
  4068cc:	2200      	movs	r2, #0
  4068ce:	2300      	movs	r3, #0
  4068d0:	f7fe f99a 	bl	404c08 <__aeabi_dcmplt>
  4068d4:	2800      	cmp	r0, #0
  4068d6:	f040 863f 	bne.w	407558 <_vfprintf_r+0x1508>
  4068da:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
  4068de:	4ea9      	ldr	r6, [pc, #676]	; (406b84 <_vfprintf_r+0xb34>)
  4068e0:	4ba9      	ldr	r3, [pc, #676]	; (406b88 <_vfprintf_r+0xb38>)
  4068e2:	9907      	ldr	r1, [sp, #28]
  4068e4:	f021 0180 	bic.w	r1, r1, #128	; 0x80
  4068e8:	9107      	str	r1, [sp, #28]
  4068ea:	9911      	ldr	r1, [sp, #68]	; 0x44
  4068ec:	2203      	movs	r2, #3
  4068ee:	f04f 0b00 	mov.w	fp, #0
  4068f2:	9209      	str	r2, [sp, #36]	; 0x24
  4068f4:	2947      	cmp	r1, #71	; 0x47
  4068f6:	bfd8      	it	le
  4068f8:	461e      	movle	r6, r3
  4068fa:	920d      	str	r2, [sp, #52]	; 0x34
  4068fc:	f8cd b04c 	str.w	fp, [sp, #76]	; 0x4c
  406900:	e5b4      	b.n	40646c <_vfprintf_r+0x41c>
  406902:	9b07      	ldr	r3, [sp, #28]
  406904:	f043 0308 	orr.w	r3, r3, #8
  406908:	9307      	str	r3, [sp, #28]
  40690a:	f898 3000 	ldrb.w	r3, [r8]
  40690e:	e412      	b.n	406136 <_vfprintf_r+0xe6>
  406910:	9311      	str	r3, [sp, #68]	; 0x44
  406912:	46ab      	mov	fp, r5
  406914:	2a00      	cmp	r2, #0
  406916:	f43f ad6a 	beq.w	4063ee <_vfprintf_r+0x39e>
  40691a:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  40691e:	e566      	b.n	4063ee <_vfprintf_r+0x39e>
  406920:	9311      	str	r3, [sp, #68]	; 0x44
  406922:	46ab      	mov	fp, r5
  406924:	2a00      	cmp	r2, #0
  406926:	f040 86e0 	bne.w	4076ea <_vfprintf_r+0x169a>
  40692a:	9b07      	ldr	r3, [sp, #28]
  40692c:	4897      	ldr	r0, [pc, #604]	; (406b8c <_vfprintf_r+0xb3c>)
  40692e:	069c      	lsls	r4, r3, #26
  406930:	f53f aec4 	bmi.w	4066bc <_vfprintf_r+0x66c>
  406934:	9b07      	ldr	r3, [sp, #28]
  406936:	06d9      	lsls	r1, r3, #27
  406938:	f140 841f 	bpl.w	40717a <_vfprintf_r+0x112a>
  40693c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  40693e:	4613      	mov	r3, r2
  406940:	3304      	adds	r3, #4
  406942:	6814      	ldr	r4, [r2, #0]
  406944:	930e      	str	r3, [sp, #56]	; 0x38
  406946:	2500      	movs	r5, #0
  406948:	e6c1      	b.n	4066ce <_vfprintf_r+0x67e>
  40694a:	f898 3000 	ldrb.w	r3, [r8]
  40694e:	2900      	cmp	r1, #0
  406950:	f47f abf1 	bne.w	406136 <_vfprintf_r+0xe6>
  406954:	2201      	movs	r2, #1
  406956:	2120      	movs	r1, #32
  406958:	f7ff bbed 	b.w	406136 <_vfprintf_r+0xe6>
  40695c:	9b07      	ldr	r3, [sp, #28]
  40695e:	f043 0301 	orr.w	r3, r3, #1
  406962:	9307      	str	r3, [sp, #28]
  406964:	f898 3000 	ldrb.w	r3, [r8]
  406968:	f7ff bbe5 	b.w	406136 <_vfprintf_r+0xe6>
  40696c:	9b07      	ldr	r3, [sp, #28]
  40696e:	f043 0320 	orr.w	r3, r3, #32
  406972:	9307      	str	r3, [sp, #28]
  406974:	f898 3000 	ldrb.w	r3, [r8]
  406978:	f7ff bbdd 	b.w	406136 <_vfprintf_r+0xe6>
  40697c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  40697e:	9311      	str	r3, [sp, #68]	; 0x44
  406980:	6816      	ldr	r6, [r2, #0]
  406982:	2400      	movs	r4, #0
  406984:	f88d 406f 	strb.w	r4, [sp, #111]	; 0x6f
  406988:	1d17      	adds	r7, r2, #4
  40698a:	2e00      	cmp	r6, #0
  40698c:	f000 85bb 	beq.w	407506 <_vfprintf_r+0x14b6>
  406990:	2d00      	cmp	r5, #0
  406992:	f2c0 8511 	blt.w	4073b8 <_vfprintf_r+0x1368>
  406996:	462a      	mov	r2, r5
  406998:	4621      	mov	r1, r4
  40699a:	4630      	mov	r0, r6
  40699c:	f002 ff18 	bl	4097d0 <memchr>
  4069a0:	2800      	cmp	r0, #0
  4069a2:	f000 85f9 	beq.w	407598 <_vfprintf_r+0x1548>
  4069a6:	1b83      	subs	r3, r0, r6
  4069a8:	930d      	str	r3, [sp, #52]	; 0x34
  4069aa:	46a3      	mov	fp, r4
  4069ac:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  4069b0:	970e      	str	r7, [sp, #56]	; 0x38
  4069b2:	9309      	str	r3, [sp, #36]	; 0x24
  4069b4:	f8cd b04c 	str.w	fp, [sp, #76]	; 0x4c
  4069b8:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
  4069bc:	e556      	b.n	40646c <_vfprintf_r+0x41c>
  4069be:	f898 3000 	ldrb.w	r3, [r8]
  4069c2:	2201      	movs	r2, #1
  4069c4:	212b      	movs	r1, #43	; 0x2b
  4069c6:	f7ff bbb6 	b.w	406136 <_vfprintf_r+0xe6>
  4069ca:	4870      	ldr	r0, [pc, #448]	; (406b8c <_vfprintf_r+0xb3c>)
  4069cc:	9211      	str	r2, [sp, #68]	; 0x44
  4069ce:	f1bb 0f00 	cmp.w	fp, #0
  4069d2:	f040 8174 	bne.w	406cbe <_vfprintf_r+0xc6e>
  4069d6:	465f      	mov	r7, fp
  4069d8:	e6e4      	b.n	4067a4 <_vfprintf_r+0x754>
  4069da:	9311      	str	r3, [sp, #68]	; 0x44
  4069dc:	2a00      	cmp	r2, #0
  4069de:	f040 869b 	bne.w	407718 <_vfprintf_r+0x16c8>
  4069e2:	9a11      	ldr	r2, [sp, #68]	; 0x44
  4069e4:	2a00      	cmp	r2, #0
  4069e6:	f43f ac5b 	beq.w	4062a0 <_vfprintf_r+0x250>
  4069ea:	2300      	movs	r3, #0
  4069ec:	2101      	movs	r1, #1
  4069ee:	461f      	mov	r7, r3
  4069f0:	9109      	str	r1, [sp, #36]	; 0x24
  4069f2:	f88d 2098 	strb.w	r2, [sp, #152]	; 0x98
  4069f6:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
  4069fa:	469b      	mov	fp, r3
  4069fc:	9313      	str	r3, [sp, #76]	; 0x4c
  4069fe:	910d      	str	r1, [sp, #52]	; 0x34
  406a00:	ae26      	add	r6, sp, #152	; 0x98
  406a02:	e537      	b.n	406474 <_vfprintf_r+0x424>
  406a04:	f1bb 0f00 	cmp.w	fp, #0
  406a08:	f000 85d1 	beq.w	4075ae <_vfprintf_r+0x155e>
  406a0c:	2700      	movs	r7, #0
  406a0e:	2400      	movs	r4, #0
  406a10:	2500      	movs	r5, #0
  406a12:	e478      	b.n	406306 <_vfprintf_r+0x2b6>
  406a14:	485d      	ldr	r0, [pc, #372]	; (406b8c <_vfprintf_r+0xb3c>)
  406a16:	9307      	str	r3, [sp, #28]
  406a18:	9211      	str	r2, [sp, #68]	; 0x44
  406a1a:	ea54 0305 	orrs.w	r3, r4, r5
  406a1e:	970e      	str	r7, [sp, #56]	; 0x38
  406a20:	f04f 0700 	mov.w	r7, #0
  406a24:	f47f ae71 	bne.w	40670a <_vfprintf_r+0x6ba>
  406a28:	2400      	movs	r4, #0
  406a2a:	2500      	movs	r5, #0
  406a2c:	e66d      	b.n	40670a <_vfprintf_r+0x6ba>
  406a2e:	9c25      	ldr	r4, [sp, #148]	; 0x94
  406a30:	e577      	b.n	406522 <_vfprintf_r+0x4d2>
  406a32:	9b11      	ldr	r3, [sp, #68]	; 0x44
  406a34:	2b65      	cmp	r3, #101	; 0x65
  406a36:	f340 80af 	ble.w	406b98 <_vfprintf_r+0xb48>
  406a3a:	9814      	ldr	r0, [sp, #80]	; 0x50
  406a3c:	9915      	ldr	r1, [sp, #84]	; 0x54
  406a3e:	2200      	movs	r2, #0
  406a40:	2300      	movs	r3, #0
  406a42:	f7fe f8d7 	bl	404bf4 <__aeabi_dcmpeq>
  406a46:	2800      	cmp	r0, #0
  406a48:	f000 813b 	beq.w	406cc2 <_vfprintf_r+0xc72>
  406a4c:	9b24      	ldr	r3, [sp, #144]	; 0x90
  406a4e:	4a50      	ldr	r2, [pc, #320]	; (406b90 <_vfprintf_r+0xb40>)
  406a50:	f8c9 2000 	str.w	r2, [r9]
  406a54:	3301      	adds	r3, #1
  406a56:	3401      	adds	r4, #1
  406a58:	2201      	movs	r2, #1
  406a5a:	2b07      	cmp	r3, #7
  406a5c:	9425      	str	r4, [sp, #148]	; 0x94
  406a5e:	9324      	str	r3, [sp, #144]	; 0x90
  406a60:	f8c9 2004 	str.w	r2, [r9, #4]
  406a64:	f300 83b4 	bgt.w	4071d0 <_vfprintf_r+0x1180>
  406a68:	f109 0908 	add.w	r9, r9, #8
  406a6c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  406a6e:	9a12      	ldr	r2, [sp, #72]	; 0x48
  406a70:	4293      	cmp	r3, r2
  406a72:	db03      	blt.n	406a7c <_vfprintf_r+0xa2c>
  406a74:	9b07      	ldr	r3, [sp, #28]
  406a76:	07d8      	lsls	r0, r3, #31
  406a78:	f57f adc3 	bpl.w	406602 <_vfprintf_r+0x5b2>
  406a7c:	9b24      	ldr	r3, [sp, #144]	; 0x90
  406a7e:	9916      	ldr	r1, [sp, #88]	; 0x58
  406a80:	9a17      	ldr	r2, [sp, #92]	; 0x5c
  406a82:	f8c9 2000 	str.w	r2, [r9]
  406a86:	3301      	adds	r3, #1
  406a88:	440c      	add	r4, r1
  406a8a:	2b07      	cmp	r3, #7
  406a8c:	9425      	str	r4, [sp, #148]	; 0x94
  406a8e:	f8c9 1004 	str.w	r1, [r9, #4]
  406a92:	9324      	str	r3, [sp, #144]	; 0x90
  406a94:	f300 846a 	bgt.w	40736c <_vfprintf_r+0x131c>
  406a98:	f109 0908 	add.w	r9, r9, #8
  406a9c:	9b12      	ldr	r3, [sp, #72]	; 0x48
  406a9e:	1e5d      	subs	r5, r3, #1
  406aa0:	2d00      	cmp	r5, #0
  406aa2:	f77f adae 	ble.w	406602 <_vfprintf_r+0x5b2>
  406aa6:	4a3b      	ldr	r2, [pc, #236]	; (406b94 <_vfprintf_r+0xb44>)
  406aa8:	9b24      	ldr	r3, [sp, #144]	; 0x90
  406aaa:	920f      	str	r2, [sp, #60]	; 0x3c
  406aac:	2d10      	cmp	r5, #16
  406aae:	f340 81d2 	ble.w	406e56 <_vfprintf_r+0xe06>
  406ab2:	2610      	movs	r6, #16
  406ab4:	9f0a      	ldr	r7, [sp, #40]	; 0x28
  406ab6:	f8dd b020 	ldr.w	fp, [sp, #32]
  406aba:	e005      	b.n	406ac8 <_vfprintf_r+0xa78>
  406abc:	f109 0908 	add.w	r9, r9, #8
  406ac0:	3d10      	subs	r5, #16
  406ac2:	2d10      	cmp	r5, #16
  406ac4:	f340 81c7 	ble.w	406e56 <_vfprintf_r+0xe06>
  406ac8:	3301      	adds	r3, #1
  406aca:	3410      	adds	r4, #16
  406acc:	2b07      	cmp	r3, #7
  406ace:	9425      	str	r4, [sp, #148]	; 0x94
  406ad0:	9324      	str	r3, [sp, #144]	; 0x90
  406ad2:	f8c9 a000 	str.w	sl, [r9]
  406ad6:	f8c9 6004 	str.w	r6, [r9, #4]
  406ada:	ddef      	ble.n	406abc <_vfprintf_r+0xa6c>
  406adc:	aa23      	add	r2, sp, #140	; 0x8c
  406ade:	4659      	mov	r1, fp
  406ae0:	4638      	mov	r0, r7
  406ae2:	f7fe fb77 	bl	4051d4 <__sprint_r>
  406ae6:	2800      	cmp	r0, #0
  406ae8:	f47f abe1 	bne.w	4062ae <_vfprintf_r+0x25e>
  406aec:	9c25      	ldr	r4, [sp, #148]	; 0x94
  406aee:	9b24      	ldr	r3, [sp, #144]	; 0x90
  406af0:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  406af4:	e7e4      	b.n	406ac0 <_vfprintf_r+0xa70>
  406af6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  406af8:	9a09      	ldr	r2, [sp, #36]	; 0x24
  406afa:	1a9f      	subs	r7, r3, r2
  406afc:	2f00      	cmp	r7, #0
  406afe:	f77f ad34 	ble.w	40656a <_vfprintf_r+0x51a>
  406b02:	4a24      	ldr	r2, [pc, #144]	; (406b94 <_vfprintf_r+0xb44>)
  406b04:	9b24      	ldr	r3, [sp, #144]	; 0x90
  406b06:	920f      	str	r2, [sp, #60]	; 0x3c
  406b08:	2f10      	cmp	r7, #16
  406b0a:	dd2b      	ble.n	406b64 <_vfprintf_r+0xb14>
  406b0c:	464a      	mov	r2, r9
  406b0e:	4621      	mov	r1, r4
  406b10:	46b9      	mov	r9, r7
  406b12:	2510      	movs	r5, #16
  406b14:	4637      	mov	r7, r6
  406b16:	9c0a      	ldr	r4, [sp, #40]	; 0x28
  406b18:	9e08      	ldr	r6, [sp, #32]
  406b1a:	e006      	b.n	406b2a <_vfprintf_r+0xada>
  406b1c:	f1a9 0910 	sub.w	r9, r9, #16
  406b20:	f1b9 0f10 	cmp.w	r9, #16
  406b24:	f102 0208 	add.w	r2, r2, #8
  406b28:	dd18      	ble.n	406b5c <_vfprintf_r+0xb0c>
  406b2a:	3301      	adds	r3, #1
  406b2c:	3110      	adds	r1, #16
  406b2e:	2b07      	cmp	r3, #7
  406b30:	9125      	str	r1, [sp, #148]	; 0x94
  406b32:	9324      	str	r3, [sp, #144]	; 0x90
  406b34:	f8c2 a000 	str.w	sl, [r2]
  406b38:	6055      	str	r5, [r2, #4]
  406b3a:	ddef      	ble.n	406b1c <_vfprintf_r+0xacc>
  406b3c:	aa23      	add	r2, sp, #140	; 0x8c
  406b3e:	4631      	mov	r1, r6
  406b40:	4620      	mov	r0, r4
  406b42:	f7fe fb47 	bl	4051d4 <__sprint_r>
  406b46:	2800      	cmp	r0, #0
  406b48:	f47f abb1 	bne.w	4062ae <_vfprintf_r+0x25e>
  406b4c:	f1a9 0910 	sub.w	r9, r9, #16
  406b50:	f1b9 0f10 	cmp.w	r9, #16
  406b54:	9925      	ldr	r1, [sp, #148]	; 0x94
  406b56:	9b24      	ldr	r3, [sp, #144]	; 0x90
  406b58:	aa30      	add	r2, sp, #192	; 0xc0
  406b5a:	dce6      	bgt.n	406b2a <_vfprintf_r+0xada>
  406b5c:	463e      	mov	r6, r7
  406b5e:	460c      	mov	r4, r1
  406b60:	464f      	mov	r7, r9
  406b62:	4691      	mov	r9, r2
  406b64:	3301      	adds	r3, #1
  406b66:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  406b68:	9324      	str	r3, [sp, #144]	; 0x90
  406b6a:	443c      	add	r4, r7
  406b6c:	2b07      	cmp	r3, #7
  406b6e:	9425      	str	r4, [sp, #148]	; 0x94
  406b70:	e889 0084 	stmia.w	r9, {r2, r7}
  406b74:	f300 822c 	bgt.w	406fd0 <_vfprintf_r+0xf80>
  406b78:	f109 0908 	add.w	r9, r9, #8
  406b7c:	e4f5      	b.n	40656a <_vfprintf_r+0x51a>
  406b7e:	bf00      	nop
  406b80:	7fefffff 	.word	0x7fefffff
  406b84:	0040ae3c 	.word	0x0040ae3c
  406b88:	0040ae38 	.word	0x0040ae38
  406b8c:	0040adfc 	.word	0x0040adfc
  406b90:	0040ae48 	.word	0x0040ae48
  406b94:	0040ae28 	.word	0x0040ae28
  406b98:	9b12      	ldr	r3, [sp, #72]	; 0x48
  406b9a:	9d24      	ldr	r5, [sp, #144]	; 0x90
  406b9c:	2b01      	cmp	r3, #1
  406b9e:	f340 81d0 	ble.w	406f42 <_vfprintf_r+0xef2>
  406ba2:	3501      	adds	r5, #1
  406ba4:	3401      	adds	r4, #1
  406ba6:	2301      	movs	r3, #1
  406ba8:	2d07      	cmp	r5, #7
  406baa:	9425      	str	r4, [sp, #148]	; 0x94
  406bac:	9524      	str	r5, [sp, #144]	; 0x90
  406bae:	f8c9 6000 	str.w	r6, [r9]
  406bb2:	f8c9 3004 	str.w	r3, [r9, #4]
  406bb6:	f300 81e1 	bgt.w	406f7c <_vfprintf_r+0xf2c>
  406bba:	f109 0908 	add.w	r9, r9, #8
  406bbe:	9a16      	ldr	r2, [sp, #88]	; 0x58
  406bc0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
  406bc2:	f8c9 3000 	str.w	r3, [r9]
  406bc6:	3501      	adds	r5, #1
  406bc8:	4414      	add	r4, r2
  406bca:	2d07      	cmp	r5, #7
  406bcc:	9425      	str	r4, [sp, #148]	; 0x94
  406bce:	9524      	str	r5, [sp, #144]	; 0x90
  406bd0:	f8c9 2004 	str.w	r2, [r9, #4]
  406bd4:	f300 81ed 	bgt.w	406fb2 <_vfprintf_r+0xf62>
  406bd8:	f109 0908 	add.w	r9, r9, #8
  406bdc:	2300      	movs	r3, #0
  406bde:	9814      	ldr	r0, [sp, #80]	; 0x50
  406be0:	9915      	ldr	r1, [sp, #84]	; 0x54
  406be2:	2200      	movs	r2, #0
  406be4:	f7fe f806 	bl	404bf4 <__aeabi_dcmpeq>
  406be8:	9b12      	ldr	r3, [sp, #72]	; 0x48
  406bea:	2800      	cmp	r0, #0
  406bec:	f040 80c3 	bne.w	406d76 <_vfprintf_r+0xd26>
  406bf0:	3b01      	subs	r3, #1
  406bf2:	3501      	adds	r5, #1
  406bf4:	3601      	adds	r6, #1
  406bf6:	441c      	add	r4, r3
  406bf8:	2d07      	cmp	r5, #7
  406bfa:	9524      	str	r5, [sp, #144]	; 0x90
  406bfc:	9425      	str	r4, [sp, #148]	; 0x94
  406bfe:	f8c9 6000 	str.w	r6, [r9]
  406c02:	f8c9 3004 	str.w	r3, [r9, #4]
  406c06:	f300 81ac 	bgt.w	406f62 <_vfprintf_r+0xf12>
  406c0a:	f109 0908 	add.w	r9, r9, #8
  406c0e:	9a19      	ldr	r2, [sp, #100]	; 0x64
  406c10:	f8c9 2004 	str.w	r2, [r9, #4]
  406c14:	3501      	adds	r5, #1
  406c16:	4414      	add	r4, r2
  406c18:	ab1f      	add	r3, sp, #124	; 0x7c
  406c1a:	2d07      	cmp	r5, #7
  406c1c:	9425      	str	r4, [sp, #148]	; 0x94
  406c1e:	9524      	str	r5, [sp, #144]	; 0x90
  406c20:	f8c9 3000 	str.w	r3, [r9]
  406c24:	f77f aceb 	ble.w	4065fe <_vfprintf_r+0x5ae>
  406c28:	aa23      	add	r2, sp, #140	; 0x8c
  406c2a:	9908      	ldr	r1, [sp, #32]
  406c2c:	980a      	ldr	r0, [sp, #40]	; 0x28
  406c2e:	f7fe fad1 	bl	4051d4 <__sprint_r>
  406c32:	2800      	cmp	r0, #0
  406c34:	f47f ab3b 	bne.w	4062ae <_vfprintf_r+0x25e>
  406c38:	9c25      	ldr	r4, [sp, #148]	; 0x94
  406c3a:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  406c3e:	e4e0      	b.n	406602 <_vfprintf_r+0x5b2>
  406c40:	aa23      	add	r2, sp, #140	; 0x8c
  406c42:	9908      	ldr	r1, [sp, #32]
  406c44:	980a      	ldr	r0, [sp, #40]	; 0x28
  406c46:	f7fe fac5 	bl	4051d4 <__sprint_r>
  406c4a:	2800      	cmp	r0, #0
  406c4c:	f43f ad27 	beq.w	40669e <_vfprintf_r+0x64e>
  406c50:	f7ff bb2d 	b.w	4062ae <_vfprintf_r+0x25e>
  406c54:	aa23      	add	r2, sp, #140	; 0x8c
  406c56:	9908      	ldr	r1, [sp, #32]
  406c58:	980a      	ldr	r0, [sp, #40]	; 0x28
  406c5a:	f7fe fabb 	bl	4051d4 <__sprint_r>
  406c5e:	2800      	cmp	r0, #0
  406c60:	f47f ab25 	bne.w	4062ae <_vfprintf_r+0x25e>
  406c64:	9c25      	ldr	r4, [sp, #148]	; 0x94
  406c66:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  406c6a:	e4b7      	b.n	4065dc <_vfprintf_r+0x58c>
  406c6c:	aa23      	add	r2, sp, #140	; 0x8c
  406c6e:	9908      	ldr	r1, [sp, #32]
  406c70:	980a      	ldr	r0, [sp, #40]	; 0x28
  406c72:	f7fe faaf 	bl	4051d4 <__sprint_r>
  406c76:	2800      	cmp	r0, #0
  406c78:	f47f ab19 	bne.w	4062ae <_vfprintf_r+0x25e>
  406c7c:	9c25      	ldr	r4, [sp, #148]	; 0x94
  406c7e:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  406c82:	e45e      	b.n	406542 <_vfprintf_r+0x4f2>
  406c84:	aa23      	add	r2, sp, #140	; 0x8c
  406c86:	9908      	ldr	r1, [sp, #32]
  406c88:	980a      	ldr	r0, [sp, #40]	; 0x28
  406c8a:	f7fe faa3 	bl	4051d4 <__sprint_r>
  406c8e:	2800      	cmp	r0, #0
  406c90:	f47f ab0d 	bne.w	4062ae <_vfprintf_r+0x25e>
  406c94:	9c25      	ldr	r4, [sp, #148]	; 0x94
  406c96:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  406c9a:	e462      	b.n	406562 <_vfprintf_r+0x512>
  406c9c:	f1bb 0f00 	cmp.w	fp, #0
  406ca0:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
  406ca4:	f2c0 82a0 	blt.w	4071e8 <_vfprintf_r+0x1198>
  406ca8:	f022 0380 	bic.w	r3, r2, #128	; 0x80
  406cac:	9307      	str	r3, [sp, #28]
  406cae:	ea54 0305 	orrs.w	r3, r4, r5
  406cb2:	f47f ad2a 	bne.w	40670a <_vfprintf_r+0x6ba>
  406cb6:	f1bb 0f00 	cmp.w	fp, #0
  406cba:	f43f ae8c 	beq.w	4069d6 <_vfprintf_r+0x986>
  406cbe:	2700      	movs	r7, #0
  406cc0:	e6b2      	b.n	406a28 <_vfprintf_r+0x9d8>
  406cc2:	9d1d      	ldr	r5, [sp, #116]	; 0x74
  406cc4:	2d00      	cmp	r5, #0
  406cc6:	f340 8291 	ble.w	4071ec <_vfprintf_r+0x119c>
  406cca:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  406ccc:	9a12      	ldr	r2, [sp, #72]	; 0x48
  406cce:	4293      	cmp	r3, r2
  406cd0:	bfa8      	it	ge
  406cd2:	4613      	movge	r3, r2
  406cd4:	2b00      	cmp	r3, #0
  406cd6:	461d      	mov	r5, r3
  406cd8:	dd0d      	ble.n	406cf6 <_vfprintf_r+0xca6>
  406cda:	9b24      	ldr	r3, [sp, #144]	; 0x90
  406cdc:	f8c9 6000 	str.w	r6, [r9]
  406ce0:	3301      	adds	r3, #1
  406ce2:	442c      	add	r4, r5
  406ce4:	2b07      	cmp	r3, #7
  406ce6:	9425      	str	r4, [sp, #148]	; 0x94
  406ce8:	f8c9 5004 	str.w	r5, [r9, #4]
  406cec:	9324      	str	r3, [sp, #144]	; 0x90
  406cee:	f300 837e 	bgt.w	4073ee <_vfprintf_r+0x139e>
  406cf2:	f109 0908 	add.w	r9, r9, #8
  406cf6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  406cf8:	2d00      	cmp	r5, #0
  406cfa:	bfa8      	it	ge
  406cfc:	1b5b      	subge	r3, r3, r5
  406cfe:	2b00      	cmp	r3, #0
  406d00:	461d      	mov	r5, r3
  406d02:	f340 80be 	ble.w	406e82 <_vfprintf_r+0xe32>
  406d06:	4ab9      	ldr	r2, [pc, #740]	; (406fec <_vfprintf_r+0xf9c>)
  406d08:	9b24      	ldr	r3, [sp, #144]	; 0x90
  406d0a:	920f      	str	r2, [sp, #60]	; 0x3c
  406d0c:	2d10      	cmp	r5, #16
  406d0e:	f340 8246 	ble.w	40719e <_vfprintf_r+0x114e>
  406d12:	4622      	mov	r2, r4
  406d14:	2710      	movs	r7, #16
  406d16:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
  406d1a:	9c08      	ldr	r4, [sp, #32]
  406d1c:	e005      	b.n	406d2a <_vfprintf_r+0xcda>
  406d1e:	f109 0908 	add.w	r9, r9, #8
  406d22:	3d10      	subs	r5, #16
  406d24:	2d10      	cmp	r5, #16
  406d26:	f340 8239 	ble.w	40719c <_vfprintf_r+0x114c>
  406d2a:	3301      	adds	r3, #1
  406d2c:	3210      	adds	r2, #16
  406d2e:	2b07      	cmp	r3, #7
  406d30:	9225      	str	r2, [sp, #148]	; 0x94
  406d32:	9324      	str	r3, [sp, #144]	; 0x90
  406d34:	f8c9 a000 	str.w	sl, [r9]
  406d38:	f8c9 7004 	str.w	r7, [r9, #4]
  406d3c:	ddef      	ble.n	406d1e <_vfprintf_r+0xcce>
  406d3e:	aa23      	add	r2, sp, #140	; 0x8c
  406d40:	4621      	mov	r1, r4
  406d42:	4658      	mov	r0, fp
  406d44:	f7fe fa46 	bl	4051d4 <__sprint_r>
  406d48:	2800      	cmp	r0, #0
  406d4a:	f47f aab0 	bne.w	4062ae <_vfprintf_r+0x25e>
  406d4e:	9a25      	ldr	r2, [sp, #148]	; 0x94
  406d50:	9b24      	ldr	r3, [sp, #144]	; 0x90
  406d52:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  406d56:	e7e4      	b.n	406d22 <_vfprintf_r+0xcd2>
  406d58:	aa23      	add	r2, sp, #140	; 0x8c
  406d5a:	9908      	ldr	r1, [sp, #32]
  406d5c:	980a      	ldr	r0, [sp, #40]	; 0x28
  406d5e:	f7fe fa39 	bl	4051d4 <__sprint_r>
  406d62:	2800      	cmp	r0, #0
  406d64:	f47f aaa3 	bne.w	4062ae <_vfprintf_r+0x25e>
  406d68:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
  406d6c:	9c25      	ldr	r4, [sp, #148]	; 0x94
  406d6e:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  406d72:	f7ff bbd6 	b.w	406522 <_vfprintf_r+0x4d2>
  406d76:	1e5e      	subs	r6, r3, #1
  406d78:	2e00      	cmp	r6, #0
  406d7a:	f77f af48 	ble.w	406c0e <_vfprintf_r+0xbbe>
  406d7e:	4b9b      	ldr	r3, [pc, #620]	; (406fec <_vfprintf_r+0xf9c>)
  406d80:	930f      	str	r3, [sp, #60]	; 0x3c
  406d82:	2e10      	cmp	r6, #16
  406d84:	f340 810a 	ble.w	406f9c <_vfprintf_r+0xf4c>
  406d88:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
  406d8c:	2710      	movs	r7, #16
  406d8e:	46b0      	mov	r8, r6
  406d90:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
  406d94:	9e08      	ldr	r6, [sp, #32]
  406d96:	e007      	b.n	406da8 <_vfprintf_r+0xd58>
  406d98:	f109 0908 	add.w	r9, r9, #8
  406d9c:	f1a8 0810 	sub.w	r8, r8, #16
  406da0:	f1b8 0f10 	cmp.w	r8, #16
  406da4:	f340 80f7 	ble.w	406f96 <_vfprintf_r+0xf46>
  406da8:	3501      	adds	r5, #1
  406daa:	3410      	adds	r4, #16
  406dac:	2d07      	cmp	r5, #7
  406dae:	9425      	str	r4, [sp, #148]	; 0x94
  406db0:	9524      	str	r5, [sp, #144]	; 0x90
  406db2:	f8c9 a000 	str.w	sl, [r9]
  406db6:	f8c9 7004 	str.w	r7, [r9, #4]
  406dba:	dded      	ble.n	406d98 <_vfprintf_r+0xd48>
  406dbc:	aa23      	add	r2, sp, #140	; 0x8c
  406dbe:	4631      	mov	r1, r6
  406dc0:	4658      	mov	r0, fp
  406dc2:	f7fe fa07 	bl	4051d4 <__sprint_r>
  406dc6:	2800      	cmp	r0, #0
  406dc8:	f47f aa71 	bne.w	4062ae <_vfprintf_r+0x25e>
  406dcc:	9c25      	ldr	r4, [sp, #148]	; 0x94
  406dce:	9d24      	ldr	r5, [sp, #144]	; 0x90
  406dd0:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  406dd4:	e7e2      	b.n	406d9c <_vfprintf_r+0xd4c>
  406dd6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  406dd8:	6814      	ldr	r4, [r2, #0]
  406dda:	4613      	mov	r3, r2
  406ddc:	3304      	adds	r3, #4
  406dde:	17e5      	asrs	r5, r4, #31
  406de0:	930e      	str	r3, [sp, #56]	; 0x38
  406de2:	4622      	mov	r2, r4
  406de4:	462b      	mov	r3, r5
  406de6:	e4c6      	b.n	406776 <_vfprintf_r+0x726>
  406de8:	9907      	ldr	r1, [sp, #28]
  406dea:	f011 0210 	ands.w	r2, r1, #16
  406dee:	d015      	beq.n	406e1c <_vfprintf_r+0xdcc>
  406df0:	980e      	ldr	r0, [sp, #56]	; 0x38
  406df2:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
  406df6:	f1bb 0f00 	cmp.w	fp, #0
  406dfa:	6804      	ldr	r4, [r0, #0]
  406dfc:	f100 0704 	add.w	r7, r0, #4
  406e00:	f04f 0500 	mov.w	r5, #0
  406e04:	db1b      	blt.n	406e3e <_vfprintf_r+0xdee>
  406e06:	460a      	mov	r2, r1
  406e08:	f022 0280 	bic.w	r2, r2, #128	; 0x80
  406e0c:	9207      	str	r2, [sp, #28]
  406e0e:	ea54 0205 	orrs.w	r2, r4, r5
  406e12:	970e      	str	r7, [sp, #56]	; 0x38
  406e14:	461f      	mov	r7, r3
  406e16:	f47f ab05 	bne.w	406424 <_vfprintf_r+0x3d4>
  406e1a:	e4bf      	b.n	40679c <_vfprintf_r+0x74c>
  406e1c:	9907      	ldr	r1, [sp, #28]
  406e1e:	f011 0340 	ands.w	r3, r1, #64	; 0x40
  406e22:	f040 8251 	bne.w	4072c8 <_vfprintf_r+0x1278>
  406e26:	990e      	ldr	r1, [sp, #56]	; 0x38
  406e28:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
  406e2c:	f1bb 0f00 	cmp.w	fp, #0
  406e30:	680c      	ldr	r4, [r1, #0]
  406e32:	f101 0704 	add.w	r7, r1, #4
  406e36:	f04f 0500 	mov.w	r5, #0
  406e3a:	f280 819c 	bge.w	407176 <_vfprintf_r+0x1126>
  406e3e:	970e      	str	r7, [sp, #56]	; 0x38
  406e40:	461f      	mov	r7, r3
  406e42:	ea54 0305 	orrs.w	r3, r4, r5
  406e46:	f47f aaed 	bne.w	406424 <_vfprintf_r+0x3d4>
  406e4a:	ae40      	add	r6, sp, #256	; 0x100
  406e4c:	3430      	adds	r4, #48	; 0x30
  406e4e:	f806 4d41 	strb.w	r4, [r6, #-65]!
  406e52:	f7ff bb01 	b.w	406458 <_vfprintf_r+0x408>
  406e56:	3301      	adds	r3, #1
  406e58:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  406e5a:	9324      	str	r3, [sp, #144]	; 0x90
  406e5c:	442c      	add	r4, r5
  406e5e:	2b07      	cmp	r3, #7
  406e60:	9425      	str	r4, [sp, #148]	; 0x94
  406e62:	e889 0024 	stmia.w	r9, {r2, r5}
  406e66:	f77f abca 	ble.w	4065fe <_vfprintf_r+0x5ae>
  406e6a:	e6dd      	b.n	406c28 <_vfprintf_r+0xbd8>
  406e6c:	aa23      	add	r2, sp, #140	; 0x8c
  406e6e:	9908      	ldr	r1, [sp, #32]
  406e70:	980a      	ldr	r0, [sp, #40]	; 0x28
  406e72:	f7fe f9af 	bl	4051d4 <__sprint_r>
  406e76:	2800      	cmp	r0, #0
  406e78:	f47f aa19 	bne.w	4062ae <_vfprintf_r+0x25e>
  406e7c:	9c25      	ldr	r4, [sp, #148]	; 0x94
  406e7e:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  406e82:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  406e84:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  406e86:	4432      	add	r2, r6
  406e88:	4617      	mov	r7, r2
  406e8a:	9a12      	ldr	r2, [sp, #72]	; 0x48
  406e8c:	4293      	cmp	r3, r2
  406e8e:	db47      	blt.n	406f20 <_vfprintf_r+0xed0>
  406e90:	9a07      	ldr	r2, [sp, #28]
  406e92:	07d2      	lsls	r2, r2, #31
  406e94:	d444      	bmi.n	406f20 <_vfprintf_r+0xed0>
  406e96:	9912      	ldr	r1, [sp, #72]	; 0x48
  406e98:	440e      	add	r6, r1
  406e9a:	1bf5      	subs	r5, r6, r7
  406e9c:	1acb      	subs	r3, r1, r3
  406e9e:	429d      	cmp	r5, r3
  406ea0:	bfa8      	it	ge
  406ea2:	461d      	movge	r5, r3
  406ea4:	2d00      	cmp	r5, #0
  406ea6:	462e      	mov	r6, r5
  406ea8:	dd0d      	ble.n	406ec6 <_vfprintf_r+0xe76>
  406eaa:	9a24      	ldr	r2, [sp, #144]	; 0x90
  406eac:	f8c9 7000 	str.w	r7, [r9]
  406eb0:	3201      	adds	r2, #1
  406eb2:	442c      	add	r4, r5
  406eb4:	2a07      	cmp	r2, #7
  406eb6:	9425      	str	r4, [sp, #148]	; 0x94
  406eb8:	f8c9 5004 	str.w	r5, [r9, #4]
  406ebc:	9224      	str	r2, [sp, #144]	; 0x90
  406ebe:	f300 8313 	bgt.w	4074e8 <_vfprintf_r+0x1498>
  406ec2:	f109 0908 	add.w	r9, r9, #8
  406ec6:	2e00      	cmp	r6, #0
  406ec8:	bfac      	ite	ge
  406eca:	1b9d      	subge	r5, r3, r6
  406ecc:	461d      	movlt	r5, r3
  406ece:	2d00      	cmp	r5, #0
  406ed0:	f77f ab97 	ble.w	406602 <_vfprintf_r+0x5b2>
  406ed4:	4a45      	ldr	r2, [pc, #276]	; (406fec <_vfprintf_r+0xf9c>)
  406ed6:	9b24      	ldr	r3, [sp, #144]	; 0x90
  406ed8:	920f      	str	r2, [sp, #60]	; 0x3c
  406eda:	2d10      	cmp	r5, #16
  406edc:	ddbb      	ble.n	406e56 <_vfprintf_r+0xe06>
  406ede:	2610      	movs	r6, #16
  406ee0:	9f0a      	ldr	r7, [sp, #40]	; 0x28
  406ee2:	f8dd b020 	ldr.w	fp, [sp, #32]
  406ee6:	e004      	b.n	406ef2 <_vfprintf_r+0xea2>
  406ee8:	f109 0908 	add.w	r9, r9, #8
  406eec:	3d10      	subs	r5, #16
  406eee:	2d10      	cmp	r5, #16
  406ef0:	ddb1      	ble.n	406e56 <_vfprintf_r+0xe06>
  406ef2:	3301      	adds	r3, #1
  406ef4:	3410      	adds	r4, #16
  406ef6:	2b07      	cmp	r3, #7
  406ef8:	9425      	str	r4, [sp, #148]	; 0x94
  406efa:	9324      	str	r3, [sp, #144]	; 0x90
  406efc:	f8c9 a000 	str.w	sl, [r9]
  406f00:	f8c9 6004 	str.w	r6, [r9, #4]
  406f04:	ddf0      	ble.n	406ee8 <_vfprintf_r+0xe98>
  406f06:	aa23      	add	r2, sp, #140	; 0x8c
  406f08:	4659      	mov	r1, fp
  406f0a:	4638      	mov	r0, r7
  406f0c:	f7fe f962 	bl	4051d4 <__sprint_r>
  406f10:	2800      	cmp	r0, #0
  406f12:	f47f a9cc 	bne.w	4062ae <_vfprintf_r+0x25e>
  406f16:	9c25      	ldr	r4, [sp, #148]	; 0x94
  406f18:	9b24      	ldr	r3, [sp, #144]	; 0x90
  406f1a:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  406f1e:	e7e5      	b.n	406eec <_vfprintf_r+0xe9c>
  406f20:	9a24      	ldr	r2, [sp, #144]	; 0x90
  406f22:	9816      	ldr	r0, [sp, #88]	; 0x58
  406f24:	9917      	ldr	r1, [sp, #92]	; 0x5c
  406f26:	f8c9 1000 	str.w	r1, [r9]
  406f2a:	3201      	adds	r2, #1
  406f2c:	4404      	add	r4, r0
  406f2e:	2a07      	cmp	r2, #7
  406f30:	9425      	str	r4, [sp, #148]	; 0x94
  406f32:	f8c9 0004 	str.w	r0, [r9, #4]
  406f36:	9224      	str	r2, [sp, #144]	; 0x90
  406f38:	f300 8272 	bgt.w	407420 <_vfprintf_r+0x13d0>
  406f3c:	f109 0908 	add.w	r9, r9, #8
  406f40:	e7a9      	b.n	406e96 <_vfprintf_r+0xe46>
  406f42:	9b07      	ldr	r3, [sp, #28]
  406f44:	07df      	lsls	r7, r3, #31
  406f46:	f53f ae2c 	bmi.w	406ba2 <_vfprintf_r+0xb52>
  406f4a:	3501      	adds	r5, #1
  406f4c:	3401      	adds	r4, #1
  406f4e:	2301      	movs	r3, #1
  406f50:	2d07      	cmp	r5, #7
  406f52:	9425      	str	r4, [sp, #148]	; 0x94
  406f54:	9524      	str	r5, [sp, #144]	; 0x90
  406f56:	f8c9 6000 	str.w	r6, [r9]
  406f5a:	f8c9 3004 	str.w	r3, [r9, #4]
  406f5e:	f77f ae54 	ble.w	406c0a <_vfprintf_r+0xbba>
  406f62:	aa23      	add	r2, sp, #140	; 0x8c
  406f64:	9908      	ldr	r1, [sp, #32]
  406f66:	980a      	ldr	r0, [sp, #40]	; 0x28
  406f68:	f7fe f934 	bl	4051d4 <__sprint_r>
  406f6c:	2800      	cmp	r0, #0
  406f6e:	f47f a99e 	bne.w	4062ae <_vfprintf_r+0x25e>
  406f72:	9c25      	ldr	r4, [sp, #148]	; 0x94
  406f74:	9d24      	ldr	r5, [sp, #144]	; 0x90
  406f76:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  406f7a:	e648      	b.n	406c0e <_vfprintf_r+0xbbe>
  406f7c:	aa23      	add	r2, sp, #140	; 0x8c
  406f7e:	9908      	ldr	r1, [sp, #32]
  406f80:	980a      	ldr	r0, [sp, #40]	; 0x28
  406f82:	f7fe f927 	bl	4051d4 <__sprint_r>
  406f86:	2800      	cmp	r0, #0
  406f88:	f47f a991 	bne.w	4062ae <_vfprintf_r+0x25e>
  406f8c:	9c25      	ldr	r4, [sp, #148]	; 0x94
  406f8e:	9d24      	ldr	r5, [sp, #144]	; 0x90
  406f90:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  406f94:	e613      	b.n	406bbe <_vfprintf_r+0xb6e>
  406f96:	4646      	mov	r6, r8
  406f98:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
  406f9c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  406f9e:	3501      	adds	r5, #1
  406fa0:	4434      	add	r4, r6
  406fa2:	2d07      	cmp	r5, #7
  406fa4:	9425      	str	r4, [sp, #148]	; 0x94
  406fa6:	9524      	str	r5, [sp, #144]	; 0x90
  406fa8:	e889 0048 	stmia.w	r9, {r3, r6}
  406fac:	f77f ae2d 	ble.w	406c0a <_vfprintf_r+0xbba>
  406fb0:	e7d7      	b.n	406f62 <_vfprintf_r+0xf12>
  406fb2:	aa23      	add	r2, sp, #140	; 0x8c
  406fb4:	9908      	ldr	r1, [sp, #32]
  406fb6:	980a      	ldr	r0, [sp, #40]	; 0x28
  406fb8:	f7fe f90c 	bl	4051d4 <__sprint_r>
  406fbc:	2800      	cmp	r0, #0
  406fbe:	f47f a976 	bne.w	4062ae <_vfprintf_r+0x25e>
  406fc2:	9c25      	ldr	r4, [sp, #148]	; 0x94
  406fc4:	9d24      	ldr	r5, [sp, #144]	; 0x90
  406fc6:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  406fca:	e607      	b.n	406bdc <_vfprintf_r+0xb8c>
  406fcc:	2400      	movs	r4, #0
  406fce:	e73c      	b.n	406e4a <_vfprintf_r+0xdfa>
  406fd0:	aa23      	add	r2, sp, #140	; 0x8c
  406fd2:	9908      	ldr	r1, [sp, #32]
  406fd4:	980a      	ldr	r0, [sp, #40]	; 0x28
  406fd6:	f7fe f8fd 	bl	4051d4 <__sprint_r>
  406fda:	2800      	cmp	r0, #0
  406fdc:	f47f a967 	bne.w	4062ae <_vfprintf_r+0x25e>
  406fe0:	9c25      	ldr	r4, [sp, #148]	; 0x94
  406fe2:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  406fe6:	f7ff bac0 	b.w	40656a <_vfprintf_r+0x51a>
  406fea:	bf00      	nop
  406fec:	0040ae28 	.word	0x0040ae28
  406ff0:	4264      	negs	r4, r4
  406ff2:	f04f 072d 	mov.w	r7, #45	; 0x2d
  406ff6:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
  406ffa:	f1bb 0f00 	cmp.w	fp, #0
  406ffe:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
  407002:	f6ff aa0f 	blt.w	406424 <_vfprintf_r+0x3d4>
  407006:	9b07      	ldr	r3, [sp, #28]
  407008:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  40700c:	9307      	str	r3, [sp, #28]
  40700e:	f7ff ba09 	b.w	406424 <_vfprintf_r+0x3d4>
  407012:	9b07      	ldr	r3, [sp, #28]
  407014:	06de      	lsls	r6, r3, #27
  407016:	d40b      	bmi.n	407030 <_vfprintf_r+0xfe0>
  407018:	9b07      	ldr	r3, [sp, #28]
  40701a:	065d      	lsls	r5, r3, #25
  40701c:	d508      	bpl.n	407030 <_vfprintf_r+0xfe0>
  40701e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  407020:	6813      	ldr	r3, [r2, #0]
  407022:	3204      	adds	r2, #4
  407024:	920e      	str	r2, [sp, #56]	; 0x38
  407026:	f8bd 202c 	ldrh.w	r2, [sp, #44]	; 0x2c
  40702a:	801a      	strh	r2, [r3, #0]
  40702c:	f7ff b850 	b.w	4060d0 <_vfprintf_r+0x80>
  407030:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  407032:	6813      	ldr	r3, [r2, #0]
  407034:	3204      	adds	r2, #4
  407036:	920e      	str	r2, [sp, #56]	; 0x38
  407038:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  40703a:	601a      	str	r2, [r3, #0]
  40703c:	f7ff b848 	b.w	4060d0 <_vfprintf_r+0x80>
  407040:	9c14      	ldr	r4, [sp, #80]	; 0x50
  407042:	4622      	mov	r2, r4
  407044:	4620      	mov	r0, r4
  407046:	9c15      	ldr	r4, [sp, #84]	; 0x54
  407048:	4623      	mov	r3, r4
  40704a:	4621      	mov	r1, r4
  40704c:	f003 fbe2 	bl	40a814 <__aeabi_dcmpun>
  407050:	2800      	cmp	r0, #0
  407052:	f040 830b 	bne.w	40766c <_vfprintf_r+0x161c>
  407056:	9b11      	ldr	r3, [sp, #68]	; 0x44
  407058:	f1bb 3fff 	cmp.w	fp, #4294967295
  40705c:	f023 0320 	bic.w	r3, r3, #32
  407060:	930d      	str	r3, [sp, #52]	; 0x34
  407062:	f000 825f 	beq.w	407524 <_vfprintf_r+0x14d4>
  407066:	2b47      	cmp	r3, #71	; 0x47
  407068:	f000 8170 	beq.w	40734c <_vfprintf_r+0x12fc>
  40706c:	9b07      	ldr	r3, [sp, #28]
  40706e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  407072:	9310      	str	r3, [sp, #64]	; 0x40
  407074:	9b15      	ldr	r3, [sp, #84]	; 0x54
  407076:	1e1f      	subs	r7, r3, #0
  407078:	9b14      	ldr	r3, [sp, #80]	; 0x50
  40707a:	9309      	str	r3, [sp, #36]	; 0x24
  40707c:	bfbb      	ittet	lt
  40707e:	463b      	movlt	r3, r7
  407080:	f103 4700 	addlt.w	r7, r3, #2147483648	; 0x80000000
  407084:	2300      	movge	r3, #0
  407086:	232d      	movlt	r3, #45	; 0x2d
  407088:	930f      	str	r3, [sp, #60]	; 0x3c
  40708a:	9b11      	ldr	r3, [sp, #68]	; 0x44
  40708c:	2b66      	cmp	r3, #102	; 0x66
  40708e:	f000 824f 	beq.w	407530 <_vfprintf_r+0x14e0>
  407092:	2b46      	cmp	r3, #70	; 0x46
  407094:	f000 812f 	beq.w	4072f6 <_vfprintf_r+0x12a6>
  407098:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  40709a:	9a09      	ldr	r2, [sp, #36]	; 0x24
  40709c:	2b45      	cmp	r3, #69	; 0x45
  40709e:	a821      	add	r0, sp, #132	; 0x84
  4070a0:	a91e      	add	r1, sp, #120	; 0x78
  4070a2:	bf0c      	ite	eq
  4070a4:	f10b 0501 	addeq.w	r5, fp, #1
  4070a8:	465d      	movne	r5, fp
  4070aa:	9004      	str	r0, [sp, #16]
  4070ac:	9103      	str	r1, [sp, #12]
  4070ae:	a81d      	add	r0, sp, #116	; 0x74
  4070b0:	2102      	movs	r1, #2
  4070b2:	463b      	mov	r3, r7
  4070b4:	9002      	str	r0, [sp, #8]
  4070b6:	9501      	str	r5, [sp, #4]
  4070b8:	9100      	str	r1, [sp, #0]
  4070ba:	980a      	ldr	r0, [sp, #40]	; 0x28
  4070bc:	f000 fc84 	bl	4079c8 <_dtoa_r>
  4070c0:	9b11      	ldr	r3, [sp, #68]	; 0x44
  4070c2:	2b67      	cmp	r3, #103	; 0x67
  4070c4:	4606      	mov	r6, r0
  4070c6:	f040 8281 	bne.w	4075cc <_vfprintf_r+0x157c>
  4070ca:	9b07      	ldr	r3, [sp, #28]
  4070cc:	07da      	lsls	r2, r3, #31
  4070ce:	f140 82a8 	bpl.w	407622 <_vfprintf_r+0x15d2>
  4070d2:	1974      	adds	r4, r6, r5
  4070d4:	9809      	ldr	r0, [sp, #36]	; 0x24
  4070d6:	4639      	mov	r1, r7
  4070d8:	2200      	movs	r2, #0
  4070da:	2300      	movs	r3, #0
  4070dc:	f7fd fd8a 	bl	404bf4 <__aeabi_dcmpeq>
  4070e0:	2800      	cmp	r0, #0
  4070e2:	f040 8182 	bne.w	4073ea <_vfprintf_r+0x139a>
  4070e6:	9b21      	ldr	r3, [sp, #132]	; 0x84
  4070e8:	429c      	cmp	r4, r3
  4070ea:	d906      	bls.n	4070fa <_vfprintf_r+0x10aa>
  4070ec:	2130      	movs	r1, #48	; 0x30
  4070ee:	1c5a      	adds	r2, r3, #1
  4070f0:	9221      	str	r2, [sp, #132]	; 0x84
  4070f2:	7019      	strb	r1, [r3, #0]
  4070f4:	9b21      	ldr	r3, [sp, #132]	; 0x84
  4070f6:	429c      	cmp	r4, r3
  4070f8:	d8f9      	bhi.n	4070ee <_vfprintf_r+0x109e>
  4070fa:	1b9b      	subs	r3, r3, r6
  4070fc:	9312      	str	r3, [sp, #72]	; 0x48
  4070fe:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  407100:	2b47      	cmp	r3, #71	; 0x47
  407102:	f000 816b 	beq.w	4073dc <_vfprintf_r+0x138c>
  407106:	9b11      	ldr	r3, [sp, #68]	; 0x44
  407108:	2b65      	cmp	r3, #101	; 0x65
  40710a:	f340 826e 	ble.w	4075ea <_vfprintf_r+0x159a>
  40710e:	9b11      	ldr	r3, [sp, #68]	; 0x44
  407110:	2b66      	cmp	r3, #102	; 0x66
  407112:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  407114:	9313      	str	r3, [sp, #76]	; 0x4c
  407116:	f000 8231 	beq.w	40757c <_vfprintf_r+0x152c>
  40711a:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  40711c:	9912      	ldr	r1, [sp, #72]	; 0x48
  40711e:	428a      	cmp	r2, r1
  407120:	f2c0 821f 	blt.w	407562 <_vfprintf_r+0x1512>
  407124:	9b07      	ldr	r3, [sp, #28]
  407126:	07db      	lsls	r3, r3, #31
  407128:	f100 827d 	bmi.w	407626 <_vfprintf_r+0x15d6>
  40712c:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
  407130:	920d      	str	r2, [sp, #52]	; 0x34
  407132:	2267      	movs	r2, #103	; 0x67
  407134:	9211      	str	r2, [sp, #68]	; 0x44
  407136:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  407138:	2a00      	cmp	r2, #0
  40713a:	f040 8145 	bne.w	4073c8 <_vfprintf_r+0x1378>
  40713e:	9309      	str	r3, [sp, #36]	; 0x24
  407140:	9b10      	ldr	r3, [sp, #64]	; 0x40
  407142:	9307      	str	r3, [sp, #28]
  407144:	4693      	mov	fp, r2
  407146:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
  40714a:	f7ff b98f 	b.w	40646c <_vfprintf_r+0x41c>
  40714e:	9907      	ldr	r1, [sp, #28]
  407150:	f011 0340 	ands.w	r3, r1, #64	; 0x40
  407154:	f040 80a1 	bne.w	40729a <_vfprintf_r+0x124a>
  407158:	990e      	ldr	r1, [sp, #56]	; 0x38
  40715a:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
  40715e:	f1bb 0f00 	cmp.w	fp, #0
  407162:	680c      	ldr	r4, [r1, #0]
  407164:	f101 0704 	add.w	r7, r1, #4
  407168:	f04f 0500 	mov.w	r5, #0
  40716c:	da13      	bge.n	407196 <_vfprintf_r+0x1146>
  40716e:	970e      	str	r7, [sp, #56]	; 0x38
  407170:	2700      	movs	r7, #0
  407172:	f7ff b8c8 	b.w	406306 <_vfprintf_r+0x2b6>
  407176:	9a07      	ldr	r2, [sp, #28]
  407178:	e646      	b.n	406e08 <_vfprintf_r+0xdb8>
  40717a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  40717c:	9b07      	ldr	r3, [sp, #28]
  40717e:	f013 0f40 	tst.w	r3, #64	; 0x40
  407182:	4613      	mov	r3, r2
  407184:	f103 0304 	add.w	r3, r3, #4
  407188:	bf0c      	ite	eq
  40718a:	6814      	ldreq	r4, [r2, #0]
  40718c:	8814      	ldrhne	r4, [r2, #0]
  40718e:	930e      	str	r3, [sp, #56]	; 0x38
  407190:	2500      	movs	r5, #0
  407192:	f7ff ba9c 	b.w	4066ce <_vfprintf_r+0x67e>
  407196:	9a07      	ldr	r2, [sp, #28]
  407198:	f7ff b916 	b.w	4063c8 <_vfprintf_r+0x378>
  40719c:	4614      	mov	r4, r2
  40719e:	3301      	adds	r3, #1
  4071a0:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  4071a2:	9324      	str	r3, [sp, #144]	; 0x90
  4071a4:	442c      	add	r4, r5
  4071a6:	2b07      	cmp	r3, #7
  4071a8:	9425      	str	r4, [sp, #148]	; 0x94
  4071aa:	e889 0024 	stmia.w	r9, {r2, r5}
  4071ae:	f73f ae5d 	bgt.w	406e6c <_vfprintf_r+0xe1c>
  4071b2:	f109 0908 	add.w	r9, r9, #8
  4071b6:	e664      	b.n	406e82 <_vfprintf_r+0xe32>
  4071b8:	2700      	movs	r7, #0
  4071ba:	45bb      	cmp	fp, r7
  4071bc:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
  4071c0:	f6ff ac32 	blt.w	406a28 <_vfprintf_r+0x9d8>
  4071c4:	9b07      	ldr	r3, [sp, #28]
  4071c6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  4071ca:	9307      	str	r3, [sp, #28]
  4071cc:	f7ff bbff 	b.w	4069ce <_vfprintf_r+0x97e>
  4071d0:	aa23      	add	r2, sp, #140	; 0x8c
  4071d2:	9908      	ldr	r1, [sp, #32]
  4071d4:	980a      	ldr	r0, [sp, #40]	; 0x28
  4071d6:	f7fd fffd 	bl	4051d4 <__sprint_r>
  4071da:	2800      	cmp	r0, #0
  4071dc:	f47f a867 	bne.w	4062ae <_vfprintf_r+0x25e>
  4071e0:	9c25      	ldr	r4, [sp, #148]	; 0x94
  4071e2:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  4071e6:	e441      	b.n	406a6c <_vfprintf_r+0xa1c>
  4071e8:	9f0e      	ldr	r7, [sp, #56]	; 0x38
  4071ea:	e416      	b.n	406a1a <_vfprintf_r+0x9ca>
  4071ec:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4071ee:	4abb      	ldr	r2, [pc, #748]	; (4074dc <_vfprintf_r+0x148c>)
  4071f0:	f8c9 2000 	str.w	r2, [r9]
  4071f4:	3301      	adds	r3, #1
  4071f6:	3401      	adds	r4, #1
  4071f8:	2201      	movs	r2, #1
  4071fa:	2b07      	cmp	r3, #7
  4071fc:	9425      	str	r4, [sp, #148]	; 0x94
  4071fe:	9324      	str	r3, [sp, #144]	; 0x90
  407200:	f8c9 2004 	str.w	r2, [r9, #4]
  407204:	f300 8095 	bgt.w	407332 <_vfprintf_r+0x12e2>
  407208:	f109 0908 	add.w	r9, r9, #8
  40720c:	b92d      	cbnz	r5, 40721a <_vfprintf_r+0x11ca>
  40720e:	9b12      	ldr	r3, [sp, #72]	; 0x48
  407210:	b91b      	cbnz	r3, 40721a <_vfprintf_r+0x11ca>
  407212:	9b07      	ldr	r3, [sp, #28]
  407214:	07d9      	lsls	r1, r3, #31
  407216:	f57f a9f4 	bpl.w	406602 <_vfprintf_r+0x5b2>
  40721a:	9b24      	ldr	r3, [sp, #144]	; 0x90
  40721c:	9916      	ldr	r1, [sp, #88]	; 0x58
  40721e:	9a17      	ldr	r2, [sp, #92]	; 0x5c
  407220:	f8c9 2000 	str.w	r2, [r9]
  407224:	3301      	adds	r3, #1
  407226:	440c      	add	r4, r1
  407228:	2b07      	cmp	r3, #7
  40722a:	9425      	str	r4, [sp, #148]	; 0x94
  40722c:	f8c9 1004 	str.w	r1, [r9, #4]
  407230:	9324      	str	r3, [sp, #144]	; 0x90
  407232:	f300 81e0 	bgt.w	4075f6 <_vfprintf_r+0x15a6>
  407236:	f109 0908 	add.w	r9, r9, #8
  40723a:	426d      	negs	r5, r5
  40723c:	2d00      	cmp	r5, #0
  40723e:	f340 80ae 	ble.w	40739e <_vfprintf_r+0x134e>
  407242:	4aa7      	ldr	r2, [pc, #668]	; (4074e0 <_vfprintf_r+0x1490>)
  407244:	920f      	str	r2, [sp, #60]	; 0x3c
  407246:	2d10      	cmp	r5, #16
  407248:	f340 80de 	ble.w	407408 <_vfprintf_r+0x13b8>
  40724c:	4622      	mov	r2, r4
  40724e:	2710      	movs	r7, #16
  407250:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
  407254:	9c08      	ldr	r4, [sp, #32]
  407256:	e005      	b.n	407264 <_vfprintf_r+0x1214>
  407258:	f109 0908 	add.w	r9, r9, #8
  40725c:	3d10      	subs	r5, #16
  40725e:	2d10      	cmp	r5, #16
  407260:	f340 80d1 	ble.w	407406 <_vfprintf_r+0x13b6>
  407264:	3301      	adds	r3, #1
  407266:	3210      	adds	r2, #16
  407268:	2b07      	cmp	r3, #7
  40726a:	9225      	str	r2, [sp, #148]	; 0x94
  40726c:	9324      	str	r3, [sp, #144]	; 0x90
  40726e:	f8c9 a000 	str.w	sl, [r9]
  407272:	f8c9 7004 	str.w	r7, [r9, #4]
  407276:	ddef      	ble.n	407258 <_vfprintf_r+0x1208>
  407278:	aa23      	add	r2, sp, #140	; 0x8c
  40727a:	4621      	mov	r1, r4
  40727c:	4658      	mov	r0, fp
  40727e:	f7fd ffa9 	bl	4051d4 <__sprint_r>
  407282:	2800      	cmp	r0, #0
  407284:	f47f a813 	bne.w	4062ae <_vfprintf_r+0x25e>
  407288:	9a25      	ldr	r2, [sp, #148]	; 0x94
  40728a:	9b24      	ldr	r3, [sp, #144]	; 0x90
  40728c:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  407290:	e7e4      	b.n	40725c <_vfprintf_r+0x120c>
  407292:	f04f 30ff 	mov.w	r0, #4294967295
  407296:	f7ff b810 	b.w	4062ba <_vfprintf_r+0x26a>
  40729a:	980e      	ldr	r0, [sp, #56]	; 0x38
  40729c:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
  4072a0:	f1bb 0f00 	cmp.w	fp, #0
  4072a4:	8804      	ldrh	r4, [r0, #0]
  4072a6:	f100 0704 	add.w	r7, r0, #4
  4072aa:	f04f 0500 	mov.w	r5, #0
  4072ae:	f6ff af5e 	blt.w	40716e <_vfprintf_r+0x111e>
  4072b2:	f021 0380 	bic.w	r3, r1, #128	; 0x80
  4072b6:	9307      	str	r3, [sp, #28]
  4072b8:	ea54 0305 	orrs.w	r3, r4, r5
  4072bc:	970e      	str	r7, [sp, #56]	; 0x38
  4072be:	f43f aba1 	beq.w	406a04 <_vfprintf_r+0x9b4>
  4072c2:	4617      	mov	r7, r2
  4072c4:	f7ff b81f 	b.w	406306 <_vfprintf_r+0x2b6>
  4072c8:	980e      	ldr	r0, [sp, #56]	; 0x38
  4072ca:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
  4072ce:	f1bb 0f00 	cmp.w	fp, #0
  4072d2:	8804      	ldrh	r4, [r0, #0]
  4072d4:	f100 0704 	add.w	r7, r0, #4
  4072d8:	f04f 0500 	mov.w	r5, #0
  4072dc:	f2c0 81ac 	blt.w	407638 <_vfprintf_r+0x15e8>
  4072e0:	f021 0380 	bic.w	r3, r1, #128	; 0x80
  4072e4:	9307      	str	r3, [sp, #28]
  4072e6:	ea54 0305 	orrs.w	r3, r4, r5
  4072ea:	970e      	str	r7, [sp, #56]	; 0x38
  4072ec:	4617      	mov	r7, r2
  4072ee:	f47f a899 	bne.w	406424 <_vfprintf_r+0x3d4>
  4072f2:	f7ff ba53 	b.w	40679c <_vfprintf_r+0x74c>
  4072f6:	a821      	add	r0, sp, #132	; 0x84
  4072f8:	a91e      	add	r1, sp, #120	; 0x78
  4072fa:	9004      	str	r0, [sp, #16]
  4072fc:	9103      	str	r1, [sp, #12]
  4072fe:	a81d      	add	r0, sp, #116	; 0x74
  407300:	2103      	movs	r1, #3
  407302:	9002      	str	r0, [sp, #8]
  407304:	9a09      	ldr	r2, [sp, #36]	; 0x24
  407306:	f8cd b004 	str.w	fp, [sp, #4]
  40730a:	463b      	mov	r3, r7
  40730c:	9100      	str	r1, [sp, #0]
  40730e:	980a      	ldr	r0, [sp, #40]	; 0x28
  407310:	f000 fb5a 	bl	4079c8 <_dtoa_r>
  407314:	465d      	mov	r5, fp
  407316:	4606      	mov	r6, r0
  407318:	9b11      	ldr	r3, [sp, #68]	; 0x44
  40731a:	2b46      	cmp	r3, #70	; 0x46
  40731c:	eb06 0405 	add.w	r4, r6, r5
  407320:	f47f aed8 	bne.w	4070d4 <_vfprintf_r+0x1084>
  407324:	7833      	ldrb	r3, [r6, #0]
  407326:	2b30      	cmp	r3, #48	; 0x30
  407328:	f000 8192 	beq.w	407650 <_vfprintf_r+0x1600>
  40732c:	9d1d      	ldr	r5, [sp, #116]	; 0x74
  40732e:	442c      	add	r4, r5
  407330:	e6d0      	b.n	4070d4 <_vfprintf_r+0x1084>
  407332:	aa23      	add	r2, sp, #140	; 0x8c
  407334:	9908      	ldr	r1, [sp, #32]
  407336:	980a      	ldr	r0, [sp, #40]	; 0x28
  407338:	f7fd ff4c 	bl	4051d4 <__sprint_r>
  40733c:	2800      	cmp	r0, #0
  40733e:	f47e afb6 	bne.w	4062ae <_vfprintf_r+0x25e>
  407342:	9d1d      	ldr	r5, [sp, #116]	; 0x74
  407344:	9c25      	ldr	r4, [sp, #148]	; 0x94
  407346:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  40734a:	e75f      	b.n	40720c <_vfprintf_r+0x11bc>
  40734c:	f1bb 0f00 	cmp.w	fp, #0
  407350:	bf08      	it	eq
  407352:	f04f 0b01 	moveq.w	fp, #1
  407356:	e689      	b.n	40706c <_vfprintf_r+0x101c>
  407358:	9b07      	ldr	r3, [sp, #28]
  40735a:	f043 0320 	orr.w	r3, r3, #32
  40735e:	9307      	str	r3, [sp, #28]
  407360:	f108 0801 	add.w	r8, r8, #1
  407364:	f898 3000 	ldrb.w	r3, [r8]
  407368:	f7fe bee5 	b.w	406136 <_vfprintf_r+0xe6>
  40736c:	aa23      	add	r2, sp, #140	; 0x8c
  40736e:	9908      	ldr	r1, [sp, #32]
  407370:	980a      	ldr	r0, [sp, #40]	; 0x28
  407372:	f7fd ff2f 	bl	4051d4 <__sprint_r>
  407376:	2800      	cmp	r0, #0
  407378:	f47e af99 	bne.w	4062ae <_vfprintf_r+0x25e>
  40737c:	9c25      	ldr	r4, [sp, #148]	; 0x94
  40737e:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  407382:	f7ff bb8b 	b.w	406a9c <_vfprintf_r+0xa4c>
  407386:	aa23      	add	r2, sp, #140	; 0x8c
  407388:	9908      	ldr	r1, [sp, #32]
  40738a:	980a      	ldr	r0, [sp, #40]	; 0x28
  40738c:	f7fd ff22 	bl	4051d4 <__sprint_r>
  407390:	2800      	cmp	r0, #0
  407392:	f47e af8c 	bne.w	4062ae <_vfprintf_r+0x25e>
  407396:	9c25      	ldr	r4, [sp, #148]	; 0x94
  407398:	9b24      	ldr	r3, [sp, #144]	; 0x90
  40739a:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  40739e:	9912      	ldr	r1, [sp, #72]	; 0x48
  4073a0:	f8c9 6000 	str.w	r6, [r9]
  4073a4:	3301      	adds	r3, #1
  4073a6:	440c      	add	r4, r1
  4073a8:	2b07      	cmp	r3, #7
  4073aa:	9425      	str	r4, [sp, #148]	; 0x94
  4073ac:	9324      	str	r3, [sp, #144]	; 0x90
  4073ae:	f8c9 1004 	str.w	r1, [r9, #4]
  4073b2:	f77f a924 	ble.w	4065fe <_vfprintf_r+0x5ae>
  4073b6:	e437      	b.n	406c28 <_vfprintf_r+0xbd8>
  4073b8:	4630      	mov	r0, r6
  4073ba:	f7fd fe61 	bl	405080 <strlen>
  4073be:	46a3      	mov	fp, r4
  4073c0:	4603      	mov	r3, r0
  4073c2:	900d      	str	r0, [sp, #52]	; 0x34
  4073c4:	f7ff baf2 	b.w	4069ac <_vfprintf_r+0x95c>
  4073c8:	272d      	movs	r7, #45	; 0x2d
  4073ca:	9309      	str	r3, [sp, #36]	; 0x24
  4073cc:	9b10      	ldr	r3, [sp, #64]	; 0x40
  4073ce:	9307      	str	r3, [sp, #28]
  4073d0:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
  4073d4:	f04f 0b00 	mov.w	fp, #0
  4073d8:	f7ff b849 	b.w	40646e <_vfprintf_r+0x41e>
  4073dc:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  4073de:	1cd8      	adds	r0, r3, #3
  4073e0:	db2b      	blt.n	40743a <_vfprintf_r+0x13ea>
  4073e2:	459b      	cmp	fp, r3
  4073e4:	db29      	blt.n	40743a <_vfprintf_r+0x13ea>
  4073e6:	9313      	str	r3, [sp, #76]	; 0x4c
  4073e8:	e697      	b.n	40711a <_vfprintf_r+0x10ca>
  4073ea:	4623      	mov	r3, r4
  4073ec:	e685      	b.n	4070fa <_vfprintf_r+0x10aa>
  4073ee:	aa23      	add	r2, sp, #140	; 0x8c
  4073f0:	9908      	ldr	r1, [sp, #32]
  4073f2:	980a      	ldr	r0, [sp, #40]	; 0x28
  4073f4:	f7fd feee 	bl	4051d4 <__sprint_r>
  4073f8:	2800      	cmp	r0, #0
  4073fa:	f47e af58 	bne.w	4062ae <_vfprintf_r+0x25e>
  4073fe:	9c25      	ldr	r4, [sp, #148]	; 0x94
  407400:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  407404:	e477      	b.n	406cf6 <_vfprintf_r+0xca6>
  407406:	4614      	mov	r4, r2
  407408:	3301      	adds	r3, #1
  40740a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  40740c:	9324      	str	r3, [sp, #144]	; 0x90
  40740e:	442c      	add	r4, r5
  407410:	2b07      	cmp	r3, #7
  407412:	9425      	str	r4, [sp, #148]	; 0x94
  407414:	e889 0024 	stmia.w	r9, {r2, r5}
  407418:	dcb5      	bgt.n	407386 <_vfprintf_r+0x1336>
  40741a:	f109 0908 	add.w	r9, r9, #8
  40741e:	e7be      	b.n	40739e <_vfprintf_r+0x134e>
  407420:	aa23      	add	r2, sp, #140	; 0x8c
  407422:	9908      	ldr	r1, [sp, #32]
  407424:	980a      	ldr	r0, [sp, #40]	; 0x28
  407426:	f7fd fed5 	bl	4051d4 <__sprint_r>
  40742a:	2800      	cmp	r0, #0
  40742c:	f47e af3f 	bne.w	4062ae <_vfprintf_r+0x25e>
  407430:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  407432:	9c25      	ldr	r4, [sp, #148]	; 0x94
  407434:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  407438:	e52d      	b.n	406e96 <_vfprintf_r+0xe46>
  40743a:	9a11      	ldr	r2, [sp, #68]	; 0x44
  40743c:	3a02      	subs	r2, #2
  40743e:	9211      	str	r2, [sp, #68]	; 0x44
  407440:	3b01      	subs	r3, #1
  407442:	2b00      	cmp	r3, #0
  407444:	f89d 2044 	ldrb.w	r2, [sp, #68]	; 0x44
  407448:	931d      	str	r3, [sp, #116]	; 0x74
  40744a:	bfb8      	it	lt
  40744c:	425b      	neglt	r3, r3
  40744e:	f88d 207c 	strb.w	r2, [sp, #124]	; 0x7c
  407452:	bfb4      	ite	lt
  407454:	222d      	movlt	r2, #45	; 0x2d
  407456:	222b      	movge	r2, #43	; 0x2b
  407458:	2b09      	cmp	r3, #9
  40745a:	f88d 207d 	strb.w	r2, [sp, #125]	; 0x7d
  40745e:	f340 80d8 	ble.w	407612 <_vfprintf_r+0x15c2>
  407462:	f10d 008b 	add.w	r0, sp, #139	; 0x8b
  407466:	4604      	mov	r4, r0
  407468:	4a1e      	ldr	r2, [pc, #120]	; (4074e4 <_vfprintf_r+0x1494>)
  40746a:	fb82 2103 	smull	r2, r1, r2, r3
  40746e:	17da      	asrs	r2, r3, #31
  407470:	ebc2 02a1 	rsb	r2, r2, r1, asr #2
  407474:	eb02 0182 	add.w	r1, r2, r2, lsl #2
  407478:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
  40747c:	f103 0130 	add.w	r1, r3, #48	; 0x30
  407480:	2a09      	cmp	r2, #9
  407482:	4613      	mov	r3, r2
  407484:	f804 1d01 	strb.w	r1, [r4, #-1]!
  407488:	dcee      	bgt.n	407468 <_vfprintf_r+0x1418>
  40748a:	4621      	mov	r1, r4
  40748c:	3330      	adds	r3, #48	; 0x30
  40748e:	b2da      	uxtb	r2, r3
  407490:	f801 2d01 	strb.w	r2, [r1, #-1]!
  407494:	4288      	cmp	r0, r1
  407496:	f240 8134 	bls.w	407702 <_vfprintf_r+0x16b2>
  40749a:	f10d 017e 	add.w	r1, sp, #126	; 0x7e
  40749e:	4623      	mov	r3, r4
  4074a0:	e001      	b.n	4074a6 <_vfprintf_r+0x1456>
  4074a2:	f813 2b01 	ldrb.w	r2, [r3], #1
  4074a6:	f801 2b01 	strb.w	r2, [r1], #1
  4074aa:	4298      	cmp	r0, r3
  4074ac:	d1f9      	bne.n	4074a2 <_vfprintf_r+0x1452>
  4074ae:	1c43      	adds	r3, r0, #1
  4074b0:	1b1b      	subs	r3, r3, r4
  4074b2:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
  4074b6:	4413      	add	r3, r2
  4074b8:	aa1f      	add	r2, sp, #124	; 0x7c
  4074ba:	1a9b      	subs	r3, r3, r2
  4074bc:	9a12      	ldr	r2, [sp, #72]	; 0x48
  4074be:	9319      	str	r3, [sp, #100]	; 0x64
  4074c0:	2a01      	cmp	r2, #1
  4074c2:	4413      	add	r3, r2
  4074c4:	930d      	str	r3, [sp, #52]	; 0x34
  4074c6:	f340 80d7 	ble.w	407678 <_vfprintf_r+0x1628>
  4074ca:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4074cc:	9a16      	ldr	r2, [sp, #88]	; 0x58
  4074ce:	4413      	add	r3, r2
  4074d0:	2200      	movs	r2, #0
  4074d2:	930d      	str	r3, [sp, #52]	; 0x34
  4074d4:	9213      	str	r2, [sp, #76]	; 0x4c
  4074d6:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  4074da:	e62c      	b.n	407136 <_vfprintf_r+0x10e6>
  4074dc:	0040ae48 	.word	0x0040ae48
  4074e0:	0040ae28 	.word	0x0040ae28
  4074e4:	66666667 	.word	0x66666667
  4074e8:	aa23      	add	r2, sp, #140	; 0x8c
  4074ea:	9908      	ldr	r1, [sp, #32]
  4074ec:	980a      	ldr	r0, [sp, #40]	; 0x28
  4074ee:	f7fd fe71 	bl	4051d4 <__sprint_r>
  4074f2:	2800      	cmp	r0, #0
  4074f4:	f47e aedb 	bne.w	4062ae <_vfprintf_r+0x25e>
  4074f8:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  4074fa:	9a12      	ldr	r2, [sp, #72]	; 0x48
  4074fc:	9c25      	ldr	r4, [sp, #148]	; 0x94
  4074fe:	1ad3      	subs	r3, r2, r3
  407500:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  407504:	e4df      	b.n	406ec6 <_vfprintf_r+0xe76>
  407506:	2d06      	cmp	r5, #6
  407508:	462b      	mov	r3, r5
  40750a:	bf28      	it	cs
  40750c:	2306      	movcs	r3, #6
  40750e:	930d      	str	r3, [sp, #52]	; 0x34
  407510:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  407514:	46b3      	mov	fp, r6
  407516:	970e      	str	r7, [sp, #56]	; 0x38
  407518:	9613      	str	r6, [sp, #76]	; 0x4c
  40751a:	4637      	mov	r7, r6
  40751c:	9309      	str	r3, [sp, #36]	; 0x24
  40751e:	4e84      	ldr	r6, [pc, #528]	; (407730 <_vfprintf_r+0x16e0>)
  407520:	f7fe bfa4 	b.w	40646c <_vfprintf_r+0x41c>
  407524:	f04f 0b06 	mov.w	fp, #6
  407528:	e5a0      	b.n	40706c <_vfprintf_r+0x101c>
  40752a:	9307      	str	r3, [sp, #28]
  40752c:	f7ff b8ed 	b.w	40670a <_vfprintf_r+0x6ba>
  407530:	a821      	add	r0, sp, #132	; 0x84
  407532:	a91e      	add	r1, sp, #120	; 0x78
  407534:	9004      	str	r0, [sp, #16]
  407536:	9103      	str	r1, [sp, #12]
  407538:	a81d      	add	r0, sp, #116	; 0x74
  40753a:	2103      	movs	r1, #3
  40753c:	9002      	str	r0, [sp, #8]
  40753e:	9a09      	ldr	r2, [sp, #36]	; 0x24
  407540:	f8cd b004 	str.w	fp, [sp, #4]
  407544:	463b      	mov	r3, r7
  407546:	9100      	str	r1, [sp, #0]
  407548:	980a      	ldr	r0, [sp, #40]	; 0x28
  40754a:	f000 fa3d 	bl	4079c8 <_dtoa_r>
  40754e:	465d      	mov	r5, fp
  407550:	4606      	mov	r6, r0
  407552:	eb00 040b 	add.w	r4, r0, fp
  407556:	e6e5      	b.n	407324 <_vfprintf_r+0x12d4>
  407558:	272d      	movs	r7, #45	; 0x2d
  40755a:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
  40755e:	f7ff b9be 	b.w	4068de <_vfprintf_r+0x88e>
  407562:	9a16      	ldr	r2, [sp, #88]	; 0x58
  407564:	9b12      	ldr	r3, [sp, #72]	; 0x48
  407566:	4413      	add	r3, r2
  407568:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  40756a:	930d      	str	r3, [sp, #52]	; 0x34
  40756c:	2a00      	cmp	r2, #0
  40756e:	f340 808d 	ble.w	40768c <_vfprintf_r+0x163c>
  407572:	2267      	movs	r2, #103	; 0x67
  407574:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  407578:	9211      	str	r2, [sp, #68]	; 0x44
  40757a:	e5dc      	b.n	407136 <_vfprintf_r+0x10e6>
  40757c:	2b00      	cmp	r3, #0
  40757e:	f340 808d 	ble.w	40769c <_vfprintf_r+0x164c>
  407582:	f1bb 0f00 	cmp.w	fp, #0
  407586:	d15a      	bne.n	40763e <_vfprintf_r+0x15ee>
  407588:	9a07      	ldr	r2, [sp, #28]
  40758a:	07d1      	lsls	r1, r2, #31
  40758c:	d457      	bmi.n	40763e <_vfprintf_r+0x15ee>
  40758e:	461a      	mov	r2, r3
  407590:	920d      	str	r2, [sp, #52]	; 0x34
  407592:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  407596:	e5ce      	b.n	407136 <_vfprintf_r+0x10e6>
  407598:	ea25 73e5 	bic.w	r3, r5, r5, asr #31
  40759c:	970e      	str	r7, [sp, #56]	; 0x38
  40759e:	9309      	str	r3, [sp, #36]	; 0x24
  4075a0:	950d      	str	r5, [sp, #52]	; 0x34
  4075a2:	4683      	mov	fp, r0
  4075a4:	9013      	str	r0, [sp, #76]	; 0x4c
  4075a6:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
  4075aa:	f7fe bf5f 	b.w	40646c <_vfprintf_r+0x41c>
  4075ae:	9b07      	ldr	r3, [sp, #28]
  4075b0:	07db      	lsls	r3, r3, #31
  4075b2:	465f      	mov	r7, fp
  4075b4:	d505      	bpl.n	4075c2 <_vfprintf_r+0x1572>
  4075b6:	ae40      	add	r6, sp, #256	; 0x100
  4075b8:	2330      	movs	r3, #48	; 0x30
  4075ba:	f806 3d41 	strb.w	r3, [r6, #-65]!
  4075be:	f7fe bf4b 	b.w	406458 <_vfprintf_r+0x408>
  4075c2:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
  4075c6:	ae30      	add	r6, sp, #192	; 0xc0
  4075c8:	f7fe bf49 	b.w	40645e <_vfprintf_r+0x40e>
  4075cc:	9b11      	ldr	r3, [sp, #68]	; 0x44
  4075ce:	2b47      	cmp	r3, #71	; 0x47
  4075d0:	f47f ad7f 	bne.w	4070d2 <_vfprintf_r+0x1082>
  4075d4:	9b07      	ldr	r3, [sp, #28]
  4075d6:	07dc      	lsls	r4, r3, #31
  4075d8:	f53f ae9e 	bmi.w	407318 <_vfprintf_r+0x12c8>
  4075dc:	9b21      	ldr	r3, [sp, #132]	; 0x84
  4075de:	1b9b      	subs	r3, r3, r6
  4075e0:	9312      	str	r3, [sp, #72]	; 0x48
  4075e2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4075e4:	2b47      	cmp	r3, #71	; 0x47
  4075e6:	f43f aef9 	beq.w	4073dc <_vfprintf_r+0x138c>
  4075ea:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  4075ec:	e728      	b.n	407440 <_vfprintf_r+0x13f0>
  4075ee:	46a0      	mov	r8, r4
  4075f0:	2500      	movs	r5, #0
  4075f2:	f7fe bda2 	b.w	40613a <_vfprintf_r+0xea>
  4075f6:	aa23      	add	r2, sp, #140	; 0x8c
  4075f8:	9908      	ldr	r1, [sp, #32]
  4075fa:	980a      	ldr	r0, [sp, #40]	; 0x28
  4075fc:	f7fd fdea 	bl	4051d4 <__sprint_r>
  407600:	2800      	cmp	r0, #0
  407602:	f47e ae54 	bne.w	4062ae <_vfprintf_r+0x25e>
  407606:	9d1d      	ldr	r5, [sp, #116]	; 0x74
  407608:	9c25      	ldr	r4, [sp, #148]	; 0x94
  40760a:	9b24      	ldr	r3, [sp, #144]	; 0x90
  40760c:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  407610:	e613      	b.n	40723a <_vfprintf_r+0x11ea>
  407612:	3330      	adds	r3, #48	; 0x30
  407614:	2230      	movs	r2, #48	; 0x30
  407616:	f88d 307f 	strb.w	r3, [sp, #127]	; 0x7f
  40761a:	f88d 207e 	strb.w	r2, [sp, #126]	; 0x7e
  40761e:	ab20      	add	r3, sp, #128	; 0x80
  407620:	e74a      	b.n	4074b8 <_vfprintf_r+0x1468>
  407622:	9b21      	ldr	r3, [sp, #132]	; 0x84
  407624:	e569      	b.n	4070fa <_vfprintf_r+0x10aa>
  407626:	9a16      	ldr	r2, [sp, #88]	; 0x58
  407628:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  40762a:	4413      	add	r3, r2
  40762c:	2267      	movs	r2, #103	; 0x67
  40762e:	930d      	str	r3, [sp, #52]	; 0x34
  407630:	9211      	str	r2, [sp, #68]	; 0x44
  407632:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  407636:	e57e      	b.n	407136 <_vfprintf_r+0x10e6>
  407638:	970e      	str	r7, [sp, #56]	; 0x38
  40763a:	4617      	mov	r7, r2
  40763c:	e401      	b.n	406e42 <_vfprintf_r+0xdf2>
  40763e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  407640:	9a16      	ldr	r2, [sp, #88]	; 0x58
  407642:	189d      	adds	r5, r3, r2
  407644:	eb05 030b 	add.w	r3, r5, fp
  407648:	930d      	str	r3, [sp, #52]	; 0x34
  40764a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  40764e:	e572      	b.n	407136 <_vfprintf_r+0x10e6>
  407650:	9809      	ldr	r0, [sp, #36]	; 0x24
  407652:	4639      	mov	r1, r7
  407654:	2200      	movs	r2, #0
  407656:	2300      	movs	r3, #0
  407658:	f7fd facc 	bl	404bf4 <__aeabi_dcmpeq>
  40765c:	2800      	cmp	r0, #0
  40765e:	f47f ae65 	bne.w	40732c <_vfprintf_r+0x12dc>
  407662:	f1c5 0501 	rsb	r5, r5, #1
  407666:	951d      	str	r5, [sp, #116]	; 0x74
  407668:	442c      	add	r4, r5
  40766a:	e533      	b.n	4070d4 <_vfprintf_r+0x1084>
  40766c:	4e31      	ldr	r6, [pc, #196]	; (407734 <_vfprintf_r+0x16e4>)
  40766e:	4b32      	ldr	r3, [pc, #200]	; (407738 <_vfprintf_r+0x16e8>)
  407670:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
  407674:	f7ff b935 	b.w	4068e2 <_vfprintf_r+0x892>
  407678:	9b07      	ldr	r3, [sp, #28]
  40767a:	f013 0301 	ands.w	r3, r3, #1
  40767e:	f47f af24 	bne.w	4074ca <_vfprintf_r+0x147a>
  407682:	9313      	str	r3, [sp, #76]	; 0x4c
  407684:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  407686:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  40768a:	e554      	b.n	407136 <_vfprintf_r+0x10e6>
  40768c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  40768e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  407690:	f1c3 0301 	rsb	r3, r3, #1
  407694:	441a      	add	r2, r3
  407696:	4613      	mov	r3, r2
  407698:	920d      	str	r2, [sp, #52]	; 0x34
  40769a:	e76a      	b.n	407572 <_vfprintf_r+0x1522>
  40769c:	f1bb 0f00 	cmp.w	fp, #0
  4076a0:	d102      	bne.n	4076a8 <_vfprintf_r+0x1658>
  4076a2:	9b07      	ldr	r3, [sp, #28]
  4076a4:	07da      	lsls	r2, r3, #31
  4076a6:	d507      	bpl.n	4076b8 <_vfprintf_r+0x1668>
  4076a8:	9b16      	ldr	r3, [sp, #88]	; 0x58
  4076aa:	1c5d      	adds	r5, r3, #1
  4076ac:	eb05 030b 	add.w	r3, r5, fp
  4076b0:	930d      	str	r3, [sp, #52]	; 0x34
  4076b2:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  4076b6:	e53e      	b.n	407136 <_vfprintf_r+0x10e6>
  4076b8:	2301      	movs	r3, #1
  4076ba:	930d      	str	r3, [sp, #52]	; 0x34
  4076bc:	e53b      	b.n	407136 <_vfprintf_r+0x10e6>
  4076be:	980e      	ldr	r0, [sp, #56]	; 0x38
  4076c0:	f898 3001 	ldrb.w	r3, [r8, #1]
  4076c4:	6805      	ldr	r5, [r0, #0]
  4076c6:	3004      	adds	r0, #4
  4076c8:	2d00      	cmp	r5, #0
  4076ca:	900e      	str	r0, [sp, #56]	; 0x38
  4076cc:	46a0      	mov	r8, r4
  4076ce:	f6be ad32 	bge.w	406136 <_vfprintf_r+0xe6>
  4076d2:	f04f 35ff 	mov.w	r5, #4294967295
  4076d6:	f7fe bd2e 	b.w	406136 <_vfprintf_r+0xe6>
  4076da:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  4076de:	f7fe bfe8 	b.w	4066b2 <_vfprintf_r+0x662>
  4076e2:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  4076e6:	f7fe be7e 	b.w	4063e6 <_vfprintf_r+0x396>
  4076ea:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  4076ee:	f7ff b91c 	b.w	40692a <_vfprintf_r+0x8da>
  4076f2:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  4076f6:	f7ff b8c4 	b.w	406882 <_vfprintf_r+0x832>
  4076fa:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  4076fe:	f7fe bde8 	b.w	4062d2 <_vfprintf_r+0x282>
  407702:	f10d 037e 	add.w	r3, sp, #126	; 0x7e
  407706:	e6d7      	b.n	4074b8 <_vfprintf_r+0x1468>
  407708:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  40770c:	f7ff b825 	b.w	40675a <_vfprintf_r+0x70a>
  407710:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  407714:	f7fe be3e 	b.w	406394 <_vfprintf_r+0x344>
  407718:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  40771c:	f7ff b961 	b.w	4069e2 <_vfprintf_r+0x992>
  407720:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  407724:	f7ff b890 	b.w	406848 <_vfprintf_r+0x7f8>
  407728:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  40772c:	f7ff b85a 	b.w	4067e4 <_vfprintf_r+0x794>
  407730:	0040ae10 	.word	0x0040ae10
  407734:	0040ae44 	.word	0x0040ae44
  407738:	0040ae40 	.word	0x0040ae40

0040773c <__sbprintf>:
  40773c:	b5f0      	push	{r4, r5, r6, r7, lr}
  40773e:	460c      	mov	r4, r1
  407740:	f2ad 4d6c 	subw	sp, sp, #1132	; 0x46c
  407744:	8989      	ldrh	r1, [r1, #12]
  407746:	6e66      	ldr	r6, [r4, #100]	; 0x64
  407748:	89e5      	ldrh	r5, [r4, #14]
  40774a:	9619      	str	r6, [sp, #100]	; 0x64
  40774c:	f021 0102 	bic.w	r1, r1, #2
  407750:	6a66      	ldr	r6, [r4, #36]	; 0x24
  407752:	f8ad 500e 	strh.w	r5, [sp, #14]
  407756:	2500      	movs	r5, #0
  407758:	69e7      	ldr	r7, [r4, #28]
  40775a:	f8ad 100c 	strh.w	r1, [sp, #12]
  40775e:	9609      	str	r6, [sp, #36]	; 0x24
  407760:	9506      	str	r5, [sp, #24]
  407762:	ae1a      	add	r6, sp, #104	; 0x68
  407764:	f44f 6580 	mov.w	r5, #1024	; 0x400
  407768:	4669      	mov	r1, sp
  40776a:	9600      	str	r6, [sp, #0]
  40776c:	9604      	str	r6, [sp, #16]
  40776e:	9502      	str	r5, [sp, #8]
  407770:	9505      	str	r5, [sp, #20]
  407772:	9707      	str	r7, [sp, #28]
  407774:	4606      	mov	r6, r0
  407776:	f7fe fc6b 	bl	406050 <_vfprintf_r>
  40777a:	1e05      	subs	r5, r0, #0
  40777c:	db07      	blt.n	40778e <__sbprintf+0x52>
  40777e:	4630      	mov	r0, r6
  407780:	4669      	mov	r1, sp
  407782:	f001 f8f1 	bl	408968 <_fflush_r>
  407786:	2800      	cmp	r0, #0
  407788:	bf18      	it	ne
  40778a:	f04f 35ff 	movne.w	r5, #4294967295
  40778e:	f8bd 300c 	ldrh.w	r3, [sp, #12]
  407792:	065b      	lsls	r3, r3, #25
  407794:	d503      	bpl.n	40779e <__sbprintf+0x62>
  407796:	89a3      	ldrh	r3, [r4, #12]
  407798:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  40779c:	81a3      	strh	r3, [r4, #12]
  40779e:	4628      	mov	r0, r5
  4077a0:	f20d 4d6c 	addw	sp, sp, #1132	; 0x46c
  4077a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4077a6:	bf00      	nop

004077a8 <__swsetup_r>:
  4077a8:	b538      	push	{r3, r4, r5, lr}
  4077aa:	4b30      	ldr	r3, [pc, #192]	; (40786c <__swsetup_r+0xc4>)
  4077ac:	681b      	ldr	r3, [r3, #0]
  4077ae:	4605      	mov	r5, r0
  4077b0:	460c      	mov	r4, r1
  4077b2:	b113      	cbz	r3, 4077ba <__swsetup_r+0x12>
  4077b4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  4077b6:	2a00      	cmp	r2, #0
  4077b8:	d038      	beq.n	40782c <__swsetup_r+0x84>
  4077ba:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
  4077be:	b293      	uxth	r3, r2
  4077c0:	0718      	lsls	r0, r3, #28
  4077c2:	d50c      	bpl.n	4077de <__swsetup_r+0x36>
  4077c4:	6920      	ldr	r0, [r4, #16]
  4077c6:	b1a8      	cbz	r0, 4077f4 <__swsetup_r+0x4c>
  4077c8:	f013 0201 	ands.w	r2, r3, #1
  4077cc:	d01e      	beq.n	40780c <__swsetup_r+0x64>
  4077ce:	6963      	ldr	r3, [r4, #20]
  4077d0:	2200      	movs	r2, #0
  4077d2:	425b      	negs	r3, r3
  4077d4:	61a3      	str	r3, [r4, #24]
  4077d6:	60a2      	str	r2, [r4, #8]
  4077d8:	b1f0      	cbz	r0, 407818 <__swsetup_r+0x70>
  4077da:	2000      	movs	r0, #0
  4077dc:	bd38      	pop	{r3, r4, r5, pc}
  4077de:	06d9      	lsls	r1, r3, #27
  4077e0:	d53c      	bpl.n	40785c <__swsetup_r+0xb4>
  4077e2:	0758      	lsls	r0, r3, #29
  4077e4:	d426      	bmi.n	407834 <__swsetup_r+0x8c>
  4077e6:	6920      	ldr	r0, [r4, #16]
  4077e8:	f042 0308 	orr.w	r3, r2, #8
  4077ec:	81a3      	strh	r3, [r4, #12]
  4077ee:	b29b      	uxth	r3, r3
  4077f0:	2800      	cmp	r0, #0
  4077f2:	d1e9      	bne.n	4077c8 <__swsetup_r+0x20>
  4077f4:	f403 7220 	and.w	r2, r3, #640	; 0x280
  4077f8:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
  4077fc:	d0e4      	beq.n	4077c8 <__swsetup_r+0x20>
  4077fe:	4628      	mov	r0, r5
  407800:	4621      	mov	r1, r4
  407802:	f001 fce1 	bl	4091c8 <__smakebuf_r>
  407806:	89a3      	ldrh	r3, [r4, #12]
  407808:	6920      	ldr	r0, [r4, #16]
  40780a:	e7dd      	b.n	4077c8 <__swsetup_r+0x20>
  40780c:	0799      	lsls	r1, r3, #30
  40780e:	bf58      	it	pl
  407810:	6962      	ldrpl	r2, [r4, #20]
  407812:	60a2      	str	r2, [r4, #8]
  407814:	2800      	cmp	r0, #0
  407816:	d1e0      	bne.n	4077da <__swsetup_r+0x32>
  407818:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  40781c:	061a      	lsls	r2, r3, #24
  40781e:	d5dd      	bpl.n	4077dc <__swsetup_r+0x34>
  407820:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  407824:	81a3      	strh	r3, [r4, #12]
  407826:	f04f 30ff 	mov.w	r0, #4294967295
  40782a:	bd38      	pop	{r3, r4, r5, pc}
  40782c:	4618      	mov	r0, r3
  40782e:	f001 f92f 	bl	408a90 <__sinit>
  407832:	e7c2      	b.n	4077ba <__swsetup_r+0x12>
  407834:	6b21      	ldr	r1, [r4, #48]	; 0x30
  407836:	b151      	cbz	r1, 40784e <__swsetup_r+0xa6>
  407838:	f104 0340 	add.w	r3, r4, #64	; 0x40
  40783c:	4299      	cmp	r1, r3
  40783e:	d004      	beq.n	40784a <__swsetup_r+0xa2>
  407840:	4628      	mov	r0, r5
  407842:	f001 f9ef 	bl	408c24 <_free_r>
  407846:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
  40784a:	2300      	movs	r3, #0
  40784c:	6323      	str	r3, [r4, #48]	; 0x30
  40784e:	2300      	movs	r3, #0
  407850:	6920      	ldr	r0, [r4, #16]
  407852:	6063      	str	r3, [r4, #4]
  407854:	f022 0224 	bic.w	r2, r2, #36	; 0x24
  407858:	6020      	str	r0, [r4, #0]
  40785a:	e7c5      	b.n	4077e8 <__swsetup_r+0x40>
  40785c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
  407860:	2309      	movs	r3, #9
  407862:	602b      	str	r3, [r5, #0]
  407864:	f04f 30ff 	mov.w	r0, #4294967295
  407868:	81a2      	strh	r2, [r4, #12]
  40786a:	bd38      	pop	{r3, r4, r5, pc}
  40786c:	20400438 	.word	0x20400438

00407870 <register_fini>:
  407870:	4b02      	ldr	r3, [pc, #8]	; (40787c <register_fini+0xc>)
  407872:	b113      	cbz	r3, 40787a <register_fini+0xa>
  407874:	4802      	ldr	r0, [pc, #8]	; (407880 <register_fini+0x10>)
  407876:	f000 b80d 	b.w	407894 <atexit>
  40787a:	4770      	bx	lr
  40787c:	00000000 	.word	0x00000000
  407880:	00408aa5 	.word	0x00408aa5

00407884 <abort>:
  407884:	b508      	push	{r3, lr}
  407886:	2006      	movs	r0, #6
  407888:	f002 fd96 	bl	40a3b8 <raise>
  40788c:	2001      	movs	r0, #1
  40788e:	f7fc f9e1 	bl	403c54 <_exit>
  407892:	bf00      	nop

00407894 <atexit>:
  407894:	2300      	movs	r3, #0
  407896:	4601      	mov	r1, r0
  407898:	461a      	mov	r2, r3
  40789a:	4618      	mov	r0, r3
  40789c:	f002 be92 	b.w	40a5c4 <__register_exitproc>

004078a0 <quorem>:
  4078a0:	6902      	ldr	r2, [r0, #16]
  4078a2:	690b      	ldr	r3, [r1, #16]
  4078a4:	4293      	cmp	r3, r2
  4078a6:	f300 808d 	bgt.w	4079c4 <quorem+0x124>
  4078aa:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4078ae:	f103 38ff 	add.w	r8, r3, #4294967295
  4078b2:	f101 0714 	add.w	r7, r1, #20
  4078b6:	f100 0b14 	add.w	fp, r0, #20
  4078ba:	f857 2028 	ldr.w	r2, [r7, r8, lsl #2]
  4078be:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
  4078c2:	ea4f 0488 	mov.w	r4, r8, lsl #2
  4078c6:	b083      	sub	sp, #12
  4078c8:	3201      	adds	r2, #1
  4078ca:	fbb3 f9f2 	udiv	r9, r3, r2
  4078ce:	eb0b 0304 	add.w	r3, fp, r4
  4078d2:	9400      	str	r4, [sp, #0]
  4078d4:	eb07 0a04 	add.w	sl, r7, r4
  4078d8:	9301      	str	r3, [sp, #4]
  4078da:	f1b9 0f00 	cmp.w	r9, #0
  4078de:	d039      	beq.n	407954 <quorem+0xb4>
  4078e0:	2500      	movs	r5, #0
  4078e2:	46bc      	mov	ip, r7
  4078e4:	46de      	mov	lr, fp
  4078e6:	462b      	mov	r3, r5
  4078e8:	f85c 6b04 	ldr.w	r6, [ip], #4
  4078ec:	f8de 2000 	ldr.w	r2, [lr]
  4078f0:	b2b4      	uxth	r4, r6
  4078f2:	fb09 5504 	mla	r5, r9, r4, r5
  4078f6:	0c36      	lsrs	r6, r6, #16
  4078f8:	0c2c      	lsrs	r4, r5, #16
  4078fa:	fb09 4406 	mla	r4, r9, r6, r4
  4078fe:	b2ad      	uxth	r5, r5
  407900:	1b5b      	subs	r3, r3, r5
  407902:	b2a6      	uxth	r6, r4
  407904:	fa13 f382 	uxtah	r3, r3, r2
  407908:	ebc6 4612 	rsb	r6, r6, r2, lsr #16
  40790c:	eb06 4623 	add.w	r6, r6, r3, asr #16
  407910:	b29b      	uxth	r3, r3
  407912:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
  407916:	45e2      	cmp	sl, ip
  407918:	f84e 3b04 	str.w	r3, [lr], #4
  40791c:	ea4f 4514 	mov.w	r5, r4, lsr #16
  407920:	ea4f 4326 	mov.w	r3, r6, asr #16
  407924:	d2e0      	bcs.n	4078e8 <quorem+0x48>
  407926:	9b00      	ldr	r3, [sp, #0]
  407928:	f85b 3003 	ldr.w	r3, [fp, r3]
  40792c:	b993      	cbnz	r3, 407954 <quorem+0xb4>
  40792e:	9c01      	ldr	r4, [sp, #4]
  407930:	1f23      	subs	r3, r4, #4
  407932:	459b      	cmp	fp, r3
  407934:	d20c      	bcs.n	407950 <quorem+0xb0>
  407936:	f854 3c04 	ldr.w	r3, [r4, #-4]
  40793a:	b94b      	cbnz	r3, 407950 <quorem+0xb0>
  40793c:	f1a4 0308 	sub.w	r3, r4, #8
  407940:	e002      	b.n	407948 <quorem+0xa8>
  407942:	681a      	ldr	r2, [r3, #0]
  407944:	3b04      	subs	r3, #4
  407946:	b91a      	cbnz	r2, 407950 <quorem+0xb0>
  407948:	459b      	cmp	fp, r3
  40794a:	f108 38ff 	add.w	r8, r8, #4294967295
  40794e:	d3f8      	bcc.n	407942 <quorem+0xa2>
  407950:	f8c0 8010 	str.w	r8, [r0, #16]
  407954:	4604      	mov	r4, r0
  407956:	f002 f9fb 	bl	409d50 <__mcmp>
  40795a:	2800      	cmp	r0, #0
  40795c:	db2e      	blt.n	4079bc <quorem+0x11c>
  40795e:	f109 0901 	add.w	r9, r9, #1
  407962:	465d      	mov	r5, fp
  407964:	2300      	movs	r3, #0
  407966:	f857 1b04 	ldr.w	r1, [r7], #4
  40796a:	6828      	ldr	r0, [r5, #0]
  40796c:	b28a      	uxth	r2, r1
  40796e:	1a9a      	subs	r2, r3, r2
  407970:	0c09      	lsrs	r1, r1, #16
  407972:	fa12 f280 	uxtah	r2, r2, r0
  407976:	ebc1 4310 	rsb	r3, r1, r0, lsr #16
  40797a:	eb03 4322 	add.w	r3, r3, r2, asr #16
  40797e:	b291      	uxth	r1, r2
  407980:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
  407984:	45ba      	cmp	sl, r7
  407986:	f845 1b04 	str.w	r1, [r5], #4
  40798a:	ea4f 4323 	mov.w	r3, r3, asr #16
  40798e:	d2ea      	bcs.n	407966 <quorem+0xc6>
  407990:	f85b 2028 	ldr.w	r2, [fp, r8, lsl #2]
  407994:	eb0b 0388 	add.w	r3, fp, r8, lsl #2
  407998:	b982      	cbnz	r2, 4079bc <quorem+0x11c>
  40799a:	1f1a      	subs	r2, r3, #4
  40799c:	4593      	cmp	fp, r2
  40799e:	d20b      	bcs.n	4079b8 <quorem+0x118>
  4079a0:	f853 2c04 	ldr.w	r2, [r3, #-4]
  4079a4:	b942      	cbnz	r2, 4079b8 <quorem+0x118>
  4079a6:	3b08      	subs	r3, #8
  4079a8:	e002      	b.n	4079b0 <quorem+0x110>
  4079aa:	681a      	ldr	r2, [r3, #0]
  4079ac:	3b04      	subs	r3, #4
  4079ae:	b91a      	cbnz	r2, 4079b8 <quorem+0x118>
  4079b0:	459b      	cmp	fp, r3
  4079b2:	f108 38ff 	add.w	r8, r8, #4294967295
  4079b6:	d3f8      	bcc.n	4079aa <quorem+0x10a>
  4079b8:	f8c4 8010 	str.w	r8, [r4, #16]
  4079bc:	4648      	mov	r0, r9
  4079be:	b003      	add	sp, #12
  4079c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4079c4:	2000      	movs	r0, #0
  4079c6:	4770      	bx	lr

004079c8 <_dtoa_r>:
  4079c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4079cc:	6c01      	ldr	r1, [r0, #64]	; 0x40
  4079ce:	b097      	sub	sp, #92	; 0x5c
  4079d0:	4681      	mov	r9, r0
  4079d2:	9c23      	ldr	r4, [sp, #140]	; 0x8c
  4079d4:	4692      	mov	sl, r2
  4079d6:	469b      	mov	fp, r3
  4079d8:	b149      	cbz	r1, 4079ee <_dtoa_r+0x26>
  4079da:	6c42      	ldr	r2, [r0, #68]	; 0x44
  4079dc:	604a      	str	r2, [r1, #4]
  4079de:	2301      	movs	r3, #1
  4079e0:	4093      	lsls	r3, r2
  4079e2:	608b      	str	r3, [r1, #8]
  4079e4:	f001 ffd2 	bl	40998c <_Bfree>
  4079e8:	2300      	movs	r3, #0
  4079ea:	f8c9 3040 	str.w	r3, [r9, #64]	; 0x40
  4079ee:	f1bb 0f00 	cmp.w	fp, #0
  4079f2:	46d8      	mov	r8, fp
  4079f4:	db33      	blt.n	407a5e <_dtoa_r+0x96>
  4079f6:	2300      	movs	r3, #0
  4079f8:	6023      	str	r3, [r4, #0]
  4079fa:	4ba5      	ldr	r3, [pc, #660]	; (407c90 <_dtoa_r+0x2c8>)
  4079fc:	461a      	mov	r2, r3
  4079fe:	ea08 0303 	and.w	r3, r8, r3
  407a02:	4293      	cmp	r3, r2
  407a04:	d014      	beq.n	407a30 <_dtoa_r+0x68>
  407a06:	4650      	mov	r0, sl
  407a08:	4659      	mov	r1, fp
  407a0a:	2200      	movs	r2, #0
  407a0c:	2300      	movs	r3, #0
  407a0e:	f7fd f8f1 	bl	404bf4 <__aeabi_dcmpeq>
  407a12:	4605      	mov	r5, r0
  407a14:	b348      	cbz	r0, 407a6a <_dtoa_r+0xa2>
  407a16:	9a22      	ldr	r2, [sp, #136]	; 0x88
  407a18:	2301      	movs	r3, #1
  407a1a:	6013      	str	r3, [r2, #0]
  407a1c:	9b24      	ldr	r3, [sp, #144]	; 0x90
  407a1e:	2b00      	cmp	r3, #0
  407a20:	f000 80c5 	beq.w	407bae <_dtoa_r+0x1e6>
  407a24:	489b      	ldr	r0, [pc, #620]	; (407c94 <_dtoa_r+0x2cc>)
  407a26:	6018      	str	r0, [r3, #0]
  407a28:	3801      	subs	r0, #1
  407a2a:	b017      	add	sp, #92	; 0x5c
  407a2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  407a30:	9a22      	ldr	r2, [sp, #136]	; 0x88
  407a32:	f242 730f 	movw	r3, #9999	; 0x270f
  407a36:	6013      	str	r3, [r2, #0]
  407a38:	f1ba 0f00 	cmp.w	sl, #0
  407a3c:	f000 80a2 	beq.w	407b84 <_dtoa_r+0x1bc>
  407a40:	4895      	ldr	r0, [pc, #596]	; (407c98 <_dtoa_r+0x2d0>)
  407a42:	9b24      	ldr	r3, [sp, #144]	; 0x90
  407a44:	2b00      	cmp	r3, #0
  407a46:	d0f0      	beq.n	407a2a <_dtoa_r+0x62>
  407a48:	78c3      	ldrb	r3, [r0, #3]
  407a4a:	2b00      	cmp	r3, #0
  407a4c:	f000 80b1 	beq.w	407bb2 <_dtoa_r+0x1ea>
  407a50:	f100 0308 	add.w	r3, r0, #8
  407a54:	9a24      	ldr	r2, [sp, #144]	; 0x90
  407a56:	6013      	str	r3, [r2, #0]
  407a58:	b017      	add	sp, #92	; 0x5c
  407a5a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  407a5e:	2301      	movs	r3, #1
  407a60:	f02b 4800 	bic.w	r8, fp, #2147483648	; 0x80000000
  407a64:	6023      	str	r3, [r4, #0]
  407a66:	46c3      	mov	fp, r8
  407a68:	e7c7      	b.n	4079fa <_dtoa_r+0x32>
  407a6a:	aa14      	add	r2, sp, #80	; 0x50
  407a6c:	ab15      	add	r3, sp, #84	; 0x54
  407a6e:	9201      	str	r2, [sp, #4]
  407a70:	9300      	str	r3, [sp, #0]
  407a72:	4652      	mov	r2, sl
  407a74:	465b      	mov	r3, fp
  407a76:	4648      	mov	r0, r9
  407a78:	f002 fa14 	bl	409ea4 <__d2b>
  407a7c:	ea5f 5418 	movs.w	r4, r8, lsr #20
  407a80:	9008      	str	r0, [sp, #32]
  407a82:	f040 8088 	bne.w	407b96 <_dtoa_r+0x1ce>
  407a86:	9d14      	ldr	r5, [sp, #80]	; 0x50
  407a88:	9c15      	ldr	r4, [sp, #84]	; 0x54
  407a8a:	442c      	add	r4, r5
  407a8c:	f204 4332 	addw	r3, r4, #1074	; 0x432
  407a90:	2b20      	cmp	r3, #32
  407a92:	f340 8291 	ble.w	407fb8 <_dtoa_r+0x5f0>
  407a96:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
  407a9a:	f204 4012 	addw	r0, r4, #1042	; 0x412
  407a9e:	fa08 f803 	lsl.w	r8, r8, r3
  407aa2:	fa2a f000 	lsr.w	r0, sl, r0
  407aa6:	ea40 0008 	orr.w	r0, r0, r8
  407aaa:	f7fc fdc5 	bl	404638 <__aeabi_ui2d>
  407aae:	2301      	movs	r3, #1
  407ab0:	3c01      	subs	r4, #1
  407ab2:	f1a1 71f8 	sub.w	r1, r1, #32505856	; 0x1f00000
  407ab6:	9310      	str	r3, [sp, #64]	; 0x40
  407ab8:	2200      	movs	r2, #0
  407aba:	4b78      	ldr	r3, [pc, #480]	; (407c9c <_dtoa_r+0x2d4>)
  407abc:	f7fc fc7e 	bl	4043bc <__aeabi_dsub>
  407ac0:	a36d      	add	r3, pc, #436	; (adr r3, 407c78 <_dtoa_r+0x2b0>)
  407ac2:	e9d3 2300 	ldrd	r2, r3, [r3]
  407ac6:	f7fc fe2d 	bl	404724 <__aeabi_dmul>
  407aca:	a36d      	add	r3, pc, #436	; (adr r3, 407c80 <_dtoa_r+0x2b8>)
  407acc:	e9d3 2300 	ldrd	r2, r3, [r3]
  407ad0:	f7fc fc76 	bl	4043c0 <__adddf3>
  407ad4:	4606      	mov	r6, r0
  407ad6:	4620      	mov	r0, r4
  407ad8:	460f      	mov	r7, r1
  407ada:	f7fc fdbd 	bl	404658 <__aeabi_i2d>
  407ade:	a36a      	add	r3, pc, #424	; (adr r3, 407c88 <_dtoa_r+0x2c0>)
  407ae0:	e9d3 2300 	ldrd	r2, r3, [r3]
  407ae4:	f7fc fe1e 	bl	404724 <__aeabi_dmul>
  407ae8:	4602      	mov	r2, r0
  407aea:	460b      	mov	r3, r1
  407aec:	4630      	mov	r0, r6
  407aee:	4639      	mov	r1, r7
  407af0:	f7fc fc66 	bl	4043c0 <__adddf3>
  407af4:	4606      	mov	r6, r0
  407af6:	460f      	mov	r7, r1
  407af8:	f002 fea2 	bl	40a840 <__aeabi_d2iz>
  407afc:	2200      	movs	r2, #0
  407afe:	9004      	str	r0, [sp, #16]
  407b00:	2300      	movs	r3, #0
  407b02:	4630      	mov	r0, r6
  407b04:	4639      	mov	r1, r7
  407b06:	f7fd f87f 	bl	404c08 <__aeabi_dcmplt>
  407b0a:	2800      	cmp	r0, #0
  407b0c:	f040 8230 	bne.w	407f70 <_dtoa_r+0x5a8>
  407b10:	9e04      	ldr	r6, [sp, #16]
  407b12:	2e16      	cmp	r6, #22
  407b14:	f200 8229 	bhi.w	407f6a <_dtoa_r+0x5a2>
  407b18:	4b61      	ldr	r3, [pc, #388]	; (407ca0 <_dtoa_r+0x2d8>)
  407b1a:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
  407b1e:	e9d3 0100 	ldrd	r0, r1, [r3]
  407b22:	4652      	mov	r2, sl
  407b24:	465b      	mov	r3, fp
  407b26:	f7fd f88d 	bl	404c44 <__aeabi_dcmpgt>
  407b2a:	2800      	cmp	r0, #0
  407b2c:	f000 8249 	beq.w	407fc2 <_dtoa_r+0x5fa>
  407b30:	1e73      	subs	r3, r6, #1
  407b32:	9304      	str	r3, [sp, #16]
  407b34:	2300      	movs	r3, #0
  407b36:	930c      	str	r3, [sp, #48]	; 0x30
  407b38:	1b2c      	subs	r4, r5, r4
  407b3a:	1e63      	subs	r3, r4, #1
  407b3c:	9302      	str	r3, [sp, #8]
  407b3e:	f100 8232 	bmi.w	407fa6 <_dtoa_r+0x5de>
  407b42:	2300      	movs	r3, #0
  407b44:	9305      	str	r3, [sp, #20]
  407b46:	9b04      	ldr	r3, [sp, #16]
  407b48:	2b00      	cmp	r3, #0
  407b4a:	f2c0 8223 	blt.w	407f94 <_dtoa_r+0x5cc>
  407b4e:	9a02      	ldr	r2, [sp, #8]
  407b50:	930b      	str	r3, [sp, #44]	; 0x2c
  407b52:	4611      	mov	r1, r2
  407b54:	4419      	add	r1, r3
  407b56:	2300      	movs	r3, #0
  407b58:	9102      	str	r1, [sp, #8]
  407b5a:	930a      	str	r3, [sp, #40]	; 0x28
  407b5c:	9b20      	ldr	r3, [sp, #128]	; 0x80
  407b5e:	2b09      	cmp	r3, #9
  407b60:	d829      	bhi.n	407bb6 <_dtoa_r+0x1ee>
  407b62:	2b05      	cmp	r3, #5
  407b64:	f340 8658 	ble.w	408818 <_dtoa_r+0xe50>
  407b68:	3b04      	subs	r3, #4
  407b6a:	9320      	str	r3, [sp, #128]	; 0x80
  407b6c:	2500      	movs	r5, #0
  407b6e:	9b20      	ldr	r3, [sp, #128]	; 0x80
  407b70:	3b02      	subs	r3, #2
  407b72:	2b03      	cmp	r3, #3
  407b74:	f200 8635 	bhi.w	4087e2 <_dtoa_r+0xe1a>
  407b78:	e8df f013 	tbh	[pc, r3, lsl #1]
  407b7c:	0228032c 	.word	0x0228032c
  407b80:	04590337 	.word	0x04590337
  407b84:	4b44      	ldr	r3, [pc, #272]	; (407c98 <_dtoa_r+0x2d0>)
  407b86:	4a47      	ldr	r2, [pc, #284]	; (407ca4 <_dtoa_r+0x2dc>)
  407b88:	f3c8 0013 	ubfx	r0, r8, #0, #20
  407b8c:	2800      	cmp	r0, #0
  407b8e:	bf14      	ite	ne
  407b90:	4618      	movne	r0, r3
  407b92:	4610      	moveq	r0, r2
  407b94:	e755      	b.n	407a42 <_dtoa_r+0x7a>
  407b96:	f3cb 0313 	ubfx	r3, fp, #0, #20
  407b9a:	f043 517f 	orr.w	r1, r3, #1069547520	; 0x3fc00000
  407b9e:	9510      	str	r5, [sp, #64]	; 0x40
  407ba0:	4650      	mov	r0, sl
  407ba2:	f2a4 34ff 	subw	r4, r4, #1023	; 0x3ff
  407ba6:	f441 1140 	orr.w	r1, r1, #3145728	; 0x300000
  407baa:	9d14      	ldr	r5, [sp, #80]	; 0x50
  407bac:	e784      	b.n	407ab8 <_dtoa_r+0xf0>
  407bae:	483e      	ldr	r0, [pc, #248]	; (407ca8 <_dtoa_r+0x2e0>)
  407bb0:	e73b      	b.n	407a2a <_dtoa_r+0x62>
  407bb2:	1cc3      	adds	r3, r0, #3
  407bb4:	e74e      	b.n	407a54 <_dtoa_r+0x8c>
  407bb6:	2100      	movs	r1, #0
  407bb8:	f8c9 1044 	str.w	r1, [r9, #68]	; 0x44
  407bbc:	4648      	mov	r0, r9
  407bbe:	9120      	str	r1, [sp, #128]	; 0x80
  407bc0:	f001 febe 	bl	409940 <_Balloc>
  407bc4:	f04f 33ff 	mov.w	r3, #4294967295
  407bc8:	9306      	str	r3, [sp, #24]
  407bca:	9a20      	ldr	r2, [sp, #128]	; 0x80
  407bcc:	930d      	str	r3, [sp, #52]	; 0x34
  407bce:	2301      	movs	r3, #1
  407bd0:	9007      	str	r0, [sp, #28]
  407bd2:	9221      	str	r2, [sp, #132]	; 0x84
  407bd4:	f8c9 0040 	str.w	r0, [r9, #64]	; 0x40
  407bd8:	9309      	str	r3, [sp, #36]	; 0x24
  407bda:	9b15      	ldr	r3, [sp, #84]	; 0x54
  407bdc:	2b00      	cmp	r3, #0
  407bde:	f2c0 80d1 	blt.w	407d84 <_dtoa_r+0x3bc>
  407be2:	9a04      	ldr	r2, [sp, #16]
  407be4:	2a0e      	cmp	r2, #14
  407be6:	f300 80cd 	bgt.w	407d84 <_dtoa_r+0x3bc>
  407bea:	4b2d      	ldr	r3, [pc, #180]	; (407ca0 <_dtoa_r+0x2d8>)
  407bec:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  407bf0:	e9d3 3400 	ldrd	r3, r4, [r3]
  407bf4:	e9cd 3402 	strd	r3, r4, [sp, #8]
  407bf8:	9b21      	ldr	r3, [sp, #132]	; 0x84
  407bfa:	2b00      	cmp	r3, #0
  407bfc:	f2c0 8300 	blt.w	408200 <_dtoa_r+0x838>
  407c00:	4656      	mov	r6, sl
  407c02:	465f      	mov	r7, fp
  407c04:	4650      	mov	r0, sl
  407c06:	4659      	mov	r1, fp
  407c08:	e9dd ab02 	ldrd	sl, fp, [sp, #8]
  407c0c:	4652      	mov	r2, sl
  407c0e:	465b      	mov	r3, fp
  407c10:	f7fc feb2 	bl	404978 <__aeabi_ddiv>
  407c14:	f002 fe14 	bl	40a840 <__aeabi_d2iz>
  407c18:	4604      	mov	r4, r0
  407c1a:	f7fc fd1d 	bl	404658 <__aeabi_i2d>
  407c1e:	4652      	mov	r2, sl
  407c20:	465b      	mov	r3, fp
  407c22:	f7fc fd7f 	bl	404724 <__aeabi_dmul>
  407c26:	460b      	mov	r3, r1
  407c28:	4602      	mov	r2, r0
  407c2a:	4639      	mov	r1, r7
  407c2c:	4630      	mov	r0, r6
  407c2e:	f7fc fbc5 	bl	4043bc <__aeabi_dsub>
  407c32:	9d07      	ldr	r5, [sp, #28]
  407c34:	f104 0330 	add.w	r3, r4, #48	; 0x30
  407c38:	702b      	strb	r3, [r5, #0]
  407c3a:	9b06      	ldr	r3, [sp, #24]
  407c3c:	2b01      	cmp	r3, #1
  407c3e:	4606      	mov	r6, r0
  407c40:	460f      	mov	r7, r1
  407c42:	f105 0501 	add.w	r5, r5, #1
  407c46:	d062      	beq.n	407d0e <_dtoa_r+0x346>
  407c48:	2200      	movs	r2, #0
  407c4a:	4b18      	ldr	r3, [pc, #96]	; (407cac <_dtoa_r+0x2e4>)
  407c4c:	f7fc fd6a 	bl	404724 <__aeabi_dmul>
  407c50:	2200      	movs	r2, #0
  407c52:	2300      	movs	r3, #0
  407c54:	4606      	mov	r6, r0
  407c56:	460f      	mov	r7, r1
  407c58:	f7fc ffcc 	bl	404bf4 <__aeabi_dcmpeq>
  407c5c:	2800      	cmp	r0, #0
  407c5e:	d17e      	bne.n	407d5e <_dtoa_r+0x396>
  407c60:	f8cd 9014 	str.w	r9, [sp, #20]
  407c64:	f8dd a018 	ldr.w	sl, [sp, #24]
  407c68:	f8dd b01c 	ldr.w	fp, [sp, #28]
  407c6c:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
  407c70:	e029      	b.n	407cc6 <_dtoa_r+0x2fe>
  407c72:	bf00      	nop
  407c74:	f3af 8000 	nop.w
  407c78:	636f4361 	.word	0x636f4361
  407c7c:	3fd287a7 	.word	0x3fd287a7
  407c80:	8b60c8b3 	.word	0x8b60c8b3
  407c84:	3fc68a28 	.word	0x3fc68a28
  407c88:	509f79fb 	.word	0x509f79fb
  407c8c:	3fd34413 	.word	0x3fd34413
  407c90:	7ff00000 	.word	0x7ff00000
  407c94:	0040ae49 	.word	0x0040ae49
  407c98:	0040ae68 	.word	0x0040ae68
  407c9c:	3ff80000 	.word	0x3ff80000
  407ca0:	0040ae78 	.word	0x0040ae78
  407ca4:	0040ae5c 	.word	0x0040ae5c
  407ca8:	0040ae48 	.word	0x0040ae48
  407cac:	40240000 	.word	0x40240000
  407cb0:	f7fc fd38 	bl	404724 <__aeabi_dmul>
  407cb4:	2200      	movs	r2, #0
  407cb6:	2300      	movs	r3, #0
  407cb8:	4606      	mov	r6, r0
  407cba:	460f      	mov	r7, r1
  407cbc:	f7fc ff9a 	bl	404bf4 <__aeabi_dcmpeq>
  407cc0:	2800      	cmp	r0, #0
  407cc2:	f040 83b7 	bne.w	408434 <_dtoa_r+0xa6c>
  407cc6:	4642      	mov	r2, r8
  407cc8:	464b      	mov	r3, r9
  407cca:	4630      	mov	r0, r6
  407ccc:	4639      	mov	r1, r7
  407cce:	f7fc fe53 	bl	404978 <__aeabi_ddiv>
  407cd2:	f002 fdb5 	bl	40a840 <__aeabi_d2iz>
  407cd6:	4604      	mov	r4, r0
  407cd8:	f7fc fcbe 	bl	404658 <__aeabi_i2d>
  407cdc:	4642      	mov	r2, r8
  407cde:	464b      	mov	r3, r9
  407ce0:	f7fc fd20 	bl	404724 <__aeabi_dmul>
  407ce4:	4602      	mov	r2, r0
  407ce6:	460b      	mov	r3, r1
  407ce8:	4630      	mov	r0, r6
  407cea:	4639      	mov	r1, r7
  407cec:	f7fc fb66 	bl	4043bc <__aeabi_dsub>
  407cf0:	f104 0e30 	add.w	lr, r4, #48	; 0x30
  407cf4:	f805 eb01 	strb.w	lr, [r5], #1
  407cf8:	ebcb 0e05 	rsb	lr, fp, r5
  407cfc:	45d6      	cmp	lr, sl
  407cfe:	4606      	mov	r6, r0
  407d00:	460f      	mov	r7, r1
  407d02:	f04f 0200 	mov.w	r2, #0
  407d06:	4bb0      	ldr	r3, [pc, #704]	; (407fc8 <_dtoa_r+0x600>)
  407d08:	d1d2      	bne.n	407cb0 <_dtoa_r+0x2e8>
  407d0a:	f8dd 9014 	ldr.w	r9, [sp, #20]
  407d0e:	4632      	mov	r2, r6
  407d10:	463b      	mov	r3, r7
  407d12:	4630      	mov	r0, r6
  407d14:	4639      	mov	r1, r7
  407d16:	f7fc fb53 	bl	4043c0 <__adddf3>
  407d1a:	4606      	mov	r6, r0
  407d1c:	460f      	mov	r7, r1
  407d1e:	4602      	mov	r2, r0
  407d20:	460b      	mov	r3, r1
  407d22:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  407d26:	f7fc ff6f 	bl	404c08 <__aeabi_dcmplt>
  407d2a:	b940      	cbnz	r0, 407d3e <_dtoa_r+0x376>
  407d2c:	4632      	mov	r2, r6
  407d2e:	463b      	mov	r3, r7
  407d30:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  407d34:	f7fc ff5e 	bl	404bf4 <__aeabi_dcmpeq>
  407d38:	b188      	cbz	r0, 407d5e <_dtoa_r+0x396>
  407d3a:	07e3      	lsls	r3, r4, #31
  407d3c:	d50f      	bpl.n	407d5e <_dtoa_r+0x396>
  407d3e:	f815 4c01 	ldrb.w	r4, [r5, #-1]
  407d42:	9a07      	ldr	r2, [sp, #28]
  407d44:	1e6b      	subs	r3, r5, #1
  407d46:	e004      	b.n	407d52 <_dtoa_r+0x38a>
  407d48:	429a      	cmp	r2, r3
  407d4a:	f000 842c 	beq.w	4085a6 <_dtoa_r+0xbde>
  407d4e:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
  407d52:	2c39      	cmp	r4, #57	; 0x39
  407d54:	f103 0501 	add.w	r5, r3, #1
  407d58:	d0f6      	beq.n	407d48 <_dtoa_r+0x380>
  407d5a:	3401      	adds	r4, #1
  407d5c:	701c      	strb	r4, [r3, #0]
  407d5e:	9908      	ldr	r1, [sp, #32]
  407d60:	4648      	mov	r0, r9
  407d62:	f001 fe13 	bl	40998c <_Bfree>
  407d66:	2200      	movs	r2, #0
  407d68:	9b04      	ldr	r3, [sp, #16]
  407d6a:	702a      	strb	r2, [r5, #0]
  407d6c:	9a22      	ldr	r2, [sp, #136]	; 0x88
  407d6e:	3301      	adds	r3, #1
  407d70:	6013      	str	r3, [r2, #0]
  407d72:	9b24      	ldr	r3, [sp, #144]	; 0x90
  407d74:	2b00      	cmp	r3, #0
  407d76:	f000 83a7 	beq.w	4084c8 <_dtoa_r+0xb00>
  407d7a:	9807      	ldr	r0, [sp, #28]
  407d7c:	601d      	str	r5, [r3, #0]
  407d7e:	b017      	add	sp, #92	; 0x5c
  407d80:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  407d84:	9a09      	ldr	r2, [sp, #36]	; 0x24
  407d86:	2a00      	cmp	r2, #0
  407d88:	f000 8112 	beq.w	407fb0 <_dtoa_r+0x5e8>
  407d8c:	9a20      	ldr	r2, [sp, #128]	; 0x80
  407d8e:	2a01      	cmp	r2, #1
  407d90:	f340 8258 	ble.w	408244 <_dtoa_r+0x87c>
  407d94:	9b06      	ldr	r3, [sp, #24]
  407d96:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  407d98:	1e5f      	subs	r7, r3, #1
  407d9a:	42ba      	cmp	r2, r7
  407d9c:	f2c0 8397 	blt.w	4084ce <_dtoa_r+0xb06>
  407da0:	1bd7      	subs	r7, r2, r7
  407da2:	9b06      	ldr	r3, [sp, #24]
  407da4:	2b00      	cmp	r3, #0
  407da6:	f2c0 848a 	blt.w	4086be <_dtoa_r+0xcf6>
  407daa:	9d05      	ldr	r5, [sp, #20]
  407dac:	9b06      	ldr	r3, [sp, #24]
  407dae:	9a05      	ldr	r2, [sp, #20]
  407db0:	441a      	add	r2, r3
  407db2:	9205      	str	r2, [sp, #20]
  407db4:	9a02      	ldr	r2, [sp, #8]
  407db6:	2101      	movs	r1, #1
  407db8:	441a      	add	r2, r3
  407dba:	4648      	mov	r0, r9
  407dbc:	9202      	str	r2, [sp, #8]
  407dbe:	f001 fe7d 	bl	409abc <__i2b>
  407dc2:	4606      	mov	r6, r0
  407dc4:	b165      	cbz	r5, 407de0 <_dtoa_r+0x418>
  407dc6:	9902      	ldr	r1, [sp, #8]
  407dc8:	2900      	cmp	r1, #0
  407dca:	460b      	mov	r3, r1
  407dcc:	dd08      	ble.n	407de0 <_dtoa_r+0x418>
  407dce:	42a9      	cmp	r1, r5
  407dd0:	9a05      	ldr	r2, [sp, #20]
  407dd2:	bfa8      	it	ge
  407dd4:	462b      	movge	r3, r5
  407dd6:	1ad2      	subs	r2, r2, r3
  407dd8:	1aed      	subs	r5, r5, r3
  407dda:	1acb      	subs	r3, r1, r3
  407ddc:	9205      	str	r2, [sp, #20]
  407dde:	9302      	str	r3, [sp, #8]
  407de0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  407de2:	2b00      	cmp	r3, #0
  407de4:	f340 82fc 	ble.w	4083e0 <_dtoa_r+0xa18>
  407de8:	9a09      	ldr	r2, [sp, #36]	; 0x24
  407dea:	2a00      	cmp	r2, #0
  407dec:	f000 8201 	beq.w	4081f2 <_dtoa_r+0x82a>
  407df0:	2f00      	cmp	r7, #0
  407df2:	f000 81fe 	beq.w	4081f2 <_dtoa_r+0x82a>
  407df6:	4631      	mov	r1, r6
  407df8:	463a      	mov	r2, r7
  407dfa:	4648      	mov	r0, r9
  407dfc:	f001 ff00 	bl	409c00 <__pow5mult>
  407e00:	f8dd 8020 	ldr.w	r8, [sp, #32]
  407e04:	4601      	mov	r1, r0
  407e06:	4642      	mov	r2, r8
  407e08:	4606      	mov	r6, r0
  407e0a:	4648      	mov	r0, r9
  407e0c:	f001 fe60 	bl	409ad0 <__multiply>
  407e10:	4641      	mov	r1, r8
  407e12:	4604      	mov	r4, r0
  407e14:	4648      	mov	r0, r9
  407e16:	f001 fdb9 	bl	40998c <_Bfree>
  407e1a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  407e1c:	1bdb      	subs	r3, r3, r7
  407e1e:	930a      	str	r3, [sp, #40]	; 0x28
  407e20:	f040 81e6 	bne.w	4081f0 <_dtoa_r+0x828>
  407e24:	2101      	movs	r1, #1
  407e26:	4648      	mov	r0, r9
  407e28:	f001 fe48 	bl	409abc <__i2b>
  407e2c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  407e2e:	4680      	mov	r8, r0
  407e30:	2b00      	cmp	r3, #0
  407e32:	f000 8219 	beq.w	408268 <_dtoa_r+0x8a0>
  407e36:	4601      	mov	r1, r0
  407e38:	461a      	mov	r2, r3
  407e3a:	4648      	mov	r0, r9
  407e3c:	f001 fee0 	bl	409c00 <__pow5mult>
  407e40:	9b20      	ldr	r3, [sp, #128]	; 0x80
  407e42:	2b01      	cmp	r3, #1
  407e44:	4680      	mov	r8, r0
  407e46:	f340 82f8 	ble.w	40843a <_dtoa_r+0xa72>
  407e4a:	2700      	movs	r7, #0
  407e4c:	f8d8 3010 	ldr.w	r3, [r8, #16]
  407e50:	eb08 0383 	add.w	r3, r8, r3, lsl #2
  407e54:	6918      	ldr	r0, [r3, #16]
  407e56:	f001 fde3 	bl	409a20 <__hi0bits>
  407e5a:	f1c0 0020 	rsb	r0, r0, #32
  407e5e:	9a02      	ldr	r2, [sp, #8]
  407e60:	4410      	add	r0, r2
  407e62:	f010 001f 	ands.w	r0, r0, #31
  407e66:	f000 81f6 	beq.w	408256 <_dtoa_r+0x88e>
  407e6a:	f1c0 0320 	rsb	r3, r0, #32
  407e6e:	2b04      	cmp	r3, #4
  407e70:	f340 84ca 	ble.w	408808 <_dtoa_r+0xe40>
  407e74:	9b05      	ldr	r3, [sp, #20]
  407e76:	f1c0 001c 	rsb	r0, r0, #28
  407e7a:	4403      	add	r3, r0
  407e7c:	9305      	str	r3, [sp, #20]
  407e7e:	4613      	mov	r3, r2
  407e80:	4403      	add	r3, r0
  407e82:	4405      	add	r5, r0
  407e84:	9302      	str	r3, [sp, #8]
  407e86:	9b05      	ldr	r3, [sp, #20]
  407e88:	2b00      	cmp	r3, #0
  407e8a:	dd05      	ble.n	407e98 <_dtoa_r+0x4d0>
  407e8c:	4621      	mov	r1, r4
  407e8e:	461a      	mov	r2, r3
  407e90:	4648      	mov	r0, r9
  407e92:	f001 ff05 	bl	409ca0 <__lshift>
  407e96:	4604      	mov	r4, r0
  407e98:	9b02      	ldr	r3, [sp, #8]
  407e9a:	2b00      	cmp	r3, #0
  407e9c:	dd05      	ble.n	407eaa <_dtoa_r+0x4e2>
  407e9e:	4641      	mov	r1, r8
  407ea0:	461a      	mov	r2, r3
  407ea2:	4648      	mov	r0, r9
  407ea4:	f001 fefc 	bl	409ca0 <__lshift>
  407ea8:	4680      	mov	r8, r0
  407eaa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  407eac:	2b00      	cmp	r3, #0
  407eae:	f040 827c 	bne.w	4083aa <_dtoa_r+0x9e2>
  407eb2:	9b06      	ldr	r3, [sp, #24]
  407eb4:	2b00      	cmp	r3, #0
  407eb6:	f340 8295 	ble.w	4083e4 <_dtoa_r+0xa1c>
  407eba:	9b09      	ldr	r3, [sp, #36]	; 0x24
  407ebc:	2b00      	cmp	r3, #0
  407ebe:	f040 81f5 	bne.w	4082ac <_dtoa_r+0x8e4>
  407ec2:	f8dd b01c 	ldr.w	fp, [sp, #28]
  407ec6:	9f06      	ldr	r7, [sp, #24]
  407ec8:	465d      	mov	r5, fp
  407eca:	e002      	b.n	407ed2 <_dtoa_r+0x50a>
  407ecc:	f001 fd68 	bl	4099a0 <__multadd>
  407ed0:	4604      	mov	r4, r0
  407ed2:	4641      	mov	r1, r8
  407ed4:	4620      	mov	r0, r4
  407ed6:	f7ff fce3 	bl	4078a0 <quorem>
  407eda:	f100 0a30 	add.w	sl, r0, #48	; 0x30
  407ede:	f805 ab01 	strb.w	sl, [r5], #1
  407ee2:	ebcb 0305 	rsb	r3, fp, r5
  407ee6:	42bb      	cmp	r3, r7
  407ee8:	f04f 020a 	mov.w	r2, #10
  407eec:	f04f 0300 	mov.w	r3, #0
  407ef0:	4621      	mov	r1, r4
  407ef2:	4648      	mov	r0, r9
  407ef4:	dbea      	blt.n	407ecc <_dtoa_r+0x504>
  407ef6:	9b07      	ldr	r3, [sp, #28]
  407ef8:	9a06      	ldr	r2, [sp, #24]
  407efa:	2a01      	cmp	r2, #1
  407efc:	bfac      	ite	ge
  407efe:	189b      	addge	r3, r3, r2
  407f00:	3301      	addlt	r3, #1
  407f02:	461d      	mov	r5, r3
  407f04:	f04f 0b00 	mov.w	fp, #0
  407f08:	4621      	mov	r1, r4
  407f0a:	2201      	movs	r2, #1
  407f0c:	4648      	mov	r0, r9
  407f0e:	f001 fec7 	bl	409ca0 <__lshift>
  407f12:	4641      	mov	r1, r8
  407f14:	9008      	str	r0, [sp, #32]
  407f16:	f001 ff1b 	bl	409d50 <__mcmp>
  407f1a:	2800      	cmp	r0, #0
  407f1c:	f340 830d 	ble.w	40853a <_dtoa_r+0xb72>
  407f20:	f815 2c01 	ldrb.w	r2, [r5, #-1]
  407f24:	9907      	ldr	r1, [sp, #28]
  407f26:	1e6b      	subs	r3, r5, #1
  407f28:	e004      	b.n	407f34 <_dtoa_r+0x56c>
  407f2a:	428b      	cmp	r3, r1
  407f2c:	f000 8278 	beq.w	408420 <_dtoa_r+0xa58>
  407f30:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
  407f34:	2a39      	cmp	r2, #57	; 0x39
  407f36:	f103 0501 	add.w	r5, r3, #1
  407f3a:	d0f6      	beq.n	407f2a <_dtoa_r+0x562>
  407f3c:	3201      	adds	r2, #1
  407f3e:	701a      	strb	r2, [r3, #0]
  407f40:	4641      	mov	r1, r8
  407f42:	4648      	mov	r0, r9
  407f44:	f001 fd22 	bl	40998c <_Bfree>
  407f48:	2e00      	cmp	r6, #0
  407f4a:	f43f af08 	beq.w	407d5e <_dtoa_r+0x396>
  407f4e:	f1bb 0f00 	cmp.w	fp, #0
  407f52:	d005      	beq.n	407f60 <_dtoa_r+0x598>
  407f54:	45b3      	cmp	fp, r6
  407f56:	d003      	beq.n	407f60 <_dtoa_r+0x598>
  407f58:	4659      	mov	r1, fp
  407f5a:	4648      	mov	r0, r9
  407f5c:	f001 fd16 	bl	40998c <_Bfree>
  407f60:	4631      	mov	r1, r6
  407f62:	4648      	mov	r0, r9
  407f64:	f001 fd12 	bl	40998c <_Bfree>
  407f68:	e6f9      	b.n	407d5e <_dtoa_r+0x396>
  407f6a:	2301      	movs	r3, #1
  407f6c:	930c      	str	r3, [sp, #48]	; 0x30
  407f6e:	e5e3      	b.n	407b38 <_dtoa_r+0x170>
  407f70:	f8dd 8010 	ldr.w	r8, [sp, #16]
  407f74:	4640      	mov	r0, r8
  407f76:	f7fc fb6f 	bl	404658 <__aeabi_i2d>
  407f7a:	4602      	mov	r2, r0
  407f7c:	460b      	mov	r3, r1
  407f7e:	4630      	mov	r0, r6
  407f80:	4639      	mov	r1, r7
  407f82:	f7fc fe37 	bl	404bf4 <__aeabi_dcmpeq>
  407f86:	2800      	cmp	r0, #0
  407f88:	f47f adc2 	bne.w	407b10 <_dtoa_r+0x148>
  407f8c:	f108 33ff 	add.w	r3, r8, #4294967295
  407f90:	9304      	str	r3, [sp, #16]
  407f92:	e5bd      	b.n	407b10 <_dtoa_r+0x148>
  407f94:	9a05      	ldr	r2, [sp, #20]
  407f96:	9b04      	ldr	r3, [sp, #16]
  407f98:	1ad2      	subs	r2, r2, r3
  407f9a:	425b      	negs	r3, r3
  407f9c:	930a      	str	r3, [sp, #40]	; 0x28
  407f9e:	2300      	movs	r3, #0
  407fa0:	9205      	str	r2, [sp, #20]
  407fa2:	930b      	str	r3, [sp, #44]	; 0x2c
  407fa4:	e5da      	b.n	407b5c <_dtoa_r+0x194>
  407fa6:	425b      	negs	r3, r3
  407fa8:	9305      	str	r3, [sp, #20]
  407faa:	2300      	movs	r3, #0
  407fac:	9302      	str	r3, [sp, #8]
  407fae:	e5ca      	b.n	407b46 <_dtoa_r+0x17e>
  407fb0:	9f0a      	ldr	r7, [sp, #40]	; 0x28
  407fb2:	9d05      	ldr	r5, [sp, #20]
  407fb4:	9e09      	ldr	r6, [sp, #36]	; 0x24
  407fb6:	e705      	b.n	407dc4 <_dtoa_r+0x3fc>
  407fb8:	f1c3 0820 	rsb	r8, r3, #32
  407fbc:	fa0a f008 	lsl.w	r0, sl, r8
  407fc0:	e573      	b.n	407aaa <_dtoa_r+0xe2>
  407fc2:	900c      	str	r0, [sp, #48]	; 0x30
  407fc4:	e5b8      	b.n	407b38 <_dtoa_r+0x170>
  407fc6:	bf00      	nop
  407fc8:	40240000 	.word	0x40240000
  407fcc:	2300      	movs	r3, #0
  407fce:	9309      	str	r3, [sp, #36]	; 0x24
  407fd0:	9b04      	ldr	r3, [sp, #16]
  407fd2:	9a21      	ldr	r2, [sp, #132]	; 0x84
  407fd4:	4413      	add	r3, r2
  407fd6:	930d      	str	r3, [sp, #52]	; 0x34
  407fd8:	3301      	adds	r3, #1
  407fda:	2b00      	cmp	r3, #0
  407fdc:	9306      	str	r3, [sp, #24]
  407fde:	f340 8283 	ble.w	4084e8 <_dtoa_r+0xb20>
  407fe2:	9c06      	ldr	r4, [sp, #24]
  407fe4:	4626      	mov	r6, r4
  407fe6:	2100      	movs	r1, #0
  407fe8:	2e17      	cmp	r6, #23
  407fea:	f8c9 1044 	str.w	r1, [r9, #68]	; 0x44
  407fee:	d90b      	bls.n	408008 <_dtoa_r+0x640>
  407ff0:	2201      	movs	r2, #1
  407ff2:	2304      	movs	r3, #4
  407ff4:	005b      	lsls	r3, r3, #1
  407ff6:	f103 0014 	add.w	r0, r3, #20
  407ffa:	42b0      	cmp	r0, r6
  407ffc:	4611      	mov	r1, r2
  407ffe:	f102 0201 	add.w	r2, r2, #1
  408002:	d9f7      	bls.n	407ff4 <_dtoa_r+0x62c>
  408004:	f8c9 1044 	str.w	r1, [r9, #68]	; 0x44
  408008:	4648      	mov	r0, r9
  40800a:	f001 fc99 	bl	409940 <_Balloc>
  40800e:	2c0e      	cmp	r4, #14
  408010:	9007      	str	r0, [sp, #28]
  408012:	f8c9 0040 	str.w	r0, [r9, #64]	; 0x40
  408016:	f63f ade0 	bhi.w	407bda <_dtoa_r+0x212>
  40801a:	2d00      	cmp	r5, #0
  40801c:	f43f addd 	beq.w	407bda <_dtoa_r+0x212>
  408020:	9904      	ldr	r1, [sp, #16]
  408022:	4657      	mov	r7, sl
  408024:	46d8      	mov	r8, fp
  408026:	2900      	cmp	r1, #0
  408028:	e9cd 780e 	strd	r7, r8, [sp, #56]	; 0x38
  40802c:	f340 8292 	ble.w	408554 <_dtoa_r+0xb8c>
  408030:	4b91      	ldr	r3, [pc, #580]	; (408278 <_dtoa_r+0x8b0>)
  408032:	f001 020f 	and.w	r2, r1, #15
  408036:	110e      	asrs	r6, r1, #4
  408038:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  40803c:	06f0      	lsls	r0, r6, #27
  40803e:	e9d3 4500 	ldrd	r4, r5, [r3]
  408042:	f140 824c 	bpl.w	4084de <_dtoa_r+0xb16>
  408046:	4b8d      	ldr	r3, [pc, #564]	; (40827c <_dtoa_r+0x8b4>)
  408048:	4650      	mov	r0, sl
  40804a:	4659      	mov	r1, fp
  40804c:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
  408050:	f7fc fc92 	bl	404978 <__aeabi_ddiv>
  408054:	f006 060f 	and.w	r6, r6, #15
  408058:	4682      	mov	sl, r0
  40805a:	468b      	mov	fp, r1
  40805c:	f04f 0803 	mov.w	r8, #3
  408060:	b186      	cbz	r6, 408084 <_dtoa_r+0x6bc>
  408062:	4f86      	ldr	r7, [pc, #536]	; (40827c <_dtoa_r+0x8b4>)
  408064:	07f1      	lsls	r1, r6, #31
  408066:	d509      	bpl.n	40807c <_dtoa_r+0x6b4>
  408068:	4620      	mov	r0, r4
  40806a:	4629      	mov	r1, r5
  40806c:	e9d7 2300 	ldrd	r2, r3, [r7]
  408070:	f7fc fb58 	bl	404724 <__aeabi_dmul>
  408074:	f108 0801 	add.w	r8, r8, #1
  408078:	4604      	mov	r4, r0
  40807a:	460d      	mov	r5, r1
  40807c:	1076      	asrs	r6, r6, #1
  40807e:	f107 0708 	add.w	r7, r7, #8
  408082:	d1ef      	bne.n	408064 <_dtoa_r+0x69c>
  408084:	4622      	mov	r2, r4
  408086:	462b      	mov	r3, r5
  408088:	4650      	mov	r0, sl
  40808a:	4659      	mov	r1, fp
  40808c:	f7fc fc74 	bl	404978 <__aeabi_ddiv>
  408090:	4606      	mov	r6, r0
  408092:	460f      	mov	r7, r1
  408094:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  408096:	b143      	cbz	r3, 4080aa <_dtoa_r+0x6e2>
  408098:	2200      	movs	r2, #0
  40809a:	4b79      	ldr	r3, [pc, #484]	; (408280 <_dtoa_r+0x8b8>)
  40809c:	4630      	mov	r0, r6
  40809e:	4639      	mov	r1, r7
  4080a0:	f7fc fdb2 	bl	404c08 <__aeabi_dcmplt>
  4080a4:	2800      	cmp	r0, #0
  4080a6:	f040 8320 	bne.w	4086ea <_dtoa_r+0xd22>
  4080aa:	4640      	mov	r0, r8
  4080ac:	f7fc fad4 	bl	404658 <__aeabi_i2d>
  4080b0:	4632      	mov	r2, r6
  4080b2:	463b      	mov	r3, r7
  4080b4:	f7fc fb36 	bl	404724 <__aeabi_dmul>
  4080b8:	4b72      	ldr	r3, [pc, #456]	; (408284 <_dtoa_r+0x8bc>)
  4080ba:	2200      	movs	r2, #0
  4080bc:	f7fc f980 	bl	4043c0 <__adddf3>
  4080c0:	9b06      	ldr	r3, [sp, #24]
  4080c2:	4604      	mov	r4, r0
  4080c4:	f1a1 7550 	sub.w	r5, r1, #54525952	; 0x3400000
  4080c8:	2b00      	cmp	r3, #0
  4080ca:	f000 81df 	beq.w	40848c <_dtoa_r+0xac4>
  4080ce:	9b04      	ldr	r3, [sp, #16]
  4080d0:	f8dd 8018 	ldr.w	r8, [sp, #24]
  4080d4:	9311      	str	r3, [sp, #68]	; 0x44
  4080d6:	9b09      	ldr	r3, [sp, #36]	; 0x24
  4080d8:	2b00      	cmp	r3, #0
  4080da:	f000 8297 	beq.w	40860c <_dtoa_r+0xc44>
  4080de:	4b66      	ldr	r3, [pc, #408]	; (408278 <_dtoa_r+0x8b0>)
  4080e0:	4969      	ldr	r1, [pc, #420]	; (408288 <_dtoa_r+0x8c0>)
  4080e2:	eb03 03c8 	add.w	r3, r3, r8, lsl #3
  4080e6:	e953 2302 	ldrd	r2, r3, [r3, #-8]
  4080ea:	2000      	movs	r0, #0
  4080ec:	f7fc fc44 	bl	404978 <__aeabi_ddiv>
  4080f0:	4622      	mov	r2, r4
  4080f2:	462b      	mov	r3, r5
  4080f4:	f7fc f962 	bl	4043bc <__aeabi_dsub>
  4080f8:	4682      	mov	sl, r0
  4080fa:	468b      	mov	fp, r1
  4080fc:	4630      	mov	r0, r6
  4080fe:	4639      	mov	r1, r7
  408100:	f002 fb9e 	bl	40a840 <__aeabi_d2iz>
  408104:	4604      	mov	r4, r0
  408106:	f7fc faa7 	bl	404658 <__aeabi_i2d>
  40810a:	4602      	mov	r2, r0
  40810c:	460b      	mov	r3, r1
  40810e:	4630      	mov	r0, r6
  408110:	4639      	mov	r1, r7
  408112:	f7fc f953 	bl	4043bc <__aeabi_dsub>
  408116:	3430      	adds	r4, #48	; 0x30
  408118:	9d07      	ldr	r5, [sp, #28]
  40811a:	b2e4      	uxtb	r4, r4
  40811c:	4606      	mov	r6, r0
  40811e:	460f      	mov	r7, r1
  408120:	702c      	strb	r4, [r5, #0]
  408122:	4602      	mov	r2, r0
  408124:	460b      	mov	r3, r1
  408126:	4650      	mov	r0, sl
  408128:	4659      	mov	r1, fp
  40812a:	3501      	adds	r5, #1
  40812c:	f7fc fd8a 	bl	404c44 <__aeabi_dcmpgt>
  408130:	2800      	cmp	r0, #0
  408132:	d14c      	bne.n	4081ce <_dtoa_r+0x806>
  408134:	4632      	mov	r2, r6
  408136:	463b      	mov	r3, r7
  408138:	2000      	movs	r0, #0
  40813a:	4951      	ldr	r1, [pc, #324]	; (408280 <_dtoa_r+0x8b8>)
  40813c:	f7fc f93e 	bl	4043bc <__aeabi_dsub>
  408140:	4602      	mov	r2, r0
  408142:	460b      	mov	r3, r1
  408144:	4650      	mov	r0, sl
  408146:	4659      	mov	r1, fp
  408148:	f7fc fd7c 	bl	404c44 <__aeabi_dcmpgt>
  40814c:	2800      	cmp	r0, #0
  40814e:	f040 830d 	bne.w	40876c <_dtoa_r+0xda4>
  408152:	f1b8 0f01 	cmp.w	r8, #1
  408156:	f340 81b3 	ble.w	4084c0 <_dtoa_r+0xaf8>
  40815a:	9b07      	ldr	r3, [sp, #28]
  40815c:	4498      	add	r8, r3
  40815e:	e00d      	b.n	40817c <_dtoa_r+0x7b4>
  408160:	2000      	movs	r0, #0
  408162:	4947      	ldr	r1, [pc, #284]	; (408280 <_dtoa_r+0x8b8>)
  408164:	f7fc f92a 	bl	4043bc <__aeabi_dsub>
  408168:	4652      	mov	r2, sl
  40816a:	465b      	mov	r3, fp
  40816c:	f7fc fd4c 	bl	404c08 <__aeabi_dcmplt>
  408170:	2800      	cmp	r0, #0
  408172:	f040 82fb 	bne.w	40876c <_dtoa_r+0xda4>
  408176:	4545      	cmp	r5, r8
  408178:	f000 81a2 	beq.w	4084c0 <_dtoa_r+0xaf8>
  40817c:	4650      	mov	r0, sl
  40817e:	4659      	mov	r1, fp
  408180:	2200      	movs	r2, #0
  408182:	4b42      	ldr	r3, [pc, #264]	; (40828c <_dtoa_r+0x8c4>)
  408184:	f7fc face 	bl	404724 <__aeabi_dmul>
  408188:	2200      	movs	r2, #0
  40818a:	4b40      	ldr	r3, [pc, #256]	; (40828c <_dtoa_r+0x8c4>)
  40818c:	4682      	mov	sl, r0
  40818e:	468b      	mov	fp, r1
  408190:	4630      	mov	r0, r6
  408192:	4639      	mov	r1, r7
  408194:	f7fc fac6 	bl	404724 <__aeabi_dmul>
  408198:	460f      	mov	r7, r1
  40819a:	4606      	mov	r6, r0
  40819c:	f002 fb50 	bl	40a840 <__aeabi_d2iz>
  4081a0:	4604      	mov	r4, r0
  4081a2:	f7fc fa59 	bl	404658 <__aeabi_i2d>
  4081a6:	4602      	mov	r2, r0
  4081a8:	460b      	mov	r3, r1
  4081aa:	4630      	mov	r0, r6
  4081ac:	4639      	mov	r1, r7
  4081ae:	f7fc f905 	bl	4043bc <__aeabi_dsub>
  4081b2:	3430      	adds	r4, #48	; 0x30
  4081b4:	b2e4      	uxtb	r4, r4
  4081b6:	4652      	mov	r2, sl
  4081b8:	465b      	mov	r3, fp
  4081ba:	f805 4b01 	strb.w	r4, [r5], #1
  4081be:	4606      	mov	r6, r0
  4081c0:	460f      	mov	r7, r1
  4081c2:	f7fc fd21 	bl	404c08 <__aeabi_dcmplt>
  4081c6:	4632      	mov	r2, r6
  4081c8:	463b      	mov	r3, r7
  4081ca:	2800      	cmp	r0, #0
  4081cc:	d0c8      	beq.n	408160 <_dtoa_r+0x798>
  4081ce:	9b11      	ldr	r3, [sp, #68]	; 0x44
  4081d0:	9304      	str	r3, [sp, #16]
  4081d2:	e5c4      	b.n	407d5e <_dtoa_r+0x396>
  4081d4:	2300      	movs	r3, #0
  4081d6:	9309      	str	r3, [sp, #36]	; 0x24
  4081d8:	9b21      	ldr	r3, [sp, #132]	; 0x84
  4081da:	2b00      	cmp	r3, #0
  4081dc:	f340 8189 	ble.w	4084f2 <_dtoa_r+0xb2a>
  4081e0:	461e      	mov	r6, r3
  4081e2:	461c      	mov	r4, r3
  4081e4:	930d      	str	r3, [sp, #52]	; 0x34
  4081e6:	9306      	str	r3, [sp, #24]
  4081e8:	e6fd      	b.n	407fe6 <_dtoa_r+0x61e>
  4081ea:	2301      	movs	r3, #1
  4081ec:	9309      	str	r3, [sp, #36]	; 0x24
  4081ee:	e7f3      	b.n	4081d8 <_dtoa_r+0x810>
  4081f0:	9408      	str	r4, [sp, #32]
  4081f2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  4081f4:	9908      	ldr	r1, [sp, #32]
  4081f6:	4648      	mov	r0, r9
  4081f8:	f001 fd02 	bl	409c00 <__pow5mult>
  4081fc:	4604      	mov	r4, r0
  4081fe:	e611      	b.n	407e24 <_dtoa_r+0x45c>
  408200:	9b06      	ldr	r3, [sp, #24]
  408202:	2b00      	cmp	r3, #0
  408204:	f73f acfc 	bgt.w	407c00 <_dtoa_r+0x238>
  408208:	f040 82da 	bne.w	4087c0 <_dtoa_r+0xdf8>
  40820c:	2200      	movs	r2, #0
  40820e:	4b20      	ldr	r3, [pc, #128]	; (408290 <_dtoa_r+0x8c8>)
  408210:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  408214:	f7fc fa86 	bl	404724 <__aeabi_dmul>
  408218:	4652      	mov	r2, sl
  40821a:	465b      	mov	r3, fp
  40821c:	f7fc fd08 	bl	404c30 <__aeabi_dcmpge>
  408220:	f8dd 8018 	ldr.w	r8, [sp, #24]
  408224:	4646      	mov	r6, r8
  408226:	2800      	cmp	r0, #0
  408228:	f000 80f2 	beq.w	408410 <_dtoa_r+0xa48>
  40822c:	9b21      	ldr	r3, [sp, #132]	; 0x84
  40822e:	9d07      	ldr	r5, [sp, #28]
  408230:	43db      	mvns	r3, r3
  408232:	9304      	str	r3, [sp, #16]
  408234:	4641      	mov	r1, r8
  408236:	4648      	mov	r0, r9
  408238:	f001 fba8 	bl	40998c <_Bfree>
  40823c:	2e00      	cmp	r6, #0
  40823e:	f43f ad8e 	beq.w	407d5e <_dtoa_r+0x396>
  408242:	e68d      	b.n	407f60 <_dtoa_r+0x598>
  408244:	9a10      	ldr	r2, [sp, #64]	; 0x40
  408246:	2a00      	cmp	r2, #0
  408248:	f000 8241 	beq.w	4086ce <_dtoa_r+0xd06>
  40824c:	f203 4333 	addw	r3, r3, #1075	; 0x433
  408250:	9f0a      	ldr	r7, [sp, #40]	; 0x28
  408252:	9d05      	ldr	r5, [sp, #20]
  408254:	e5ab      	b.n	407dae <_dtoa_r+0x3e6>
  408256:	201c      	movs	r0, #28
  408258:	9b05      	ldr	r3, [sp, #20]
  40825a:	4403      	add	r3, r0
  40825c:	9305      	str	r3, [sp, #20]
  40825e:	9b02      	ldr	r3, [sp, #8]
  408260:	4403      	add	r3, r0
  408262:	4405      	add	r5, r0
  408264:	9302      	str	r3, [sp, #8]
  408266:	e60e      	b.n	407e86 <_dtoa_r+0x4be>
  408268:	9b20      	ldr	r3, [sp, #128]	; 0x80
  40826a:	2b01      	cmp	r3, #1
  40826c:	f340 8282 	ble.w	408774 <_dtoa_r+0xdac>
  408270:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
  408272:	2001      	movs	r0, #1
  408274:	e5f3      	b.n	407e5e <_dtoa_r+0x496>
  408276:	bf00      	nop
  408278:	0040ae78 	.word	0x0040ae78
  40827c:	0040af40 	.word	0x0040af40
  408280:	3ff00000 	.word	0x3ff00000
  408284:	401c0000 	.word	0x401c0000
  408288:	3fe00000 	.word	0x3fe00000
  40828c:	40240000 	.word	0x40240000
  408290:	40140000 	.word	0x40140000
  408294:	4631      	mov	r1, r6
  408296:	2300      	movs	r3, #0
  408298:	220a      	movs	r2, #10
  40829a:	4648      	mov	r0, r9
  40829c:	f001 fb80 	bl	4099a0 <__multadd>
  4082a0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4082a2:	2b00      	cmp	r3, #0
  4082a4:	4606      	mov	r6, r0
  4082a6:	f340 8297 	ble.w	4087d8 <_dtoa_r+0xe10>
  4082aa:	9306      	str	r3, [sp, #24]
  4082ac:	2d00      	cmp	r5, #0
  4082ae:	dd05      	ble.n	4082bc <_dtoa_r+0x8f4>
  4082b0:	4631      	mov	r1, r6
  4082b2:	462a      	mov	r2, r5
  4082b4:	4648      	mov	r0, r9
  4082b6:	f001 fcf3 	bl	409ca0 <__lshift>
  4082ba:	4606      	mov	r6, r0
  4082bc:	2f00      	cmp	r7, #0
  4082be:	f040 817c 	bne.w	4085ba <_dtoa_r+0xbf2>
  4082c2:	9605      	str	r6, [sp, #20]
  4082c4:	9b06      	ldr	r3, [sp, #24]
  4082c6:	9a07      	ldr	r2, [sp, #28]
  4082c8:	f8dd b014 	ldr.w	fp, [sp, #20]
  4082cc:	3b01      	subs	r3, #1
  4082ce:	18d3      	adds	r3, r2, r3
  4082d0:	9308      	str	r3, [sp, #32]
  4082d2:	f00a 0301 	and.w	r3, sl, #1
  4082d6:	9309      	str	r3, [sp, #36]	; 0x24
  4082d8:	4617      	mov	r7, r2
  4082da:	46c2      	mov	sl, r8
  4082dc:	4651      	mov	r1, sl
  4082de:	4620      	mov	r0, r4
  4082e0:	f7ff fade 	bl	4078a0 <quorem>
  4082e4:	4631      	mov	r1, r6
  4082e6:	4605      	mov	r5, r0
  4082e8:	4620      	mov	r0, r4
  4082ea:	f001 fd31 	bl	409d50 <__mcmp>
  4082ee:	465a      	mov	r2, fp
  4082f0:	9002      	str	r0, [sp, #8]
  4082f2:	4651      	mov	r1, sl
  4082f4:	4648      	mov	r0, r9
  4082f6:	f001 fd4b 	bl	409d90 <__mdiff>
  4082fa:	68c2      	ldr	r2, [r0, #12]
  4082fc:	4680      	mov	r8, r0
  4082fe:	f105 0330 	add.w	r3, r5, #48	; 0x30
  408302:	2a00      	cmp	r2, #0
  408304:	d149      	bne.n	40839a <_dtoa_r+0x9d2>
  408306:	4601      	mov	r1, r0
  408308:	4620      	mov	r0, r4
  40830a:	9306      	str	r3, [sp, #24]
  40830c:	f001 fd20 	bl	409d50 <__mcmp>
  408310:	4641      	mov	r1, r8
  408312:	9005      	str	r0, [sp, #20]
  408314:	4648      	mov	r0, r9
  408316:	f001 fb39 	bl	40998c <_Bfree>
  40831a:	9a05      	ldr	r2, [sp, #20]
  40831c:	9b06      	ldr	r3, [sp, #24]
  40831e:	b92a      	cbnz	r2, 40832c <_dtoa_r+0x964>
  408320:	9920      	ldr	r1, [sp, #128]	; 0x80
  408322:	b919      	cbnz	r1, 40832c <_dtoa_r+0x964>
  408324:	9909      	ldr	r1, [sp, #36]	; 0x24
  408326:	2900      	cmp	r1, #0
  408328:	f000 8236 	beq.w	408798 <_dtoa_r+0xdd0>
  40832c:	9902      	ldr	r1, [sp, #8]
  40832e:	2900      	cmp	r1, #0
  408330:	f2c0 80e4 	blt.w	4084fc <_dtoa_r+0xb34>
  408334:	d105      	bne.n	408342 <_dtoa_r+0x97a>
  408336:	9920      	ldr	r1, [sp, #128]	; 0x80
  408338:	b919      	cbnz	r1, 408342 <_dtoa_r+0x97a>
  40833a:	9909      	ldr	r1, [sp, #36]	; 0x24
  40833c:	2900      	cmp	r1, #0
  40833e:	f000 80dd 	beq.w	4084fc <_dtoa_r+0xb34>
  408342:	2a00      	cmp	r2, #0
  408344:	f300 814d 	bgt.w	4085e2 <_dtoa_r+0xc1a>
  408348:	9a08      	ldr	r2, [sp, #32]
  40834a:	703b      	strb	r3, [r7, #0]
  40834c:	f107 0801 	add.w	r8, r7, #1
  408350:	4297      	cmp	r7, r2
  408352:	4645      	mov	r5, r8
  408354:	f000 8154 	beq.w	408600 <_dtoa_r+0xc38>
  408358:	4621      	mov	r1, r4
  40835a:	2300      	movs	r3, #0
  40835c:	220a      	movs	r2, #10
  40835e:	4648      	mov	r0, r9
  408360:	f001 fb1e 	bl	4099a0 <__multadd>
  408364:	455e      	cmp	r6, fp
  408366:	4604      	mov	r4, r0
  408368:	4631      	mov	r1, r6
  40836a:	f04f 0300 	mov.w	r3, #0
  40836e:	f04f 020a 	mov.w	r2, #10
  408372:	4648      	mov	r0, r9
  408374:	d00b      	beq.n	40838e <_dtoa_r+0x9c6>
  408376:	f001 fb13 	bl	4099a0 <__multadd>
  40837a:	4659      	mov	r1, fp
  40837c:	4606      	mov	r6, r0
  40837e:	2300      	movs	r3, #0
  408380:	220a      	movs	r2, #10
  408382:	4648      	mov	r0, r9
  408384:	f001 fb0c 	bl	4099a0 <__multadd>
  408388:	4647      	mov	r7, r8
  40838a:	4683      	mov	fp, r0
  40838c:	e7a6      	b.n	4082dc <_dtoa_r+0x914>
  40838e:	f001 fb07 	bl	4099a0 <__multadd>
  408392:	4647      	mov	r7, r8
  408394:	4606      	mov	r6, r0
  408396:	4683      	mov	fp, r0
  408398:	e7a0      	b.n	4082dc <_dtoa_r+0x914>
  40839a:	4601      	mov	r1, r0
  40839c:	4648      	mov	r0, r9
  40839e:	9305      	str	r3, [sp, #20]
  4083a0:	f001 faf4 	bl	40998c <_Bfree>
  4083a4:	2201      	movs	r2, #1
  4083a6:	9b05      	ldr	r3, [sp, #20]
  4083a8:	e7c0      	b.n	40832c <_dtoa_r+0x964>
  4083aa:	4641      	mov	r1, r8
  4083ac:	4620      	mov	r0, r4
  4083ae:	f001 fccf 	bl	409d50 <__mcmp>
  4083b2:	2800      	cmp	r0, #0
  4083b4:	f6bf ad7d 	bge.w	407eb2 <_dtoa_r+0x4ea>
  4083b8:	4621      	mov	r1, r4
  4083ba:	9c04      	ldr	r4, [sp, #16]
  4083bc:	2300      	movs	r3, #0
  4083be:	3c01      	subs	r4, #1
  4083c0:	220a      	movs	r2, #10
  4083c2:	4648      	mov	r0, r9
  4083c4:	9404      	str	r4, [sp, #16]
  4083c6:	f001 faeb 	bl	4099a0 <__multadd>
  4083ca:	9b09      	ldr	r3, [sp, #36]	; 0x24
  4083cc:	4604      	mov	r4, r0
  4083ce:	2b00      	cmp	r3, #0
  4083d0:	f47f af60 	bne.w	408294 <_dtoa_r+0x8cc>
  4083d4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4083d6:	2b00      	cmp	r3, #0
  4083d8:	f340 81f6 	ble.w	4087c8 <_dtoa_r+0xe00>
  4083dc:	9306      	str	r3, [sp, #24]
  4083de:	e570      	b.n	407ec2 <_dtoa_r+0x4fa>
  4083e0:	9c08      	ldr	r4, [sp, #32]
  4083e2:	e51f      	b.n	407e24 <_dtoa_r+0x45c>
  4083e4:	9b20      	ldr	r3, [sp, #128]	; 0x80
  4083e6:	2b02      	cmp	r3, #2
  4083e8:	f77f ad67 	ble.w	407eba <_dtoa_r+0x4f2>
  4083ec:	9b06      	ldr	r3, [sp, #24]
  4083ee:	2b00      	cmp	r3, #0
  4083f0:	f040 8179 	bne.w	4086e6 <_dtoa_r+0xd1e>
  4083f4:	4641      	mov	r1, r8
  4083f6:	2205      	movs	r2, #5
  4083f8:	4648      	mov	r0, r9
  4083fa:	f001 fad1 	bl	4099a0 <__multadd>
  4083fe:	4601      	mov	r1, r0
  408400:	4680      	mov	r8, r0
  408402:	4620      	mov	r0, r4
  408404:	f001 fca4 	bl	409d50 <__mcmp>
  408408:	2800      	cmp	r0, #0
  40840a:	9408      	str	r4, [sp, #32]
  40840c:	f77f af0e 	ble.w	40822c <_dtoa_r+0x864>
  408410:	9a04      	ldr	r2, [sp, #16]
  408412:	9907      	ldr	r1, [sp, #28]
  408414:	2331      	movs	r3, #49	; 0x31
  408416:	3201      	adds	r2, #1
  408418:	9204      	str	r2, [sp, #16]
  40841a:	700b      	strb	r3, [r1, #0]
  40841c:	1c4d      	adds	r5, r1, #1
  40841e:	e709      	b.n	408234 <_dtoa_r+0x86c>
  408420:	9a04      	ldr	r2, [sp, #16]
  408422:	3201      	adds	r2, #1
  408424:	9204      	str	r2, [sp, #16]
  408426:	9a07      	ldr	r2, [sp, #28]
  408428:	2331      	movs	r3, #49	; 0x31
  40842a:	7013      	strb	r3, [r2, #0]
  40842c:	e588      	b.n	407f40 <_dtoa_r+0x578>
  40842e:	2301      	movs	r3, #1
  408430:	9309      	str	r3, [sp, #36]	; 0x24
  408432:	e5cd      	b.n	407fd0 <_dtoa_r+0x608>
  408434:	f8dd 9014 	ldr.w	r9, [sp, #20]
  408438:	e491      	b.n	407d5e <_dtoa_r+0x396>
  40843a:	f1ba 0f00 	cmp.w	sl, #0
  40843e:	f47f ad04 	bne.w	407e4a <_dtoa_r+0x482>
  408442:	f3cb 0313 	ubfx	r3, fp, #0, #20
  408446:	2b00      	cmp	r3, #0
  408448:	f040 813f 	bne.w	4086ca <_dtoa_r+0xd02>
  40844c:	f02b 4700 	bic.w	r7, fp, #2147483648	; 0x80000000
  408450:	0d3f      	lsrs	r7, r7, #20
  408452:	053f      	lsls	r7, r7, #20
  408454:	b137      	cbz	r7, 408464 <_dtoa_r+0xa9c>
  408456:	9b05      	ldr	r3, [sp, #20]
  408458:	3301      	adds	r3, #1
  40845a:	9305      	str	r3, [sp, #20]
  40845c:	9b02      	ldr	r3, [sp, #8]
  40845e:	3301      	adds	r3, #1
  408460:	9302      	str	r3, [sp, #8]
  408462:	2701      	movs	r7, #1
  408464:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  408466:	2001      	movs	r0, #1
  408468:	2b00      	cmp	r3, #0
  40846a:	f43f acf8 	beq.w	407e5e <_dtoa_r+0x496>
  40846e:	e4ed      	b.n	407e4c <_dtoa_r+0x484>
  408470:	4640      	mov	r0, r8
  408472:	f7fc f8f1 	bl	404658 <__aeabi_i2d>
  408476:	4632      	mov	r2, r6
  408478:	463b      	mov	r3, r7
  40847a:	f7fc f953 	bl	404724 <__aeabi_dmul>
  40847e:	2200      	movs	r2, #0
  408480:	4bbf      	ldr	r3, [pc, #764]	; (408780 <_dtoa_r+0xdb8>)
  408482:	f7fb ff9d 	bl	4043c0 <__adddf3>
  408486:	4604      	mov	r4, r0
  408488:	f1a1 7550 	sub.w	r5, r1, #54525952	; 0x3400000
  40848c:	4630      	mov	r0, r6
  40848e:	4639      	mov	r1, r7
  408490:	2200      	movs	r2, #0
  408492:	4bbc      	ldr	r3, [pc, #752]	; (408784 <_dtoa_r+0xdbc>)
  408494:	f7fb ff92 	bl	4043bc <__aeabi_dsub>
  408498:	4622      	mov	r2, r4
  40849a:	462b      	mov	r3, r5
  40849c:	4606      	mov	r6, r0
  40849e:	460f      	mov	r7, r1
  4084a0:	f7fc fbd0 	bl	404c44 <__aeabi_dcmpgt>
  4084a4:	4680      	mov	r8, r0
  4084a6:	2800      	cmp	r0, #0
  4084a8:	f040 8105 	bne.w	4086b6 <_dtoa_r+0xcee>
  4084ac:	4622      	mov	r2, r4
  4084ae:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
  4084b2:	4630      	mov	r0, r6
  4084b4:	4639      	mov	r1, r7
  4084b6:	f7fc fba7 	bl	404c08 <__aeabi_dcmplt>
  4084ba:	b108      	cbz	r0, 4084c0 <_dtoa_r+0xaf8>
  4084bc:	4646      	mov	r6, r8
  4084be:	e6b5      	b.n	40822c <_dtoa_r+0x864>
  4084c0:	e9dd ab0e 	ldrd	sl, fp, [sp, #56]	; 0x38
  4084c4:	f7ff bb89 	b.w	407bda <_dtoa_r+0x212>
  4084c8:	9807      	ldr	r0, [sp, #28]
  4084ca:	f7ff baae 	b.w	407a2a <_dtoa_r+0x62>
  4084ce:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  4084d0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  4084d2:	970a      	str	r7, [sp, #40]	; 0x28
  4084d4:	1afb      	subs	r3, r7, r3
  4084d6:	441a      	add	r2, r3
  4084d8:	920b      	str	r2, [sp, #44]	; 0x2c
  4084da:	2700      	movs	r7, #0
  4084dc:	e461      	b.n	407da2 <_dtoa_r+0x3da>
  4084de:	e9dd ab0e 	ldrd	sl, fp, [sp, #56]	; 0x38
  4084e2:	f04f 0802 	mov.w	r8, #2
  4084e6:	e5bb      	b.n	408060 <_dtoa_r+0x698>
  4084e8:	461c      	mov	r4, r3
  4084ea:	2100      	movs	r1, #0
  4084ec:	f8c9 1044 	str.w	r1, [r9, #68]	; 0x44
  4084f0:	e58a      	b.n	408008 <_dtoa_r+0x640>
  4084f2:	2401      	movs	r4, #1
  4084f4:	9421      	str	r4, [sp, #132]	; 0x84
  4084f6:	940d      	str	r4, [sp, #52]	; 0x34
  4084f8:	9406      	str	r4, [sp, #24]
  4084fa:	e7f6      	b.n	4084ea <_dtoa_r+0xb22>
  4084fc:	2a00      	cmp	r2, #0
  4084fe:	46d0      	mov	r8, sl
  408500:	f8cd b014 	str.w	fp, [sp, #20]
  408504:	469a      	mov	sl, r3
  408506:	dd11      	ble.n	40852c <_dtoa_r+0xb64>
  408508:	4621      	mov	r1, r4
  40850a:	2201      	movs	r2, #1
  40850c:	4648      	mov	r0, r9
  40850e:	f001 fbc7 	bl	409ca0 <__lshift>
  408512:	4641      	mov	r1, r8
  408514:	4604      	mov	r4, r0
  408516:	f001 fc1b 	bl	409d50 <__mcmp>
  40851a:	2800      	cmp	r0, #0
  40851c:	f340 8149 	ble.w	4087b2 <_dtoa_r+0xdea>
  408520:	f1ba 0f39 	cmp.w	sl, #57	; 0x39
  408524:	f000 8106 	beq.w	408734 <_dtoa_r+0xd6c>
  408528:	f105 0a31 	add.w	sl, r5, #49	; 0x31
  40852c:	46b3      	mov	fp, r6
  40852e:	f887 a000 	strb.w	sl, [r7]
  408532:	1c7d      	adds	r5, r7, #1
  408534:	9e05      	ldr	r6, [sp, #20]
  408536:	9408      	str	r4, [sp, #32]
  408538:	e502      	b.n	407f40 <_dtoa_r+0x578>
  40853a:	d104      	bne.n	408546 <_dtoa_r+0xb7e>
  40853c:	f01a 0f01 	tst.w	sl, #1
  408540:	d001      	beq.n	408546 <_dtoa_r+0xb7e>
  408542:	e4ed      	b.n	407f20 <_dtoa_r+0x558>
  408544:	4615      	mov	r5, r2
  408546:	f815 3c01 	ldrb.w	r3, [r5, #-1]
  40854a:	2b30      	cmp	r3, #48	; 0x30
  40854c:	f105 32ff 	add.w	r2, r5, #4294967295
  408550:	d0f8      	beq.n	408544 <_dtoa_r+0xb7c>
  408552:	e4f5      	b.n	407f40 <_dtoa_r+0x578>
  408554:	9b04      	ldr	r3, [sp, #16]
  408556:	425c      	negs	r4, r3
  408558:	2c00      	cmp	r4, #0
  40855a:	f000 80bf 	beq.w	4086dc <_dtoa_r+0xd14>
  40855e:	4b8a      	ldr	r3, [pc, #552]	; (408788 <_dtoa_r+0xdc0>)
  408560:	f004 020f 	and.w	r2, r4, #15
  408564:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  408568:	e9d3 2300 	ldrd	r2, r3, [r3]
  40856c:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
  408570:	f7fc f8d8 	bl	404724 <__aeabi_dmul>
  408574:	1124      	asrs	r4, r4, #4
  408576:	4606      	mov	r6, r0
  408578:	460f      	mov	r7, r1
  40857a:	f000 812a 	beq.w	4087d2 <_dtoa_r+0xe0a>
  40857e:	4d83      	ldr	r5, [pc, #524]	; (40878c <_dtoa_r+0xdc4>)
  408580:	f04f 0802 	mov.w	r8, #2
  408584:	07e2      	lsls	r2, r4, #31
  408586:	d509      	bpl.n	40859c <_dtoa_r+0xbd4>
  408588:	4630      	mov	r0, r6
  40858a:	4639      	mov	r1, r7
  40858c:	e9d5 2300 	ldrd	r2, r3, [r5]
  408590:	f7fc f8c8 	bl	404724 <__aeabi_dmul>
  408594:	f108 0801 	add.w	r8, r8, #1
  408598:	4606      	mov	r6, r0
  40859a:	460f      	mov	r7, r1
  40859c:	1064      	asrs	r4, r4, #1
  40859e:	f105 0508 	add.w	r5, r5, #8
  4085a2:	d1ef      	bne.n	408584 <_dtoa_r+0xbbc>
  4085a4:	e576      	b.n	408094 <_dtoa_r+0x6cc>
  4085a6:	9907      	ldr	r1, [sp, #28]
  4085a8:	2230      	movs	r2, #48	; 0x30
  4085aa:	700a      	strb	r2, [r1, #0]
  4085ac:	9a04      	ldr	r2, [sp, #16]
  4085ae:	f815 4c01 	ldrb.w	r4, [r5, #-1]
  4085b2:	3201      	adds	r2, #1
  4085b4:	9204      	str	r2, [sp, #16]
  4085b6:	f7ff bbd0 	b.w	407d5a <_dtoa_r+0x392>
  4085ba:	6871      	ldr	r1, [r6, #4]
  4085bc:	4648      	mov	r0, r9
  4085be:	f001 f9bf 	bl	409940 <_Balloc>
  4085c2:	6933      	ldr	r3, [r6, #16]
  4085c4:	1c9a      	adds	r2, r3, #2
  4085c6:	4605      	mov	r5, r0
  4085c8:	0092      	lsls	r2, r2, #2
  4085ca:	f106 010c 	add.w	r1, r6, #12
  4085ce:	300c      	adds	r0, #12
  4085d0:	f7fc fb9c 	bl	404d0c <memcpy>
  4085d4:	4629      	mov	r1, r5
  4085d6:	2201      	movs	r2, #1
  4085d8:	4648      	mov	r0, r9
  4085da:	f001 fb61 	bl	409ca0 <__lshift>
  4085de:	9005      	str	r0, [sp, #20]
  4085e0:	e670      	b.n	4082c4 <_dtoa_r+0x8fc>
  4085e2:	2b39      	cmp	r3, #57	; 0x39
  4085e4:	f8cd b014 	str.w	fp, [sp, #20]
  4085e8:	46d0      	mov	r8, sl
  4085ea:	f000 80a3 	beq.w	408734 <_dtoa_r+0xd6c>
  4085ee:	f103 0a01 	add.w	sl, r3, #1
  4085f2:	46b3      	mov	fp, r6
  4085f4:	f887 a000 	strb.w	sl, [r7]
  4085f8:	1c7d      	adds	r5, r7, #1
  4085fa:	9e05      	ldr	r6, [sp, #20]
  4085fc:	9408      	str	r4, [sp, #32]
  4085fe:	e49f      	b.n	407f40 <_dtoa_r+0x578>
  408600:	465a      	mov	r2, fp
  408602:	46d0      	mov	r8, sl
  408604:	46b3      	mov	fp, r6
  408606:	469a      	mov	sl, r3
  408608:	4616      	mov	r6, r2
  40860a:	e47d      	b.n	407f08 <_dtoa_r+0x540>
  40860c:	495e      	ldr	r1, [pc, #376]	; (408788 <_dtoa_r+0xdc0>)
  40860e:	f108 3aff 	add.w	sl, r8, #4294967295
  408612:	eb01 01ca 	add.w	r1, r1, sl, lsl #3
  408616:	4622      	mov	r2, r4
  408618:	462b      	mov	r3, r5
  40861a:	e9d1 0100 	ldrd	r0, r1, [r1]
  40861e:	f7fc f881 	bl	404724 <__aeabi_dmul>
  408622:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
  408626:	4639      	mov	r1, r7
  408628:	4630      	mov	r0, r6
  40862a:	f002 f909 	bl	40a840 <__aeabi_d2iz>
  40862e:	4604      	mov	r4, r0
  408630:	f7fc f812 	bl	404658 <__aeabi_i2d>
  408634:	4602      	mov	r2, r0
  408636:	460b      	mov	r3, r1
  408638:	4630      	mov	r0, r6
  40863a:	4639      	mov	r1, r7
  40863c:	f7fb febe 	bl	4043bc <__aeabi_dsub>
  408640:	9a07      	ldr	r2, [sp, #28]
  408642:	3430      	adds	r4, #48	; 0x30
  408644:	f1b8 0f01 	cmp.w	r8, #1
  408648:	4606      	mov	r6, r0
  40864a:	460f      	mov	r7, r1
  40864c:	7014      	strb	r4, [r2, #0]
  40864e:	f102 0501 	add.w	r5, r2, #1
  408652:	d01e      	beq.n	408692 <_dtoa_r+0xcca>
  408654:	9b07      	ldr	r3, [sp, #28]
  408656:	eb03 0b08 	add.w	fp, r3, r8
  40865a:	46a8      	mov	r8, r5
  40865c:	2200      	movs	r2, #0
  40865e:	4b4c      	ldr	r3, [pc, #304]	; (408790 <_dtoa_r+0xdc8>)
  408660:	4630      	mov	r0, r6
  408662:	4639      	mov	r1, r7
  408664:	f7fc f85e 	bl	404724 <__aeabi_dmul>
  408668:	460f      	mov	r7, r1
  40866a:	4606      	mov	r6, r0
  40866c:	f002 f8e8 	bl	40a840 <__aeabi_d2iz>
  408670:	4604      	mov	r4, r0
  408672:	f7fb fff1 	bl	404658 <__aeabi_i2d>
  408676:	3430      	adds	r4, #48	; 0x30
  408678:	4602      	mov	r2, r0
  40867a:	460b      	mov	r3, r1
  40867c:	4630      	mov	r0, r6
  40867e:	4639      	mov	r1, r7
  408680:	f7fb fe9c 	bl	4043bc <__aeabi_dsub>
  408684:	f808 4b01 	strb.w	r4, [r8], #1
  408688:	45c3      	cmp	fp, r8
  40868a:	4606      	mov	r6, r0
  40868c:	460f      	mov	r7, r1
  40868e:	d1e5      	bne.n	40865c <_dtoa_r+0xc94>
  408690:	4455      	add	r5, sl
  408692:	2200      	movs	r2, #0
  408694:	4b3f      	ldr	r3, [pc, #252]	; (408794 <_dtoa_r+0xdcc>)
  408696:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
  40869a:	f7fb fe91 	bl	4043c0 <__adddf3>
  40869e:	4632      	mov	r2, r6
  4086a0:	463b      	mov	r3, r7
  4086a2:	f7fc fab1 	bl	404c08 <__aeabi_dcmplt>
  4086a6:	2800      	cmp	r0, #0
  4086a8:	d04c      	beq.n	408744 <_dtoa_r+0xd7c>
  4086aa:	9b11      	ldr	r3, [sp, #68]	; 0x44
  4086ac:	9304      	str	r3, [sp, #16]
  4086ae:	f815 4c01 	ldrb.w	r4, [r5, #-1]
  4086b2:	f7ff bb46 	b.w	407d42 <_dtoa_r+0x37a>
  4086b6:	f04f 0800 	mov.w	r8, #0
  4086ba:	4646      	mov	r6, r8
  4086bc:	e6a8      	b.n	408410 <_dtoa_r+0xa48>
  4086be:	9b05      	ldr	r3, [sp, #20]
  4086c0:	9a06      	ldr	r2, [sp, #24]
  4086c2:	1a9d      	subs	r5, r3, r2
  4086c4:	2300      	movs	r3, #0
  4086c6:	f7ff bb72 	b.w	407dae <_dtoa_r+0x3e6>
  4086ca:	2700      	movs	r7, #0
  4086cc:	e6ca      	b.n	408464 <_dtoa_r+0xa9c>
  4086ce:	9b14      	ldr	r3, [sp, #80]	; 0x50
  4086d0:	9f0a      	ldr	r7, [sp, #40]	; 0x28
  4086d2:	9d05      	ldr	r5, [sp, #20]
  4086d4:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
  4086d8:	f7ff bb69 	b.w	407dae <_dtoa_r+0x3e6>
  4086dc:	e9dd 670e 	ldrd	r6, r7, [sp, #56]	; 0x38
  4086e0:	f04f 0802 	mov.w	r8, #2
  4086e4:	e4d6      	b.n	408094 <_dtoa_r+0x6cc>
  4086e6:	9408      	str	r4, [sp, #32]
  4086e8:	e5a0      	b.n	40822c <_dtoa_r+0x864>
  4086ea:	9b06      	ldr	r3, [sp, #24]
  4086ec:	2b00      	cmp	r3, #0
  4086ee:	f43f aebf 	beq.w	408470 <_dtoa_r+0xaa8>
  4086f2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4086f4:	2b00      	cmp	r3, #0
  4086f6:	f77f aee3 	ble.w	4084c0 <_dtoa_r+0xaf8>
  4086fa:	2200      	movs	r2, #0
  4086fc:	4b24      	ldr	r3, [pc, #144]	; (408790 <_dtoa_r+0xdc8>)
  4086fe:	4630      	mov	r0, r6
  408700:	4639      	mov	r1, r7
  408702:	f7fc f80f 	bl	404724 <__aeabi_dmul>
  408706:	4606      	mov	r6, r0
  408708:	460f      	mov	r7, r1
  40870a:	f108 0001 	add.w	r0, r8, #1
  40870e:	f7fb ffa3 	bl	404658 <__aeabi_i2d>
  408712:	4632      	mov	r2, r6
  408714:	463b      	mov	r3, r7
  408716:	f7fc f805 	bl	404724 <__aeabi_dmul>
  40871a:	2200      	movs	r2, #0
  40871c:	4b18      	ldr	r3, [pc, #96]	; (408780 <_dtoa_r+0xdb8>)
  40871e:	f7fb fe4f 	bl	4043c0 <__adddf3>
  408722:	9a04      	ldr	r2, [sp, #16]
  408724:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
  408728:	3a01      	subs	r2, #1
  40872a:	4604      	mov	r4, r0
  40872c:	f1a1 7550 	sub.w	r5, r1, #54525952	; 0x3400000
  408730:	9211      	str	r2, [sp, #68]	; 0x44
  408732:	e4d0      	b.n	4080d6 <_dtoa_r+0x70e>
  408734:	2239      	movs	r2, #57	; 0x39
  408736:	46b3      	mov	fp, r6
  408738:	9408      	str	r4, [sp, #32]
  40873a:	9e05      	ldr	r6, [sp, #20]
  40873c:	703a      	strb	r2, [r7, #0]
  40873e:	1c7d      	adds	r5, r7, #1
  408740:	f7ff bbf0 	b.w	407f24 <_dtoa_r+0x55c>
  408744:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
  408748:	2000      	movs	r0, #0
  40874a:	4912      	ldr	r1, [pc, #72]	; (408794 <_dtoa_r+0xdcc>)
  40874c:	f7fb fe36 	bl	4043bc <__aeabi_dsub>
  408750:	4632      	mov	r2, r6
  408752:	463b      	mov	r3, r7
  408754:	f7fc fa76 	bl	404c44 <__aeabi_dcmpgt>
  408758:	b908      	cbnz	r0, 40875e <_dtoa_r+0xd96>
  40875a:	e6b1      	b.n	4084c0 <_dtoa_r+0xaf8>
  40875c:	4615      	mov	r5, r2
  40875e:	f815 3c01 	ldrb.w	r3, [r5, #-1]
  408762:	2b30      	cmp	r3, #48	; 0x30
  408764:	f105 32ff 	add.w	r2, r5, #4294967295
  408768:	d0f8      	beq.n	40875c <_dtoa_r+0xd94>
  40876a:	e530      	b.n	4081ce <_dtoa_r+0x806>
  40876c:	9b11      	ldr	r3, [sp, #68]	; 0x44
  40876e:	9304      	str	r3, [sp, #16]
  408770:	f7ff bae7 	b.w	407d42 <_dtoa_r+0x37a>
  408774:	f1ba 0f00 	cmp.w	sl, #0
  408778:	f47f ad7a 	bne.w	408270 <_dtoa_r+0x8a8>
  40877c:	e661      	b.n	408442 <_dtoa_r+0xa7a>
  40877e:	bf00      	nop
  408780:	401c0000 	.word	0x401c0000
  408784:	40140000 	.word	0x40140000
  408788:	0040ae78 	.word	0x0040ae78
  40878c:	0040af40 	.word	0x0040af40
  408790:	40240000 	.word	0x40240000
  408794:	3fe00000 	.word	0x3fe00000
  408798:	2b39      	cmp	r3, #57	; 0x39
  40879a:	f8cd b014 	str.w	fp, [sp, #20]
  40879e:	46d0      	mov	r8, sl
  4087a0:	f8dd b008 	ldr.w	fp, [sp, #8]
  4087a4:	469a      	mov	sl, r3
  4087a6:	d0c5      	beq.n	408734 <_dtoa_r+0xd6c>
  4087a8:	f1bb 0f00 	cmp.w	fp, #0
  4087ac:	f73f aebc 	bgt.w	408528 <_dtoa_r+0xb60>
  4087b0:	e6bc      	b.n	40852c <_dtoa_r+0xb64>
  4087b2:	f47f aebb 	bne.w	40852c <_dtoa_r+0xb64>
  4087b6:	f01a 0f01 	tst.w	sl, #1
  4087ba:	f43f aeb7 	beq.w	40852c <_dtoa_r+0xb64>
  4087be:	e6af      	b.n	408520 <_dtoa_r+0xb58>
  4087c0:	f04f 0800 	mov.w	r8, #0
  4087c4:	4646      	mov	r6, r8
  4087c6:	e531      	b.n	40822c <_dtoa_r+0x864>
  4087c8:	9b20      	ldr	r3, [sp, #128]	; 0x80
  4087ca:	2b02      	cmp	r3, #2
  4087cc:	dc21      	bgt.n	408812 <_dtoa_r+0xe4a>
  4087ce:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4087d0:	e604      	b.n	4083dc <_dtoa_r+0xa14>
  4087d2:	f04f 0802 	mov.w	r8, #2
  4087d6:	e45d      	b.n	408094 <_dtoa_r+0x6cc>
  4087d8:	9b20      	ldr	r3, [sp, #128]	; 0x80
  4087da:	2b02      	cmp	r3, #2
  4087dc:	dc19      	bgt.n	408812 <_dtoa_r+0xe4a>
  4087de:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4087e0:	e563      	b.n	4082aa <_dtoa_r+0x8e2>
  4087e2:	2400      	movs	r4, #0
  4087e4:	f8c9 4044 	str.w	r4, [r9, #68]	; 0x44
  4087e8:	4621      	mov	r1, r4
  4087ea:	4648      	mov	r0, r9
  4087ec:	f001 f8a8 	bl	409940 <_Balloc>
  4087f0:	f04f 33ff 	mov.w	r3, #4294967295
  4087f4:	9306      	str	r3, [sp, #24]
  4087f6:	930d      	str	r3, [sp, #52]	; 0x34
  4087f8:	2301      	movs	r3, #1
  4087fa:	9007      	str	r0, [sp, #28]
  4087fc:	9421      	str	r4, [sp, #132]	; 0x84
  4087fe:	f8c9 0040 	str.w	r0, [r9, #64]	; 0x40
  408802:	9309      	str	r3, [sp, #36]	; 0x24
  408804:	f7ff b9e9 	b.w	407bda <_dtoa_r+0x212>
  408808:	f43f ab3d 	beq.w	407e86 <_dtoa_r+0x4be>
  40880c:	f1c0 003c 	rsb	r0, r0, #60	; 0x3c
  408810:	e522      	b.n	408258 <_dtoa_r+0x890>
  408812:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  408814:	9306      	str	r3, [sp, #24]
  408816:	e5e9      	b.n	4083ec <_dtoa_r+0xa24>
  408818:	2501      	movs	r5, #1
  40881a:	f7ff b9a8 	b.w	407b6e <_dtoa_r+0x1a6>
  40881e:	bf00      	nop

00408820 <__sflush_r>:
  408820:	f9b1 300c 	ldrsh.w	r3, [r1, #12]
  408824:	b29a      	uxth	r2, r3
  408826:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40882a:	460d      	mov	r5, r1
  40882c:	0711      	lsls	r1, r2, #28
  40882e:	4680      	mov	r8, r0
  408830:	d43c      	bmi.n	4088ac <__sflush_r+0x8c>
  408832:	686a      	ldr	r2, [r5, #4]
  408834:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  408838:	2a00      	cmp	r2, #0
  40883a:	81ab      	strh	r3, [r5, #12]
  40883c:	dd73      	ble.n	408926 <__sflush_r+0x106>
  40883e:	6aac      	ldr	r4, [r5, #40]	; 0x28
  408840:	2c00      	cmp	r4, #0
  408842:	d04b      	beq.n	4088dc <__sflush_r+0xbc>
  408844:	b29b      	uxth	r3, r3
  408846:	f403 5280 	and.w	r2, r3, #4096	; 0x1000
  40884a:	2100      	movs	r1, #0
  40884c:	b292      	uxth	r2, r2
  40884e:	f8d8 6000 	ldr.w	r6, [r8]
  408852:	f8c8 1000 	str.w	r1, [r8]
  408856:	2a00      	cmp	r2, #0
  408858:	d069      	beq.n	40892e <__sflush_r+0x10e>
  40885a:	6d2a      	ldr	r2, [r5, #80]	; 0x50
  40885c:	075f      	lsls	r7, r3, #29
  40885e:	d505      	bpl.n	40886c <__sflush_r+0x4c>
  408860:	6869      	ldr	r1, [r5, #4]
  408862:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  408864:	1a52      	subs	r2, r2, r1
  408866:	b10b      	cbz	r3, 40886c <__sflush_r+0x4c>
  408868:	6beb      	ldr	r3, [r5, #60]	; 0x3c
  40886a:	1ad2      	subs	r2, r2, r3
  40886c:	2300      	movs	r3, #0
  40886e:	69e9      	ldr	r1, [r5, #28]
  408870:	4640      	mov	r0, r8
  408872:	47a0      	blx	r4
  408874:	1c44      	adds	r4, r0, #1
  408876:	d03c      	beq.n	4088f2 <__sflush_r+0xd2>
  408878:	f9b5 300c 	ldrsh.w	r3, [r5, #12]
  40887c:	692a      	ldr	r2, [r5, #16]
  40887e:	602a      	str	r2, [r5, #0]
  408880:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  408884:	2200      	movs	r2, #0
  408886:	81ab      	strh	r3, [r5, #12]
  408888:	04db      	lsls	r3, r3, #19
  40888a:	606a      	str	r2, [r5, #4]
  40888c:	d449      	bmi.n	408922 <__sflush_r+0x102>
  40888e:	6b29      	ldr	r1, [r5, #48]	; 0x30
  408890:	f8c8 6000 	str.w	r6, [r8]
  408894:	b311      	cbz	r1, 4088dc <__sflush_r+0xbc>
  408896:	f105 0340 	add.w	r3, r5, #64	; 0x40
  40889a:	4299      	cmp	r1, r3
  40889c:	d002      	beq.n	4088a4 <__sflush_r+0x84>
  40889e:	4640      	mov	r0, r8
  4088a0:	f000 f9c0 	bl	408c24 <_free_r>
  4088a4:	2000      	movs	r0, #0
  4088a6:	6328      	str	r0, [r5, #48]	; 0x30
  4088a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4088ac:	692e      	ldr	r6, [r5, #16]
  4088ae:	b1ae      	cbz	r6, 4088dc <__sflush_r+0xbc>
  4088b0:	682c      	ldr	r4, [r5, #0]
  4088b2:	602e      	str	r6, [r5, #0]
  4088b4:	0790      	lsls	r0, r2, #30
  4088b6:	bf0c      	ite	eq
  4088b8:	696b      	ldreq	r3, [r5, #20]
  4088ba:	2300      	movne	r3, #0
  4088bc:	1ba4      	subs	r4, r4, r6
  4088be:	60ab      	str	r3, [r5, #8]
  4088c0:	e00a      	b.n	4088d8 <__sflush_r+0xb8>
  4088c2:	4623      	mov	r3, r4
  4088c4:	4632      	mov	r2, r6
  4088c6:	6a6f      	ldr	r7, [r5, #36]	; 0x24
  4088c8:	69e9      	ldr	r1, [r5, #28]
  4088ca:	4640      	mov	r0, r8
  4088cc:	47b8      	blx	r7
  4088ce:	2800      	cmp	r0, #0
  4088d0:	eba4 0400 	sub.w	r4, r4, r0
  4088d4:	4406      	add	r6, r0
  4088d6:	dd04      	ble.n	4088e2 <__sflush_r+0xc2>
  4088d8:	2c00      	cmp	r4, #0
  4088da:	dcf2      	bgt.n	4088c2 <__sflush_r+0xa2>
  4088dc:	2000      	movs	r0, #0
  4088de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4088e2:	89ab      	ldrh	r3, [r5, #12]
  4088e4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  4088e8:	81ab      	strh	r3, [r5, #12]
  4088ea:	f04f 30ff 	mov.w	r0, #4294967295
  4088ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4088f2:	f8d8 2000 	ldr.w	r2, [r8]
  4088f6:	2a1d      	cmp	r2, #29
  4088f8:	d8f3      	bhi.n	4088e2 <__sflush_r+0xc2>
  4088fa:	4b1a      	ldr	r3, [pc, #104]	; (408964 <__sflush_r+0x144>)
  4088fc:	40d3      	lsrs	r3, r2
  4088fe:	f003 0301 	and.w	r3, r3, #1
  408902:	f083 0401 	eor.w	r4, r3, #1
  408906:	2b00      	cmp	r3, #0
  408908:	d0eb      	beq.n	4088e2 <__sflush_r+0xc2>
  40890a:	f9b5 300c 	ldrsh.w	r3, [r5, #12]
  40890e:	6929      	ldr	r1, [r5, #16]
  408910:	6029      	str	r1, [r5, #0]
  408912:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  408916:	04d9      	lsls	r1, r3, #19
  408918:	606c      	str	r4, [r5, #4]
  40891a:	81ab      	strh	r3, [r5, #12]
  40891c:	d5b7      	bpl.n	40888e <__sflush_r+0x6e>
  40891e:	2a00      	cmp	r2, #0
  408920:	d1b5      	bne.n	40888e <__sflush_r+0x6e>
  408922:	6528      	str	r0, [r5, #80]	; 0x50
  408924:	e7b3      	b.n	40888e <__sflush_r+0x6e>
  408926:	6bea      	ldr	r2, [r5, #60]	; 0x3c
  408928:	2a00      	cmp	r2, #0
  40892a:	dc88      	bgt.n	40883e <__sflush_r+0x1e>
  40892c:	e7d6      	b.n	4088dc <__sflush_r+0xbc>
  40892e:	2301      	movs	r3, #1
  408930:	69e9      	ldr	r1, [r5, #28]
  408932:	4640      	mov	r0, r8
  408934:	47a0      	blx	r4
  408936:	1c43      	adds	r3, r0, #1
  408938:	4602      	mov	r2, r0
  40893a:	d002      	beq.n	408942 <__sflush_r+0x122>
  40893c:	89ab      	ldrh	r3, [r5, #12]
  40893e:	6aac      	ldr	r4, [r5, #40]	; 0x28
  408940:	e78c      	b.n	40885c <__sflush_r+0x3c>
  408942:	f8d8 3000 	ldr.w	r3, [r8]
  408946:	2b00      	cmp	r3, #0
  408948:	d0f8      	beq.n	40893c <__sflush_r+0x11c>
  40894a:	2b1d      	cmp	r3, #29
  40894c:	d001      	beq.n	408952 <__sflush_r+0x132>
  40894e:	2b16      	cmp	r3, #22
  408950:	d102      	bne.n	408958 <__sflush_r+0x138>
  408952:	f8c8 6000 	str.w	r6, [r8]
  408956:	e7c1      	b.n	4088dc <__sflush_r+0xbc>
  408958:	89ab      	ldrh	r3, [r5, #12]
  40895a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  40895e:	81ab      	strh	r3, [r5, #12]
  408960:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  408964:	20400001 	.word	0x20400001

00408968 <_fflush_r>:
  408968:	b510      	push	{r4, lr}
  40896a:	4604      	mov	r4, r0
  40896c:	b082      	sub	sp, #8
  40896e:	b108      	cbz	r0, 408974 <_fflush_r+0xc>
  408970:	6b83      	ldr	r3, [r0, #56]	; 0x38
  408972:	b153      	cbz	r3, 40898a <_fflush_r+0x22>
  408974:	f9b1 000c 	ldrsh.w	r0, [r1, #12]
  408978:	b908      	cbnz	r0, 40897e <_fflush_r+0x16>
  40897a:	b002      	add	sp, #8
  40897c:	bd10      	pop	{r4, pc}
  40897e:	4620      	mov	r0, r4
  408980:	b002      	add	sp, #8
  408982:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  408986:	f7ff bf4b 	b.w	408820 <__sflush_r>
  40898a:	9101      	str	r1, [sp, #4]
  40898c:	f000 f880 	bl	408a90 <__sinit>
  408990:	9901      	ldr	r1, [sp, #4]
  408992:	e7ef      	b.n	408974 <_fflush_r+0xc>

00408994 <_cleanup_r>:
  408994:	4901      	ldr	r1, [pc, #4]	; (40899c <_cleanup_r+0x8>)
  408996:	f000 bbaf 	b.w	4090f8 <_fwalk_reent>
  40899a:	bf00      	nop
  40899c:	0040a6ed 	.word	0x0040a6ed

004089a0 <__sinit.part.1>:
  4089a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4089a4:	4b35      	ldr	r3, [pc, #212]	; (408a7c <__sinit.part.1+0xdc>)
  4089a6:	6845      	ldr	r5, [r0, #4]
  4089a8:	63c3      	str	r3, [r0, #60]	; 0x3c
  4089aa:	2400      	movs	r4, #0
  4089ac:	4607      	mov	r7, r0
  4089ae:	f500 723b 	add.w	r2, r0, #748	; 0x2ec
  4089b2:	2304      	movs	r3, #4
  4089b4:	2103      	movs	r1, #3
  4089b6:	f8c0 12e4 	str.w	r1, [r0, #740]	; 0x2e4
  4089ba:	f8c0 22e8 	str.w	r2, [r0, #744]	; 0x2e8
  4089be:	f8c0 42e0 	str.w	r4, [r0, #736]	; 0x2e0
  4089c2:	b083      	sub	sp, #12
  4089c4:	602c      	str	r4, [r5, #0]
  4089c6:	606c      	str	r4, [r5, #4]
  4089c8:	60ac      	str	r4, [r5, #8]
  4089ca:	666c      	str	r4, [r5, #100]	; 0x64
  4089cc:	81ec      	strh	r4, [r5, #14]
  4089ce:	612c      	str	r4, [r5, #16]
  4089d0:	616c      	str	r4, [r5, #20]
  4089d2:	61ac      	str	r4, [r5, #24]
  4089d4:	81ab      	strh	r3, [r5, #12]
  4089d6:	4621      	mov	r1, r4
  4089d8:	f105 005c 	add.w	r0, r5, #92	; 0x5c
  4089dc:	2208      	movs	r2, #8
  4089de:	f7fc fa2f 	bl	404e40 <memset>
  4089e2:	68be      	ldr	r6, [r7, #8]
  4089e4:	f8df b098 	ldr.w	fp, [pc, #152]	; 408a80 <__sinit.part.1+0xe0>
  4089e8:	f8df a098 	ldr.w	sl, [pc, #152]	; 408a84 <__sinit.part.1+0xe4>
  4089ec:	f8df 9098 	ldr.w	r9, [pc, #152]	; 408a88 <__sinit.part.1+0xe8>
  4089f0:	f8df 8098 	ldr.w	r8, [pc, #152]	; 408a8c <__sinit.part.1+0xec>
  4089f4:	f8c5 b020 	str.w	fp, [r5, #32]
  4089f8:	2301      	movs	r3, #1
  4089fa:	2209      	movs	r2, #9
  4089fc:	f8c5 a024 	str.w	sl, [r5, #36]	; 0x24
  408a00:	f8c5 9028 	str.w	r9, [r5, #40]	; 0x28
  408a04:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
  408a08:	61ed      	str	r5, [r5, #28]
  408a0a:	4621      	mov	r1, r4
  408a0c:	81f3      	strh	r3, [r6, #14]
  408a0e:	81b2      	strh	r2, [r6, #12]
  408a10:	f106 005c 	add.w	r0, r6, #92	; 0x5c
  408a14:	6034      	str	r4, [r6, #0]
  408a16:	6074      	str	r4, [r6, #4]
  408a18:	60b4      	str	r4, [r6, #8]
  408a1a:	6674      	str	r4, [r6, #100]	; 0x64
  408a1c:	6134      	str	r4, [r6, #16]
  408a1e:	6174      	str	r4, [r6, #20]
  408a20:	61b4      	str	r4, [r6, #24]
  408a22:	2208      	movs	r2, #8
  408a24:	9301      	str	r3, [sp, #4]
  408a26:	f7fc fa0b 	bl	404e40 <memset>
  408a2a:	68fd      	ldr	r5, [r7, #12]
  408a2c:	61f6      	str	r6, [r6, #28]
  408a2e:	2012      	movs	r0, #18
  408a30:	2202      	movs	r2, #2
  408a32:	f8c6 b020 	str.w	fp, [r6, #32]
  408a36:	f8c6 a024 	str.w	sl, [r6, #36]	; 0x24
  408a3a:	f8c6 9028 	str.w	r9, [r6, #40]	; 0x28
  408a3e:	f8c6 802c 	str.w	r8, [r6, #44]	; 0x2c
  408a42:	4621      	mov	r1, r4
  408a44:	81a8      	strh	r0, [r5, #12]
  408a46:	81ea      	strh	r2, [r5, #14]
  408a48:	602c      	str	r4, [r5, #0]
  408a4a:	606c      	str	r4, [r5, #4]
  408a4c:	60ac      	str	r4, [r5, #8]
  408a4e:	666c      	str	r4, [r5, #100]	; 0x64
  408a50:	612c      	str	r4, [r5, #16]
  408a52:	616c      	str	r4, [r5, #20]
  408a54:	61ac      	str	r4, [r5, #24]
  408a56:	f105 005c 	add.w	r0, r5, #92	; 0x5c
  408a5a:	2208      	movs	r2, #8
  408a5c:	f7fc f9f0 	bl	404e40 <memset>
  408a60:	9b01      	ldr	r3, [sp, #4]
  408a62:	61ed      	str	r5, [r5, #28]
  408a64:	f8c5 b020 	str.w	fp, [r5, #32]
  408a68:	f8c5 a024 	str.w	sl, [r5, #36]	; 0x24
  408a6c:	f8c5 9028 	str.w	r9, [r5, #40]	; 0x28
  408a70:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
  408a74:	63bb      	str	r3, [r7, #56]	; 0x38
  408a76:	b003      	add	sp, #12
  408a78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  408a7c:	00408995 	.word	0x00408995
  408a80:	0040a3f5 	.word	0x0040a3f5
  408a84:	0040a419 	.word	0x0040a419
  408a88:	0040a455 	.word	0x0040a455
  408a8c:	0040a475 	.word	0x0040a475

00408a90 <__sinit>:
  408a90:	6b83      	ldr	r3, [r0, #56]	; 0x38
  408a92:	b103      	cbz	r3, 408a96 <__sinit+0x6>
  408a94:	4770      	bx	lr
  408a96:	f7ff bf83 	b.w	4089a0 <__sinit.part.1>
  408a9a:	bf00      	nop

00408a9c <__sfp_lock_acquire>:
  408a9c:	4770      	bx	lr
  408a9e:	bf00      	nop

00408aa0 <__sfp_lock_release>:
  408aa0:	4770      	bx	lr
  408aa2:	bf00      	nop

00408aa4 <__libc_fini_array>:
  408aa4:	b538      	push	{r3, r4, r5, lr}
  408aa6:	4d07      	ldr	r5, [pc, #28]	; (408ac4 <__libc_fini_array+0x20>)
  408aa8:	4c07      	ldr	r4, [pc, #28]	; (408ac8 <__libc_fini_array+0x24>)
  408aaa:	1b2c      	subs	r4, r5, r4
  408aac:	10a4      	asrs	r4, r4, #2
  408aae:	d005      	beq.n	408abc <__libc_fini_array+0x18>
  408ab0:	3c01      	subs	r4, #1
  408ab2:	f855 3d04 	ldr.w	r3, [r5, #-4]!
  408ab6:	4798      	blx	r3
  408ab8:	2c00      	cmp	r4, #0
  408aba:	d1f9      	bne.n	408ab0 <__libc_fini_array+0xc>
  408abc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  408ac0:	f002 ba62 	b.w	40af88 <_fini>
  408ac4:	0040af98 	.word	0x0040af98
  408ac8:	0040af94 	.word	0x0040af94

00408acc <__fputwc>:
  408acc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  408ad0:	b082      	sub	sp, #8
  408ad2:	4680      	mov	r8, r0
  408ad4:	4689      	mov	r9, r1
  408ad6:	4614      	mov	r4, r2
  408ad8:	f000 fb3c 	bl	409154 <__locale_mb_cur_max>
  408adc:	2801      	cmp	r0, #1
  408ade:	d033      	beq.n	408b48 <__fputwc+0x7c>
  408ae0:	f104 035c 	add.w	r3, r4, #92	; 0x5c
  408ae4:	464a      	mov	r2, r9
  408ae6:	a901      	add	r1, sp, #4
  408ae8:	4640      	mov	r0, r8
  408aea:	f001 fd1d 	bl	40a528 <_wcrtomb_r>
  408aee:	f1b0 3fff 	cmp.w	r0, #4294967295
  408af2:	4682      	mov	sl, r0
  408af4:	d021      	beq.n	408b3a <__fputwc+0x6e>
  408af6:	b388      	cbz	r0, 408b5c <__fputwc+0x90>
  408af8:	f89d 6004 	ldrb.w	r6, [sp, #4]
  408afc:	2500      	movs	r5, #0
  408afe:	e008      	b.n	408b12 <__fputwc+0x46>
  408b00:	6823      	ldr	r3, [r4, #0]
  408b02:	1c5a      	adds	r2, r3, #1
  408b04:	6022      	str	r2, [r4, #0]
  408b06:	701e      	strb	r6, [r3, #0]
  408b08:	3501      	adds	r5, #1
  408b0a:	4555      	cmp	r5, sl
  408b0c:	d226      	bcs.n	408b5c <__fputwc+0x90>
  408b0e:	ab01      	add	r3, sp, #4
  408b10:	5d5e      	ldrb	r6, [r3, r5]
  408b12:	68a3      	ldr	r3, [r4, #8]
  408b14:	3b01      	subs	r3, #1
  408b16:	2b00      	cmp	r3, #0
  408b18:	60a3      	str	r3, [r4, #8]
  408b1a:	daf1      	bge.n	408b00 <__fputwc+0x34>
  408b1c:	69a7      	ldr	r7, [r4, #24]
  408b1e:	42bb      	cmp	r3, r7
  408b20:	4631      	mov	r1, r6
  408b22:	4622      	mov	r2, r4
  408b24:	4640      	mov	r0, r8
  408b26:	db01      	blt.n	408b2c <__fputwc+0x60>
  408b28:	2e0a      	cmp	r6, #10
  408b2a:	d1e9      	bne.n	408b00 <__fputwc+0x34>
  408b2c:	f001 fca6 	bl	40a47c <__swbuf_r>
  408b30:	1c43      	adds	r3, r0, #1
  408b32:	d1e9      	bne.n	408b08 <__fputwc+0x3c>
  408b34:	b002      	add	sp, #8
  408b36:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  408b3a:	89a3      	ldrh	r3, [r4, #12]
  408b3c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  408b40:	81a3      	strh	r3, [r4, #12]
  408b42:	b002      	add	sp, #8
  408b44:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  408b48:	f109 33ff 	add.w	r3, r9, #4294967295
  408b4c:	2bfe      	cmp	r3, #254	; 0xfe
  408b4e:	d8c7      	bhi.n	408ae0 <__fputwc+0x14>
  408b50:	fa5f f689 	uxtb.w	r6, r9
  408b54:	4682      	mov	sl, r0
  408b56:	f88d 6004 	strb.w	r6, [sp, #4]
  408b5a:	e7cf      	b.n	408afc <__fputwc+0x30>
  408b5c:	4648      	mov	r0, r9
  408b5e:	b002      	add	sp, #8
  408b60:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00408b64 <_fputwc_r>:
  408b64:	f9b2 300c 	ldrsh.w	r3, [r2, #12]
  408b68:	f413 5f00 	tst.w	r3, #8192	; 0x2000
  408b6c:	d10a      	bne.n	408b84 <_fputwc_r+0x20>
  408b6e:	b410      	push	{r4}
  408b70:	6e54      	ldr	r4, [r2, #100]	; 0x64
  408b72:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  408b76:	f444 5400 	orr.w	r4, r4, #8192	; 0x2000
  408b7a:	6654      	str	r4, [r2, #100]	; 0x64
  408b7c:	8193      	strh	r3, [r2, #12]
  408b7e:	bc10      	pop	{r4}
  408b80:	f7ff bfa4 	b.w	408acc <__fputwc>
  408b84:	f7ff bfa2 	b.w	408acc <__fputwc>

00408b88 <_malloc_trim_r>:
  408b88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  408b8a:	4f23      	ldr	r7, [pc, #140]	; (408c18 <_malloc_trim_r+0x90>)
  408b8c:	460c      	mov	r4, r1
  408b8e:	4606      	mov	r6, r0
  408b90:	f000 fed2 	bl	409938 <__malloc_lock>
  408b94:	68bb      	ldr	r3, [r7, #8]
  408b96:	685d      	ldr	r5, [r3, #4]
  408b98:	f025 0503 	bic.w	r5, r5, #3
  408b9c:	1b29      	subs	r1, r5, r4
  408b9e:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
  408ba2:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
  408ba6:	f021 010f 	bic.w	r1, r1, #15
  408baa:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
  408bae:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
  408bb2:	db07      	blt.n	408bc4 <_malloc_trim_r+0x3c>
  408bb4:	2100      	movs	r1, #0
  408bb6:	4630      	mov	r0, r6
  408bb8:	f001 fbc0 	bl	40a33c <_sbrk_r>
  408bbc:	68bb      	ldr	r3, [r7, #8]
  408bbe:	442b      	add	r3, r5
  408bc0:	4298      	cmp	r0, r3
  408bc2:	d004      	beq.n	408bce <_malloc_trim_r+0x46>
  408bc4:	4630      	mov	r0, r6
  408bc6:	f000 feb9 	bl	40993c <__malloc_unlock>
  408bca:	2000      	movs	r0, #0
  408bcc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  408bce:	4261      	negs	r1, r4
  408bd0:	4630      	mov	r0, r6
  408bd2:	f001 fbb3 	bl	40a33c <_sbrk_r>
  408bd6:	3001      	adds	r0, #1
  408bd8:	d00d      	beq.n	408bf6 <_malloc_trim_r+0x6e>
  408bda:	4b10      	ldr	r3, [pc, #64]	; (408c1c <_malloc_trim_r+0x94>)
  408bdc:	68ba      	ldr	r2, [r7, #8]
  408bde:	6819      	ldr	r1, [r3, #0]
  408be0:	1b2d      	subs	r5, r5, r4
  408be2:	f045 0501 	orr.w	r5, r5, #1
  408be6:	4630      	mov	r0, r6
  408be8:	1b09      	subs	r1, r1, r4
  408bea:	6055      	str	r5, [r2, #4]
  408bec:	6019      	str	r1, [r3, #0]
  408bee:	f000 fea5 	bl	40993c <__malloc_unlock>
  408bf2:	2001      	movs	r0, #1
  408bf4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  408bf6:	2100      	movs	r1, #0
  408bf8:	4630      	mov	r0, r6
  408bfa:	f001 fb9f 	bl	40a33c <_sbrk_r>
  408bfe:	68ba      	ldr	r2, [r7, #8]
  408c00:	1a83      	subs	r3, r0, r2
  408c02:	2b0f      	cmp	r3, #15
  408c04:	ddde      	ble.n	408bc4 <_malloc_trim_r+0x3c>
  408c06:	4c06      	ldr	r4, [pc, #24]	; (408c20 <_malloc_trim_r+0x98>)
  408c08:	4904      	ldr	r1, [pc, #16]	; (408c1c <_malloc_trim_r+0x94>)
  408c0a:	6824      	ldr	r4, [r4, #0]
  408c0c:	f043 0301 	orr.w	r3, r3, #1
  408c10:	1b00      	subs	r0, r0, r4
  408c12:	6053      	str	r3, [r2, #4]
  408c14:	6008      	str	r0, [r1, #0]
  408c16:	e7d5      	b.n	408bc4 <_malloc_trim_r+0x3c>
  408c18:	20400498 	.word	0x20400498
  408c1c:	2040c454 	.word	0x2040c454
  408c20:	204008a4 	.word	0x204008a4

00408c24 <_free_r>:
  408c24:	2900      	cmp	r1, #0
  408c26:	d045      	beq.n	408cb4 <_free_r+0x90>
  408c28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  408c2c:	460d      	mov	r5, r1
  408c2e:	4680      	mov	r8, r0
  408c30:	f000 fe82 	bl	409938 <__malloc_lock>
  408c34:	f855 7c04 	ldr.w	r7, [r5, #-4]
  408c38:	496a      	ldr	r1, [pc, #424]	; (408de4 <_free_r+0x1c0>)
  408c3a:	f027 0301 	bic.w	r3, r7, #1
  408c3e:	f1a5 0408 	sub.w	r4, r5, #8
  408c42:	18e2      	adds	r2, r4, r3
  408c44:	688e      	ldr	r6, [r1, #8]
  408c46:	6850      	ldr	r0, [r2, #4]
  408c48:	42b2      	cmp	r2, r6
  408c4a:	f020 0003 	bic.w	r0, r0, #3
  408c4e:	d062      	beq.n	408d16 <_free_r+0xf2>
  408c50:	07fe      	lsls	r6, r7, #31
  408c52:	6050      	str	r0, [r2, #4]
  408c54:	d40b      	bmi.n	408c6e <_free_r+0x4a>
  408c56:	f855 7c08 	ldr.w	r7, [r5, #-8]
  408c5a:	1be4      	subs	r4, r4, r7
  408c5c:	f101 0e08 	add.w	lr, r1, #8
  408c60:	68a5      	ldr	r5, [r4, #8]
  408c62:	4575      	cmp	r5, lr
  408c64:	443b      	add	r3, r7
  408c66:	d06f      	beq.n	408d48 <_free_r+0x124>
  408c68:	68e7      	ldr	r7, [r4, #12]
  408c6a:	60ef      	str	r7, [r5, #12]
  408c6c:	60bd      	str	r5, [r7, #8]
  408c6e:	1815      	adds	r5, r2, r0
  408c70:	686d      	ldr	r5, [r5, #4]
  408c72:	07ed      	lsls	r5, r5, #31
  408c74:	d542      	bpl.n	408cfc <_free_r+0xd8>
  408c76:	f043 0201 	orr.w	r2, r3, #1
  408c7a:	6062      	str	r2, [r4, #4]
  408c7c:	50e3      	str	r3, [r4, r3]
  408c7e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  408c82:	d218      	bcs.n	408cb6 <_free_r+0x92>
  408c84:	08db      	lsrs	r3, r3, #3
  408c86:	1c5a      	adds	r2, r3, #1
  408c88:	684d      	ldr	r5, [r1, #4]
  408c8a:	f851 7032 	ldr.w	r7, [r1, r2, lsl #3]
  408c8e:	60a7      	str	r7, [r4, #8]
  408c90:	2001      	movs	r0, #1
  408c92:	109b      	asrs	r3, r3, #2
  408c94:	fa00 f303 	lsl.w	r3, r0, r3
  408c98:	eb01 00c2 	add.w	r0, r1, r2, lsl #3
  408c9c:	431d      	orrs	r5, r3
  408c9e:	3808      	subs	r0, #8
  408ca0:	60e0      	str	r0, [r4, #12]
  408ca2:	604d      	str	r5, [r1, #4]
  408ca4:	f841 4032 	str.w	r4, [r1, r2, lsl #3]
  408ca8:	60fc      	str	r4, [r7, #12]
  408caa:	4640      	mov	r0, r8
  408cac:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  408cb0:	f000 be44 	b.w	40993c <__malloc_unlock>
  408cb4:	4770      	bx	lr
  408cb6:	0a5a      	lsrs	r2, r3, #9
  408cb8:	2a04      	cmp	r2, #4
  408cba:	d853      	bhi.n	408d64 <_free_r+0x140>
  408cbc:	099a      	lsrs	r2, r3, #6
  408cbe:	f102 0739 	add.w	r7, r2, #57	; 0x39
  408cc2:	007f      	lsls	r7, r7, #1
  408cc4:	f102 0538 	add.w	r5, r2, #56	; 0x38
  408cc8:	eb01 0087 	add.w	r0, r1, r7, lsl #2
  408ccc:	f851 2027 	ldr.w	r2, [r1, r7, lsl #2]
  408cd0:	4944      	ldr	r1, [pc, #272]	; (408de4 <_free_r+0x1c0>)
  408cd2:	3808      	subs	r0, #8
  408cd4:	4290      	cmp	r0, r2
  408cd6:	d04d      	beq.n	408d74 <_free_r+0x150>
  408cd8:	6851      	ldr	r1, [r2, #4]
  408cda:	f021 0103 	bic.w	r1, r1, #3
  408cde:	428b      	cmp	r3, r1
  408ce0:	d202      	bcs.n	408ce8 <_free_r+0xc4>
  408ce2:	6892      	ldr	r2, [r2, #8]
  408ce4:	4290      	cmp	r0, r2
  408ce6:	d1f7      	bne.n	408cd8 <_free_r+0xb4>
  408ce8:	68d0      	ldr	r0, [r2, #12]
  408cea:	60e0      	str	r0, [r4, #12]
  408cec:	60a2      	str	r2, [r4, #8]
  408cee:	6084      	str	r4, [r0, #8]
  408cf0:	60d4      	str	r4, [r2, #12]
  408cf2:	4640      	mov	r0, r8
  408cf4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  408cf8:	f000 be20 	b.w	40993c <__malloc_unlock>
  408cfc:	6895      	ldr	r5, [r2, #8]
  408cfe:	4f3a      	ldr	r7, [pc, #232]	; (408de8 <_free_r+0x1c4>)
  408d00:	42bd      	cmp	r5, r7
  408d02:	4403      	add	r3, r0
  408d04:	d03f      	beq.n	408d86 <_free_r+0x162>
  408d06:	68d0      	ldr	r0, [r2, #12]
  408d08:	60e8      	str	r0, [r5, #12]
  408d0a:	f043 0201 	orr.w	r2, r3, #1
  408d0e:	6085      	str	r5, [r0, #8]
  408d10:	6062      	str	r2, [r4, #4]
  408d12:	50e3      	str	r3, [r4, r3]
  408d14:	e7b3      	b.n	408c7e <_free_r+0x5a>
  408d16:	07ff      	lsls	r7, r7, #31
  408d18:	4403      	add	r3, r0
  408d1a:	d407      	bmi.n	408d2c <_free_r+0x108>
  408d1c:	f855 2c08 	ldr.w	r2, [r5, #-8]
  408d20:	1aa4      	subs	r4, r4, r2
  408d22:	4413      	add	r3, r2
  408d24:	68a0      	ldr	r0, [r4, #8]
  408d26:	68e2      	ldr	r2, [r4, #12]
  408d28:	60c2      	str	r2, [r0, #12]
  408d2a:	6090      	str	r0, [r2, #8]
  408d2c:	4a2f      	ldr	r2, [pc, #188]	; (408dec <_free_r+0x1c8>)
  408d2e:	6812      	ldr	r2, [r2, #0]
  408d30:	f043 0001 	orr.w	r0, r3, #1
  408d34:	4293      	cmp	r3, r2
  408d36:	6060      	str	r0, [r4, #4]
  408d38:	608c      	str	r4, [r1, #8]
  408d3a:	d3b6      	bcc.n	408caa <_free_r+0x86>
  408d3c:	4b2c      	ldr	r3, [pc, #176]	; (408df0 <_free_r+0x1cc>)
  408d3e:	4640      	mov	r0, r8
  408d40:	6819      	ldr	r1, [r3, #0]
  408d42:	f7ff ff21 	bl	408b88 <_malloc_trim_r>
  408d46:	e7b0      	b.n	408caa <_free_r+0x86>
  408d48:	1811      	adds	r1, r2, r0
  408d4a:	6849      	ldr	r1, [r1, #4]
  408d4c:	07c9      	lsls	r1, r1, #31
  408d4e:	d444      	bmi.n	408dda <_free_r+0x1b6>
  408d50:	6891      	ldr	r1, [r2, #8]
  408d52:	68d2      	ldr	r2, [r2, #12]
  408d54:	60ca      	str	r2, [r1, #12]
  408d56:	4403      	add	r3, r0
  408d58:	f043 0001 	orr.w	r0, r3, #1
  408d5c:	6091      	str	r1, [r2, #8]
  408d5e:	6060      	str	r0, [r4, #4]
  408d60:	50e3      	str	r3, [r4, r3]
  408d62:	e7a2      	b.n	408caa <_free_r+0x86>
  408d64:	2a14      	cmp	r2, #20
  408d66:	d817      	bhi.n	408d98 <_free_r+0x174>
  408d68:	f102 075c 	add.w	r7, r2, #92	; 0x5c
  408d6c:	007f      	lsls	r7, r7, #1
  408d6e:	f102 055b 	add.w	r5, r2, #91	; 0x5b
  408d72:	e7a9      	b.n	408cc8 <_free_r+0xa4>
  408d74:	10aa      	asrs	r2, r5, #2
  408d76:	684b      	ldr	r3, [r1, #4]
  408d78:	2501      	movs	r5, #1
  408d7a:	fa05 f202 	lsl.w	r2, r5, r2
  408d7e:	4313      	orrs	r3, r2
  408d80:	604b      	str	r3, [r1, #4]
  408d82:	4602      	mov	r2, r0
  408d84:	e7b1      	b.n	408cea <_free_r+0xc6>
  408d86:	f043 0201 	orr.w	r2, r3, #1
  408d8a:	614c      	str	r4, [r1, #20]
  408d8c:	610c      	str	r4, [r1, #16]
  408d8e:	60e5      	str	r5, [r4, #12]
  408d90:	60a5      	str	r5, [r4, #8]
  408d92:	6062      	str	r2, [r4, #4]
  408d94:	50e3      	str	r3, [r4, r3]
  408d96:	e788      	b.n	408caa <_free_r+0x86>
  408d98:	2a54      	cmp	r2, #84	; 0x54
  408d9a:	d806      	bhi.n	408daa <_free_r+0x186>
  408d9c:	0b1a      	lsrs	r2, r3, #12
  408d9e:	f102 076f 	add.w	r7, r2, #111	; 0x6f
  408da2:	007f      	lsls	r7, r7, #1
  408da4:	f102 056e 	add.w	r5, r2, #110	; 0x6e
  408da8:	e78e      	b.n	408cc8 <_free_r+0xa4>
  408daa:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
  408dae:	d806      	bhi.n	408dbe <_free_r+0x19a>
  408db0:	0bda      	lsrs	r2, r3, #15
  408db2:	f102 0778 	add.w	r7, r2, #120	; 0x78
  408db6:	007f      	lsls	r7, r7, #1
  408db8:	f102 0577 	add.w	r5, r2, #119	; 0x77
  408dbc:	e784      	b.n	408cc8 <_free_r+0xa4>
  408dbe:	f240 5054 	movw	r0, #1364	; 0x554
  408dc2:	4282      	cmp	r2, r0
  408dc4:	d806      	bhi.n	408dd4 <_free_r+0x1b0>
  408dc6:	0c9a      	lsrs	r2, r3, #18
  408dc8:	f102 077d 	add.w	r7, r2, #125	; 0x7d
  408dcc:	007f      	lsls	r7, r7, #1
  408dce:	f102 057c 	add.w	r5, r2, #124	; 0x7c
  408dd2:	e779      	b.n	408cc8 <_free_r+0xa4>
  408dd4:	27fe      	movs	r7, #254	; 0xfe
  408dd6:	257e      	movs	r5, #126	; 0x7e
  408dd8:	e776      	b.n	408cc8 <_free_r+0xa4>
  408dda:	f043 0201 	orr.w	r2, r3, #1
  408dde:	6062      	str	r2, [r4, #4]
  408de0:	50e3      	str	r3, [r4, r3]
  408de2:	e762      	b.n	408caa <_free_r+0x86>
  408de4:	20400498 	.word	0x20400498
  408de8:	204004a0 	.word	0x204004a0
  408dec:	204008a0 	.word	0x204008a0
  408df0:	2040c450 	.word	0x2040c450

00408df4 <__sfvwrite_r>:
  408df4:	6893      	ldr	r3, [r2, #8]
  408df6:	2b00      	cmp	r3, #0
  408df8:	d076      	beq.n	408ee8 <__sfvwrite_r+0xf4>
  408dfa:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  408dfe:	898b      	ldrh	r3, [r1, #12]
  408e00:	b085      	sub	sp, #20
  408e02:	460c      	mov	r4, r1
  408e04:	0719      	lsls	r1, r3, #28
  408e06:	9001      	str	r0, [sp, #4]
  408e08:	4616      	mov	r6, r2
  408e0a:	d529      	bpl.n	408e60 <__sfvwrite_r+0x6c>
  408e0c:	6922      	ldr	r2, [r4, #16]
  408e0e:	b33a      	cbz	r2, 408e60 <__sfvwrite_r+0x6c>
  408e10:	f003 0802 	and.w	r8, r3, #2
  408e14:	fa1f f088 	uxth.w	r0, r8
  408e18:	6835      	ldr	r5, [r6, #0]
  408e1a:	2800      	cmp	r0, #0
  408e1c:	d02f      	beq.n	408e7e <__sfvwrite_r+0x8a>
  408e1e:	f04f 0900 	mov.w	r9, #0
  408e22:	4fb4      	ldr	r7, [pc, #720]	; (4090f4 <__sfvwrite_r+0x300>)
  408e24:	46c8      	mov	r8, r9
  408e26:	46b2      	mov	sl, r6
  408e28:	45b8      	cmp	r8, r7
  408e2a:	4643      	mov	r3, r8
  408e2c:	464a      	mov	r2, r9
  408e2e:	bf28      	it	cs
  408e30:	463b      	movcs	r3, r7
  408e32:	9801      	ldr	r0, [sp, #4]
  408e34:	f1b8 0f00 	cmp.w	r8, #0
  408e38:	d050      	beq.n	408edc <__sfvwrite_r+0xe8>
  408e3a:	69e1      	ldr	r1, [r4, #28]
  408e3c:	6a66      	ldr	r6, [r4, #36]	; 0x24
  408e3e:	47b0      	blx	r6
  408e40:	2800      	cmp	r0, #0
  408e42:	dd71      	ble.n	408f28 <__sfvwrite_r+0x134>
  408e44:	f8da 3008 	ldr.w	r3, [sl, #8]
  408e48:	1a1b      	subs	r3, r3, r0
  408e4a:	4481      	add	r9, r0
  408e4c:	ebc0 0808 	rsb	r8, r0, r8
  408e50:	f8ca 3008 	str.w	r3, [sl, #8]
  408e54:	2b00      	cmp	r3, #0
  408e56:	d1e7      	bne.n	408e28 <__sfvwrite_r+0x34>
  408e58:	2000      	movs	r0, #0
  408e5a:	b005      	add	sp, #20
  408e5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  408e60:	4621      	mov	r1, r4
  408e62:	9801      	ldr	r0, [sp, #4]
  408e64:	f7fe fca0 	bl	4077a8 <__swsetup_r>
  408e68:	2800      	cmp	r0, #0
  408e6a:	f040 813a 	bne.w	4090e2 <__sfvwrite_r+0x2ee>
  408e6e:	89a3      	ldrh	r3, [r4, #12]
  408e70:	6835      	ldr	r5, [r6, #0]
  408e72:	f003 0802 	and.w	r8, r3, #2
  408e76:	fa1f f088 	uxth.w	r0, r8
  408e7a:	2800      	cmp	r0, #0
  408e7c:	d1cf      	bne.n	408e1e <__sfvwrite_r+0x2a>
  408e7e:	f013 0901 	ands.w	r9, r3, #1
  408e82:	d15b      	bne.n	408f3c <__sfvwrite_r+0x148>
  408e84:	464f      	mov	r7, r9
  408e86:	9602      	str	r6, [sp, #8]
  408e88:	b31f      	cbz	r7, 408ed2 <__sfvwrite_r+0xde>
  408e8a:	059a      	lsls	r2, r3, #22
  408e8c:	f8d4 8008 	ldr.w	r8, [r4, #8]
  408e90:	d52c      	bpl.n	408eec <__sfvwrite_r+0xf8>
  408e92:	4547      	cmp	r7, r8
  408e94:	46c2      	mov	sl, r8
  408e96:	f0c0 80a4 	bcc.w	408fe2 <__sfvwrite_r+0x1ee>
  408e9a:	f413 6f90 	tst.w	r3, #1152	; 0x480
  408e9e:	f040 80b1 	bne.w	409004 <__sfvwrite_r+0x210>
  408ea2:	6820      	ldr	r0, [r4, #0]
  408ea4:	4652      	mov	r2, sl
  408ea6:	4649      	mov	r1, r9
  408ea8:	f000 fce2 	bl	409870 <memmove>
  408eac:	68a0      	ldr	r0, [r4, #8]
  408eae:	6823      	ldr	r3, [r4, #0]
  408eb0:	ebc8 0000 	rsb	r0, r8, r0
  408eb4:	4453      	add	r3, sl
  408eb6:	60a0      	str	r0, [r4, #8]
  408eb8:	6023      	str	r3, [r4, #0]
  408eba:	4638      	mov	r0, r7
  408ebc:	9a02      	ldr	r2, [sp, #8]
  408ebe:	6893      	ldr	r3, [r2, #8]
  408ec0:	1a1b      	subs	r3, r3, r0
  408ec2:	4481      	add	r9, r0
  408ec4:	1a3f      	subs	r7, r7, r0
  408ec6:	6093      	str	r3, [r2, #8]
  408ec8:	2b00      	cmp	r3, #0
  408eca:	d0c5      	beq.n	408e58 <__sfvwrite_r+0x64>
  408ecc:	89a3      	ldrh	r3, [r4, #12]
  408ece:	2f00      	cmp	r7, #0
  408ed0:	d1db      	bne.n	408e8a <__sfvwrite_r+0x96>
  408ed2:	f8d5 9000 	ldr.w	r9, [r5]
  408ed6:	686f      	ldr	r7, [r5, #4]
  408ed8:	3508      	adds	r5, #8
  408eda:	e7d5      	b.n	408e88 <__sfvwrite_r+0x94>
  408edc:	f8d5 9000 	ldr.w	r9, [r5]
  408ee0:	f8d5 8004 	ldr.w	r8, [r5, #4]
  408ee4:	3508      	adds	r5, #8
  408ee6:	e79f      	b.n	408e28 <__sfvwrite_r+0x34>
  408ee8:	2000      	movs	r0, #0
  408eea:	4770      	bx	lr
  408eec:	6820      	ldr	r0, [r4, #0]
  408eee:	6923      	ldr	r3, [r4, #16]
  408ef0:	4298      	cmp	r0, r3
  408ef2:	d803      	bhi.n	408efc <__sfvwrite_r+0x108>
  408ef4:	6961      	ldr	r1, [r4, #20]
  408ef6:	428f      	cmp	r7, r1
  408ef8:	f080 80b7 	bcs.w	40906a <__sfvwrite_r+0x276>
  408efc:	45b8      	cmp	r8, r7
  408efe:	bf28      	it	cs
  408f00:	46b8      	movcs	r8, r7
  408f02:	4642      	mov	r2, r8
  408f04:	4649      	mov	r1, r9
  408f06:	f000 fcb3 	bl	409870 <memmove>
  408f0a:	68a3      	ldr	r3, [r4, #8]
  408f0c:	6822      	ldr	r2, [r4, #0]
  408f0e:	ebc8 0303 	rsb	r3, r8, r3
  408f12:	4442      	add	r2, r8
  408f14:	60a3      	str	r3, [r4, #8]
  408f16:	6022      	str	r2, [r4, #0]
  408f18:	2b00      	cmp	r3, #0
  408f1a:	d149      	bne.n	408fb0 <__sfvwrite_r+0x1bc>
  408f1c:	4621      	mov	r1, r4
  408f1e:	9801      	ldr	r0, [sp, #4]
  408f20:	f7ff fd22 	bl	408968 <_fflush_r>
  408f24:	2800      	cmp	r0, #0
  408f26:	d043      	beq.n	408fb0 <__sfvwrite_r+0x1bc>
  408f28:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  408f2c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  408f30:	f04f 30ff 	mov.w	r0, #4294967295
  408f34:	81a3      	strh	r3, [r4, #12]
  408f36:	b005      	add	sp, #20
  408f38:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  408f3c:	4680      	mov	r8, r0
  408f3e:	9002      	str	r0, [sp, #8]
  408f40:	4682      	mov	sl, r0
  408f42:	4681      	mov	r9, r0
  408f44:	f1b9 0f00 	cmp.w	r9, #0
  408f48:	d02a      	beq.n	408fa0 <__sfvwrite_r+0x1ac>
  408f4a:	9b02      	ldr	r3, [sp, #8]
  408f4c:	2b00      	cmp	r3, #0
  408f4e:	d04c      	beq.n	408fea <__sfvwrite_r+0x1f6>
  408f50:	6820      	ldr	r0, [r4, #0]
  408f52:	6923      	ldr	r3, [r4, #16]
  408f54:	6962      	ldr	r2, [r4, #20]
  408f56:	45c8      	cmp	r8, r9
  408f58:	46c3      	mov	fp, r8
  408f5a:	bf28      	it	cs
  408f5c:	46cb      	movcs	fp, r9
  408f5e:	4298      	cmp	r0, r3
  408f60:	465f      	mov	r7, fp
  408f62:	d904      	bls.n	408f6e <__sfvwrite_r+0x17a>
  408f64:	68a3      	ldr	r3, [r4, #8]
  408f66:	4413      	add	r3, r2
  408f68:	459b      	cmp	fp, r3
  408f6a:	f300 8090 	bgt.w	40908e <__sfvwrite_r+0x29a>
  408f6e:	4593      	cmp	fp, r2
  408f70:	db20      	blt.n	408fb4 <__sfvwrite_r+0x1c0>
  408f72:	4613      	mov	r3, r2
  408f74:	6a67      	ldr	r7, [r4, #36]	; 0x24
  408f76:	69e1      	ldr	r1, [r4, #28]
  408f78:	9801      	ldr	r0, [sp, #4]
  408f7a:	4652      	mov	r2, sl
  408f7c:	47b8      	blx	r7
  408f7e:	1e07      	subs	r7, r0, #0
  408f80:	ddd2      	ble.n	408f28 <__sfvwrite_r+0x134>
  408f82:	ebb8 0807 	subs.w	r8, r8, r7
  408f86:	d023      	beq.n	408fd0 <__sfvwrite_r+0x1dc>
  408f88:	68b3      	ldr	r3, [r6, #8]
  408f8a:	1bdb      	subs	r3, r3, r7
  408f8c:	44ba      	add	sl, r7
  408f8e:	ebc7 0909 	rsb	r9, r7, r9
  408f92:	60b3      	str	r3, [r6, #8]
  408f94:	2b00      	cmp	r3, #0
  408f96:	f43f af5f 	beq.w	408e58 <__sfvwrite_r+0x64>
  408f9a:	f1b9 0f00 	cmp.w	r9, #0
  408f9e:	d1d4      	bne.n	408f4a <__sfvwrite_r+0x156>
  408fa0:	2300      	movs	r3, #0
  408fa2:	f8d5 a000 	ldr.w	sl, [r5]
  408fa6:	f8d5 9004 	ldr.w	r9, [r5, #4]
  408faa:	9302      	str	r3, [sp, #8]
  408fac:	3508      	adds	r5, #8
  408fae:	e7c9      	b.n	408f44 <__sfvwrite_r+0x150>
  408fb0:	4640      	mov	r0, r8
  408fb2:	e783      	b.n	408ebc <__sfvwrite_r+0xc8>
  408fb4:	465a      	mov	r2, fp
  408fb6:	4651      	mov	r1, sl
  408fb8:	f000 fc5a 	bl	409870 <memmove>
  408fbc:	68a2      	ldr	r2, [r4, #8]
  408fbe:	6823      	ldr	r3, [r4, #0]
  408fc0:	ebcb 0202 	rsb	r2, fp, r2
  408fc4:	445b      	add	r3, fp
  408fc6:	ebb8 0807 	subs.w	r8, r8, r7
  408fca:	60a2      	str	r2, [r4, #8]
  408fcc:	6023      	str	r3, [r4, #0]
  408fce:	d1db      	bne.n	408f88 <__sfvwrite_r+0x194>
  408fd0:	4621      	mov	r1, r4
  408fd2:	9801      	ldr	r0, [sp, #4]
  408fd4:	f7ff fcc8 	bl	408968 <_fflush_r>
  408fd8:	2800      	cmp	r0, #0
  408fda:	d1a5      	bne.n	408f28 <__sfvwrite_r+0x134>
  408fdc:	f8cd 8008 	str.w	r8, [sp, #8]
  408fe0:	e7d2      	b.n	408f88 <__sfvwrite_r+0x194>
  408fe2:	6820      	ldr	r0, [r4, #0]
  408fe4:	46b8      	mov	r8, r7
  408fe6:	46ba      	mov	sl, r7
  408fe8:	e75c      	b.n	408ea4 <__sfvwrite_r+0xb0>
  408fea:	464a      	mov	r2, r9
  408fec:	210a      	movs	r1, #10
  408fee:	4650      	mov	r0, sl
  408ff0:	f000 fbee 	bl	4097d0 <memchr>
  408ff4:	2800      	cmp	r0, #0
  408ff6:	d06f      	beq.n	4090d8 <__sfvwrite_r+0x2e4>
  408ff8:	3001      	adds	r0, #1
  408ffa:	2301      	movs	r3, #1
  408ffc:	ebca 0800 	rsb	r8, sl, r0
  409000:	9302      	str	r3, [sp, #8]
  409002:	e7a5      	b.n	408f50 <__sfvwrite_r+0x15c>
  409004:	6962      	ldr	r2, [r4, #20]
  409006:	6820      	ldr	r0, [r4, #0]
  409008:	6921      	ldr	r1, [r4, #16]
  40900a:	eb02 0842 	add.w	r8, r2, r2, lsl #1
  40900e:	ebc1 0a00 	rsb	sl, r1, r0
  409012:	eb08 78d8 	add.w	r8, r8, r8, lsr #31
  409016:	f10a 0001 	add.w	r0, sl, #1
  40901a:	ea4f 0868 	mov.w	r8, r8, asr #1
  40901e:	4438      	add	r0, r7
  409020:	4540      	cmp	r0, r8
  409022:	4642      	mov	r2, r8
  409024:	bf84      	itt	hi
  409026:	4680      	movhi	r8, r0
  409028:	4642      	movhi	r2, r8
  40902a:	055b      	lsls	r3, r3, #21
  40902c:	d542      	bpl.n	4090b4 <__sfvwrite_r+0x2c0>
  40902e:	4611      	mov	r1, r2
  409030:	9801      	ldr	r0, [sp, #4]
  409032:	f000 f915 	bl	409260 <_malloc_r>
  409036:	4683      	mov	fp, r0
  409038:	2800      	cmp	r0, #0
  40903a:	d055      	beq.n	4090e8 <__sfvwrite_r+0x2f4>
  40903c:	4652      	mov	r2, sl
  40903e:	6921      	ldr	r1, [r4, #16]
  409040:	f7fb fe64 	bl	404d0c <memcpy>
  409044:	89a3      	ldrh	r3, [r4, #12]
  409046:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
  40904a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  40904e:	81a3      	strh	r3, [r4, #12]
  409050:	ebca 0308 	rsb	r3, sl, r8
  409054:	eb0b 000a 	add.w	r0, fp, sl
  409058:	f8c4 8014 	str.w	r8, [r4, #20]
  40905c:	f8c4 b010 	str.w	fp, [r4, #16]
  409060:	6020      	str	r0, [r4, #0]
  409062:	60a3      	str	r3, [r4, #8]
  409064:	46b8      	mov	r8, r7
  409066:	46ba      	mov	sl, r7
  409068:	e71c      	b.n	408ea4 <__sfvwrite_r+0xb0>
  40906a:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
  40906e:	42bb      	cmp	r3, r7
  409070:	bf28      	it	cs
  409072:	463b      	movcs	r3, r7
  409074:	464a      	mov	r2, r9
  409076:	fb93 f3f1 	sdiv	r3, r3, r1
  40907a:	9801      	ldr	r0, [sp, #4]
  40907c:	6a66      	ldr	r6, [r4, #36]	; 0x24
  40907e:	fb01 f303 	mul.w	r3, r1, r3
  409082:	69e1      	ldr	r1, [r4, #28]
  409084:	47b0      	blx	r6
  409086:	2800      	cmp	r0, #0
  409088:	f73f af18 	bgt.w	408ebc <__sfvwrite_r+0xc8>
  40908c:	e74c      	b.n	408f28 <__sfvwrite_r+0x134>
  40908e:	461a      	mov	r2, r3
  409090:	4651      	mov	r1, sl
  409092:	9303      	str	r3, [sp, #12]
  409094:	f000 fbec 	bl	409870 <memmove>
  409098:	6822      	ldr	r2, [r4, #0]
  40909a:	9b03      	ldr	r3, [sp, #12]
  40909c:	9801      	ldr	r0, [sp, #4]
  40909e:	441a      	add	r2, r3
  4090a0:	6022      	str	r2, [r4, #0]
  4090a2:	4621      	mov	r1, r4
  4090a4:	f7ff fc60 	bl	408968 <_fflush_r>
  4090a8:	9b03      	ldr	r3, [sp, #12]
  4090aa:	2800      	cmp	r0, #0
  4090ac:	f47f af3c 	bne.w	408f28 <__sfvwrite_r+0x134>
  4090b0:	461f      	mov	r7, r3
  4090b2:	e766      	b.n	408f82 <__sfvwrite_r+0x18e>
  4090b4:	9801      	ldr	r0, [sp, #4]
  4090b6:	f000 ff51 	bl	409f5c <_realloc_r>
  4090ba:	4683      	mov	fp, r0
  4090bc:	2800      	cmp	r0, #0
  4090be:	d1c7      	bne.n	409050 <__sfvwrite_r+0x25c>
  4090c0:	9d01      	ldr	r5, [sp, #4]
  4090c2:	6921      	ldr	r1, [r4, #16]
  4090c4:	4628      	mov	r0, r5
  4090c6:	f7ff fdad 	bl	408c24 <_free_r>
  4090ca:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  4090ce:	220c      	movs	r2, #12
  4090d0:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  4090d4:	602a      	str	r2, [r5, #0]
  4090d6:	e729      	b.n	408f2c <__sfvwrite_r+0x138>
  4090d8:	2301      	movs	r3, #1
  4090da:	f109 0801 	add.w	r8, r9, #1
  4090de:	9302      	str	r3, [sp, #8]
  4090e0:	e736      	b.n	408f50 <__sfvwrite_r+0x15c>
  4090e2:	f04f 30ff 	mov.w	r0, #4294967295
  4090e6:	e6b8      	b.n	408e5a <__sfvwrite_r+0x66>
  4090e8:	9a01      	ldr	r2, [sp, #4]
  4090ea:	230c      	movs	r3, #12
  4090ec:	6013      	str	r3, [r2, #0]
  4090ee:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  4090f2:	e71b      	b.n	408f2c <__sfvwrite_r+0x138>
  4090f4:	7ffffc00 	.word	0x7ffffc00

004090f8 <_fwalk_reent>:
  4090f8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  4090fc:	f510 7738 	adds.w	r7, r0, #736	; 0x2e0
  409100:	d01f      	beq.n	409142 <_fwalk_reent+0x4a>
  409102:	4688      	mov	r8, r1
  409104:	4606      	mov	r6, r0
  409106:	f04f 0900 	mov.w	r9, #0
  40910a:	687d      	ldr	r5, [r7, #4]
  40910c:	68bc      	ldr	r4, [r7, #8]
  40910e:	3d01      	subs	r5, #1
  409110:	d411      	bmi.n	409136 <_fwalk_reent+0x3e>
  409112:	89a3      	ldrh	r3, [r4, #12]
  409114:	2b01      	cmp	r3, #1
  409116:	f105 35ff 	add.w	r5, r5, #4294967295
  40911a:	d908      	bls.n	40912e <_fwalk_reent+0x36>
  40911c:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
  409120:	3301      	adds	r3, #1
  409122:	4621      	mov	r1, r4
  409124:	4630      	mov	r0, r6
  409126:	d002      	beq.n	40912e <_fwalk_reent+0x36>
  409128:	47c0      	blx	r8
  40912a:	ea49 0900 	orr.w	r9, r9, r0
  40912e:	1c6b      	adds	r3, r5, #1
  409130:	f104 0468 	add.w	r4, r4, #104	; 0x68
  409134:	d1ed      	bne.n	409112 <_fwalk_reent+0x1a>
  409136:	683f      	ldr	r7, [r7, #0]
  409138:	2f00      	cmp	r7, #0
  40913a:	d1e6      	bne.n	40910a <_fwalk_reent+0x12>
  40913c:	4648      	mov	r0, r9
  40913e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  409142:	46b9      	mov	r9, r7
  409144:	4648      	mov	r0, r9
  409146:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  40914a:	bf00      	nop

0040914c <__locale_charset>:
  40914c:	4800      	ldr	r0, [pc, #0]	; (409150 <__locale_charset+0x4>)
  40914e:	4770      	bx	lr
  409150:	20400474 	.word	0x20400474

00409154 <__locale_mb_cur_max>:
  409154:	4b01      	ldr	r3, [pc, #4]	; (40915c <__locale_mb_cur_max+0x8>)
  409156:	6818      	ldr	r0, [r3, #0]
  409158:	4770      	bx	lr
  40915a:	bf00      	nop
  40915c:	20400494 	.word	0x20400494

00409160 <_localeconv_r>:
  409160:	4800      	ldr	r0, [pc, #0]	; (409164 <_localeconv_r+0x4>)
  409162:	4770      	bx	lr
  409164:	2040043c 	.word	0x2040043c

00409168 <__swhatbuf_r>:
  409168:	b570      	push	{r4, r5, r6, lr}
  40916a:	460d      	mov	r5, r1
  40916c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  409170:	2900      	cmp	r1, #0
  409172:	b090      	sub	sp, #64	; 0x40
  409174:	4614      	mov	r4, r2
  409176:	461e      	mov	r6, r3
  409178:	db14      	blt.n	4091a4 <__swhatbuf_r+0x3c>
  40917a:	aa01      	add	r2, sp, #4
  40917c:	f001 faf8 	bl	40a770 <_fstat_r>
  409180:	2800      	cmp	r0, #0
  409182:	db0f      	blt.n	4091a4 <__swhatbuf_r+0x3c>
  409184:	9a02      	ldr	r2, [sp, #8]
  409186:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
  40918a:	f5a2 5200 	sub.w	r2, r2, #8192	; 0x2000
  40918e:	fab2 f282 	clz	r2, r2
  409192:	0952      	lsrs	r2, r2, #5
  409194:	f44f 6380 	mov.w	r3, #1024	; 0x400
  409198:	f44f 6000 	mov.w	r0, #2048	; 0x800
  40919c:	6032      	str	r2, [r6, #0]
  40919e:	6023      	str	r3, [r4, #0]
  4091a0:	b010      	add	sp, #64	; 0x40
  4091a2:	bd70      	pop	{r4, r5, r6, pc}
  4091a4:	89a8      	ldrh	r0, [r5, #12]
  4091a6:	f000 0080 	and.w	r0, r0, #128	; 0x80
  4091aa:	b282      	uxth	r2, r0
  4091ac:	2000      	movs	r0, #0
  4091ae:	6030      	str	r0, [r6, #0]
  4091b0:	b11a      	cbz	r2, 4091ba <__swhatbuf_r+0x52>
  4091b2:	2340      	movs	r3, #64	; 0x40
  4091b4:	6023      	str	r3, [r4, #0]
  4091b6:	b010      	add	sp, #64	; 0x40
  4091b8:	bd70      	pop	{r4, r5, r6, pc}
  4091ba:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4091be:	4610      	mov	r0, r2
  4091c0:	6023      	str	r3, [r4, #0]
  4091c2:	b010      	add	sp, #64	; 0x40
  4091c4:	bd70      	pop	{r4, r5, r6, pc}
  4091c6:	bf00      	nop

004091c8 <__smakebuf_r>:
  4091c8:	898a      	ldrh	r2, [r1, #12]
  4091ca:	0792      	lsls	r2, r2, #30
  4091cc:	460b      	mov	r3, r1
  4091ce:	d506      	bpl.n	4091de <__smakebuf_r+0x16>
  4091d0:	f101 0243 	add.w	r2, r1, #67	; 0x43
  4091d4:	2101      	movs	r1, #1
  4091d6:	601a      	str	r2, [r3, #0]
  4091d8:	611a      	str	r2, [r3, #16]
  4091da:	6159      	str	r1, [r3, #20]
  4091dc:	4770      	bx	lr
  4091de:	b5f0      	push	{r4, r5, r6, r7, lr}
  4091e0:	b083      	sub	sp, #12
  4091e2:	ab01      	add	r3, sp, #4
  4091e4:	466a      	mov	r2, sp
  4091e6:	460c      	mov	r4, r1
  4091e8:	4605      	mov	r5, r0
  4091ea:	f7ff ffbd 	bl	409168 <__swhatbuf_r>
  4091ee:	9900      	ldr	r1, [sp, #0]
  4091f0:	4606      	mov	r6, r0
  4091f2:	4628      	mov	r0, r5
  4091f4:	f000 f834 	bl	409260 <_malloc_r>
  4091f8:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  4091fc:	b1d0      	cbz	r0, 409234 <__smakebuf_r+0x6c>
  4091fe:	9a01      	ldr	r2, [sp, #4]
  409200:	4f12      	ldr	r7, [pc, #72]	; (40924c <__smakebuf_r+0x84>)
  409202:	9900      	ldr	r1, [sp, #0]
  409204:	63ef      	str	r7, [r5, #60]	; 0x3c
  409206:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  40920a:	81a3      	strh	r3, [r4, #12]
  40920c:	6020      	str	r0, [r4, #0]
  40920e:	6120      	str	r0, [r4, #16]
  409210:	6161      	str	r1, [r4, #20]
  409212:	b91a      	cbnz	r2, 40921c <__smakebuf_r+0x54>
  409214:	4333      	orrs	r3, r6
  409216:	81a3      	strh	r3, [r4, #12]
  409218:	b003      	add	sp, #12
  40921a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  40921c:	4628      	mov	r0, r5
  40921e:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
  409222:	f001 fab9 	bl	40a798 <_isatty_r>
  409226:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  40922a:	2800      	cmp	r0, #0
  40922c:	d0f2      	beq.n	409214 <__smakebuf_r+0x4c>
  40922e:	f043 0301 	orr.w	r3, r3, #1
  409232:	e7ef      	b.n	409214 <__smakebuf_r+0x4c>
  409234:	059a      	lsls	r2, r3, #22
  409236:	d4ef      	bmi.n	409218 <__smakebuf_r+0x50>
  409238:	f104 0243 	add.w	r2, r4, #67	; 0x43
  40923c:	f043 0302 	orr.w	r3, r3, #2
  409240:	2101      	movs	r1, #1
  409242:	81a3      	strh	r3, [r4, #12]
  409244:	6022      	str	r2, [r4, #0]
  409246:	6122      	str	r2, [r4, #16]
  409248:	6161      	str	r1, [r4, #20]
  40924a:	e7e5      	b.n	409218 <__smakebuf_r+0x50>
  40924c:	00408995 	.word	0x00408995

00409250 <malloc>:
  409250:	4b02      	ldr	r3, [pc, #8]	; (40925c <malloc+0xc>)
  409252:	4601      	mov	r1, r0
  409254:	6818      	ldr	r0, [r3, #0]
  409256:	f000 b803 	b.w	409260 <_malloc_r>
  40925a:	bf00      	nop
  40925c:	20400438 	.word	0x20400438

00409260 <_malloc_r>:
  409260:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  409264:	f101 050b 	add.w	r5, r1, #11
  409268:	2d16      	cmp	r5, #22
  40926a:	b083      	sub	sp, #12
  40926c:	4606      	mov	r6, r0
  40926e:	f240 809f 	bls.w	4093b0 <_malloc_r+0x150>
  409272:	f035 0507 	bics.w	r5, r5, #7
  409276:	f100 80bf 	bmi.w	4093f8 <_malloc_r+0x198>
  40927a:	42a9      	cmp	r1, r5
  40927c:	f200 80bc 	bhi.w	4093f8 <_malloc_r+0x198>
  409280:	f000 fb5a 	bl	409938 <__malloc_lock>
  409284:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
  409288:	f0c0 829c 	bcc.w	4097c4 <_malloc_r+0x564>
  40928c:	0a6b      	lsrs	r3, r5, #9
  40928e:	f000 80ba 	beq.w	409406 <_malloc_r+0x1a6>
  409292:	2b04      	cmp	r3, #4
  409294:	f200 8183 	bhi.w	40959e <_malloc_r+0x33e>
  409298:	09a8      	lsrs	r0, r5, #6
  40929a:	f100 0e39 	add.w	lr, r0, #57	; 0x39
  40929e:	ea4f 034e 	mov.w	r3, lr, lsl #1
  4092a2:	3038      	adds	r0, #56	; 0x38
  4092a4:	4fc4      	ldr	r7, [pc, #784]	; (4095b8 <_malloc_r+0x358>)
  4092a6:	eb07 0383 	add.w	r3, r7, r3, lsl #2
  4092aa:	f1a3 0108 	sub.w	r1, r3, #8
  4092ae:	685c      	ldr	r4, [r3, #4]
  4092b0:	42a1      	cmp	r1, r4
  4092b2:	d107      	bne.n	4092c4 <_malloc_r+0x64>
  4092b4:	e0ac      	b.n	409410 <_malloc_r+0x1b0>
  4092b6:	2a00      	cmp	r2, #0
  4092b8:	f280 80ac 	bge.w	409414 <_malloc_r+0x1b4>
  4092bc:	68e4      	ldr	r4, [r4, #12]
  4092be:	42a1      	cmp	r1, r4
  4092c0:	f000 80a6 	beq.w	409410 <_malloc_r+0x1b0>
  4092c4:	6863      	ldr	r3, [r4, #4]
  4092c6:	f023 0303 	bic.w	r3, r3, #3
  4092ca:	1b5a      	subs	r2, r3, r5
  4092cc:	2a0f      	cmp	r2, #15
  4092ce:	ddf2      	ble.n	4092b6 <_malloc_r+0x56>
  4092d0:	49b9      	ldr	r1, [pc, #740]	; (4095b8 <_malloc_r+0x358>)
  4092d2:	693c      	ldr	r4, [r7, #16]
  4092d4:	f101 0e08 	add.w	lr, r1, #8
  4092d8:	4574      	cmp	r4, lr
  4092da:	f000 81b3 	beq.w	409644 <_malloc_r+0x3e4>
  4092de:	6863      	ldr	r3, [r4, #4]
  4092e0:	f023 0303 	bic.w	r3, r3, #3
  4092e4:	1b5a      	subs	r2, r3, r5
  4092e6:	2a0f      	cmp	r2, #15
  4092e8:	f300 8199 	bgt.w	40961e <_malloc_r+0x3be>
  4092ec:	2a00      	cmp	r2, #0
  4092ee:	f8c1 e014 	str.w	lr, [r1, #20]
  4092f2:	f8c1 e010 	str.w	lr, [r1, #16]
  4092f6:	f280 809e 	bge.w	409436 <_malloc_r+0x1d6>
  4092fa:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  4092fe:	f080 8167 	bcs.w	4095d0 <_malloc_r+0x370>
  409302:	08db      	lsrs	r3, r3, #3
  409304:	f103 0c01 	add.w	ip, r3, #1
  409308:	2201      	movs	r2, #1
  40930a:	109b      	asrs	r3, r3, #2
  40930c:	fa02 f303 	lsl.w	r3, r2, r3
  409310:	684a      	ldr	r2, [r1, #4]
  409312:	f851 803c 	ldr.w	r8, [r1, ip, lsl #3]
  409316:	f8c4 8008 	str.w	r8, [r4, #8]
  40931a:	eb01 09cc 	add.w	r9, r1, ip, lsl #3
  40931e:	431a      	orrs	r2, r3
  409320:	f1a9 0308 	sub.w	r3, r9, #8
  409324:	60e3      	str	r3, [r4, #12]
  409326:	604a      	str	r2, [r1, #4]
  409328:	f841 403c 	str.w	r4, [r1, ip, lsl #3]
  40932c:	f8c8 400c 	str.w	r4, [r8, #12]
  409330:	1083      	asrs	r3, r0, #2
  409332:	2401      	movs	r4, #1
  409334:	409c      	lsls	r4, r3
  409336:	4294      	cmp	r4, r2
  409338:	f200 808a 	bhi.w	409450 <_malloc_r+0x1f0>
  40933c:	4214      	tst	r4, r2
  40933e:	d106      	bne.n	40934e <_malloc_r+0xee>
  409340:	f020 0003 	bic.w	r0, r0, #3
  409344:	0064      	lsls	r4, r4, #1
  409346:	4214      	tst	r4, r2
  409348:	f100 0004 	add.w	r0, r0, #4
  40934c:	d0fa      	beq.n	409344 <_malloc_r+0xe4>
  40934e:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
  409352:	46cc      	mov	ip, r9
  409354:	4680      	mov	r8, r0
  409356:	f8dc 100c 	ldr.w	r1, [ip, #12]
  40935a:	458c      	cmp	ip, r1
  40935c:	d107      	bne.n	40936e <_malloc_r+0x10e>
  40935e:	e173      	b.n	409648 <_malloc_r+0x3e8>
  409360:	2a00      	cmp	r2, #0
  409362:	f280 8181 	bge.w	409668 <_malloc_r+0x408>
  409366:	68c9      	ldr	r1, [r1, #12]
  409368:	458c      	cmp	ip, r1
  40936a:	f000 816d 	beq.w	409648 <_malloc_r+0x3e8>
  40936e:	684b      	ldr	r3, [r1, #4]
  409370:	f023 0303 	bic.w	r3, r3, #3
  409374:	1b5a      	subs	r2, r3, r5
  409376:	2a0f      	cmp	r2, #15
  409378:	ddf2      	ble.n	409360 <_malloc_r+0x100>
  40937a:	460c      	mov	r4, r1
  40937c:	f8d1 c00c 	ldr.w	ip, [r1, #12]
  409380:	f854 8f08 	ldr.w	r8, [r4, #8]!
  409384:	194b      	adds	r3, r1, r5
  409386:	f045 0501 	orr.w	r5, r5, #1
  40938a:	604d      	str	r5, [r1, #4]
  40938c:	f042 0101 	orr.w	r1, r2, #1
  409390:	f8c8 c00c 	str.w	ip, [r8, #12]
  409394:	4630      	mov	r0, r6
  409396:	f8cc 8008 	str.w	r8, [ip, #8]
  40939a:	617b      	str	r3, [r7, #20]
  40939c:	613b      	str	r3, [r7, #16]
  40939e:	f8c3 e00c 	str.w	lr, [r3, #12]
  4093a2:	f8c3 e008 	str.w	lr, [r3, #8]
  4093a6:	6059      	str	r1, [r3, #4]
  4093a8:	509a      	str	r2, [r3, r2]
  4093aa:	f000 fac7 	bl	40993c <__malloc_unlock>
  4093ae:	e01f      	b.n	4093f0 <_malloc_r+0x190>
  4093b0:	2910      	cmp	r1, #16
  4093b2:	d821      	bhi.n	4093f8 <_malloc_r+0x198>
  4093b4:	f000 fac0 	bl	409938 <__malloc_lock>
  4093b8:	2510      	movs	r5, #16
  4093ba:	2306      	movs	r3, #6
  4093bc:	2002      	movs	r0, #2
  4093be:	4f7e      	ldr	r7, [pc, #504]	; (4095b8 <_malloc_r+0x358>)
  4093c0:	eb07 0383 	add.w	r3, r7, r3, lsl #2
  4093c4:	f1a3 0208 	sub.w	r2, r3, #8
  4093c8:	685c      	ldr	r4, [r3, #4]
  4093ca:	4294      	cmp	r4, r2
  4093cc:	f000 8145 	beq.w	40965a <_malloc_r+0x3fa>
  4093d0:	6863      	ldr	r3, [r4, #4]
  4093d2:	68e1      	ldr	r1, [r4, #12]
  4093d4:	68a5      	ldr	r5, [r4, #8]
  4093d6:	f023 0303 	bic.w	r3, r3, #3
  4093da:	4423      	add	r3, r4
  4093dc:	4630      	mov	r0, r6
  4093de:	685a      	ldr	r2, [r3, #4]
  4093e0:	60e9      	str	r1, [r5, #12]
  4093e2:	f042 0201 	orr.w	r2, r2, #1
  4093e6:	608d      	str	r5, [r1, #8]
  4093e8:	605a      	str	r2, [r3, #4]
  4093ea:	f000 faa7 	bl	40993c <__malloc_unlock>
  4093ee:	3408      	adds	r4, #8
  4093f0:	4620      	mov	r0, r4
  4093f2:	b003      	add	sp, #12
  4093f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4093f8:	2400      	movs	r4, #0
  4093fa:	230c      	movs	r3, #12
  4093fc:	4620      	mov	r0, r4
  4093fe:	6033      	str	r3, [r6, #0]
  409400:	b003      	add	sp, #12
  409402:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  409406:	2380      	movs	r3, #128	; 0x80
  409408:	f04f 0e40 	mov.w	lr, #64	; 0x40
  40940c:	203f      	movs	r0, #63	; 0x3f
  40940e:	e749      	b.n	4092a4 <_malloc_r+0x44>
  409410:	4670      	mov	r0, lr
  409412:	e75d      	b.n	4092d0 <_malloc_r+0x70>
  409414:	4423      	add	r3, r4
  409416:	68e1      	ldr	r1, [r4, #12]
  409418:	685a      	ldr	r2, [r3, #4]
  40941a:	68a5      	ldr	r5, [r4, #8]
  40941c:	f042 0201 	orr.w	r2, r2, #1
  409420:	60e9      	str	r1, [r5, #12]
  409422:	4630      	mov	r0, r6
  409424:	608d      	str	r5, [r1, #8]
  409426:	605a      	str	r2, [r3, #4]
  409428:	f000 fa88 	bl	40993c <__malloc_unlock>
  40942c:	3408      	adds	r4, #8
  40942e:	4620      	mov	r0, r4
  409430:	b003      	add	sp, #12
  409432:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  409436:	4423      	add	r3, r4
  409438:	4630      	mov	r0, r6
  40943a:	685a      	ldr	r2, [r3, #4]
  40943c:	f042 0201 	orr.w	r2, r2, #1
  409440:	605a      	str	r2, [r3, #4]
  409442:	f000 fa7b 	bl	40993c <__malloc_unlock>
  409446:	3408      	adds	r4, #8
  409448:	4620      	mov	r0, r4
  40944a:	b003      	add	sp, #12
  40944c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  409450:	68bc      	ldr	r4, [r7, #8]
  409452:	6863      	ldr	r3, [r4, #4]
  409454:	f023 0803 	bic.w	r8, r3, #3
  409458:	45a8      	cmp	r8, r5
  40945a:	d304      	bcc.n	409466 <_malloc_r+0x206>
  40945c:	ebc5 0308 	rsb	r3, r5, r8
  409460:	2b0f      	cmp	r3, #15
  409462:	f300 808c 	bgt.w	40957e <_malloc_r+0x31e>
  409466:	4b55      	ldr	r3, [pc, #340]	; (4095bc <_malloc_r+0x35c>)
  409468:	f8df 9160 	ldr.w	r9, [pc, #352]	; 4095cc <_malloc_r+0x36c>
  40946c:	681a      	ldr	r2, [r3, #0]
  40946e:	f8d9 3000 	ldr.w	r3, [r9]
  409472:	3301      	adds	r3, #1
  409474:	442a      	add	r2, r5
  409476:	eb04 0a08 	add.w	sl, r4, r8
  40947a:	f000 8160 	beq.w	40973e <_malloc_r+0x4de>
  40947e:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
  409482:	320f      	adds	r2, #15
  409484:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
  409488:	f022 020f 	bic.w	r2, r2, #15
  40948c:	4611      	mov	r1, r2
  40948e:	4630      	mov	r0, r6
  409490:	9201      	str	r2, [sp, #4]
  409492:	f000 ff53 	bl	40a33c <_sbrk_r>
  409496:	f1b0 3fff 	cmp.w	r0, #4294967295
  40949a:	4683      	mov	fp, r0
  40949c:	9a01      	ldr	r2, [sp, #4]
  40949e:	f000 8158 	beq.w	409752 <_malloc_r+0x4f2>
  4094a2:	4582      	cmp	sl, r0
  4094a4:	f200 80fc 	bhi.w	4096a0 <_malloc_r+0x440>
  4094a8:	4b45      	ldr	r3, [pc, #276]	; (4095c0 <_malloc_r+0x360>)
  4094aa:	6819      	ldr	r1, [r3, #0]
  4094ac:	45da      	cmp	sl, fp
  4094ae:	4411      	add	r1, r2
  4094b0:	6019      	str	r1, [r3, #0]
  4094b2:	f000 8153 	beq.w	40975c <_malloc_r+0x4fc>
  4094b6:	f8d9 0000 	ldr.w	r0, [r9]
  4094ba:	f8df e110 	ldr.w	lr, [pc, #272]	; 4095cc <_malloc_r+0x36c>
  4094be:	3001      	adds	r0, #1
  4094c0:	bf1b      	ittet	ne
  4094c2:	ebca 0a0b 	rsbne	sl, sl, fp
  4094c6:	4451      	addne	r1, sl
  4094c8:	f8ce b000 	streq.w	fp, [lr]
  4094cc:	6019      	strne	r1, [r3, #0]
  4094ce:	f01b 0107 	ands.w	r1, fp, #7
  4094d2:	f000 8117 	beq.w	409704 <_malloc_r+0x4a4>
  4094d6:	f1c1 0008 	rsb	r0, r1, #8
  4094da:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
  4094de:	4483      	add	fp, r0
  4094e0:	3108      	adds	r1, #8
  4094e2:	445a      	add	r2, fp
  4094e4:	f3c2 020b 	ubfx	r2, r2, #0, #12
  4094e8:	ebc2 0901 	rsb	r9, r2, r1
  4094ec:	4649      	mov	r1, r9
  4094ee:	4630      	mov	r0, r6
  4094f0:	9301      	str	r3, [sp, #4]
  4094f2:	f000 ff23 	bl	40a33c <_sbrk_r>
  4094f6:	1c43      	adds	r3, r0, #1
  4094f8:	9b01      	ldr	r3, [sp, #4]
  4094fa:	f000 813f 	beq.w	40977c <_malloc_r+0x51c>
  4094fe:	ebcb 0200 	rsb	r2, fp, r0
  409502:	444a      	add	r2, r9
  409504:	f042 0201 	orr.w	r2, r2, #1
  409508:	6819      	ldr	r1, [r3, #0]
  40950a:	f8c7 b008 	str.w	fp, [r7, #8]
  40950e:	4449      	add	r1, r9
  409510:	42bc      	cmp	r4, r7
  409512:	f8cb 2004 	str.w	r2, [fp, #4]
  409516:	6019      	str	r1, [r3, #0]
  409518:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 4095c0 <_malloc_r+0x360>
  40951c:	d016      	beq.n	40954c <_malloc_r+0x2ec>
  40951e:	f1b8 0f0f 	cmp.w	r8, #15
  409522:	f240 80fd 	bls.w	409720 <_malloc_r+0x4c0>
  409526:	6862      	ldr	r2, [r4, #4]
  409528:	f1a8 030c 	sub.w	r3, r8, #12
  40952c:	f023 0307 	bic.w	r3, r3, #7
  409530:	18e0      	adds	r0, r4, r3
  409532:	f002 0201 	and.w	r2, r2, #1
  409536:	f04f 0e05 	mov.w	lr, #5
  40953a:	431a      	orrs	r2, r3
  40953c:	2b0f      	cmp	r3, #15
  40953e:	6062      	str	r2, [r4, #4]
  409540:	f8c0 e004 	str.w	lr, [r0, #4]
  409544:	f8c0 e008 	str.w	lr, [r0, #8]
  409548:	f200 811c 	bhi.w	409784 <_malloc_r+0x524>
  40954c:	4b1d      	ldr	r3, [pc, #116]	; (4095c4 <_malloc_r+0x364>)
  40954e:	68bc      	ldr	r4, [r7, #8]
  409550:	681a      	ldr	r2, [r3, #0]
  409552:	4291      	cmp	r1, r2
  409554:	bf88      	it	hi
  409556:	6019      	strhi	r1, [r3, #0]
  409558:	4b1b      	ldr	r3, [pc, #108]	; (4095c8 <_malloc_r+0x368>)
  40955a:	681a      	ldr	r2, [r3, #0]
  40955c:	4291      	cmp	r1, r2
  40955e:	6862      	ldr	r2, [r4, #4]
  409560:	bf88      	it	hi
  409562:	6019      	strhi	r1, [r3, #0]
  409564:	f022 0203 	bic.w	r2, r2, #3
  409568:	4295      	cmp	r5, r2
  40956a:	eba2 0305 	sub.w	r3, r2, r5
  40956e:	d801      	bhi.n	409574 <_malloc_r+0x314>
  409570:	2b0f      	cmp	r3, #15
  409572:	dc04      	bgt.n	40957e <_malloc_r+0x31e>
  409574:	4630      	mov	r0, r6
  409576:	f000 f9e1 	bl	40993c <__malloc_unlock>
  40957a:	2400      	movs	r4, #0
  40957c:	e738      	b.n	4093f0 <_malloc_r+0x190>
  40957e:	1962      	adds	r2, r4, r5
  409580:	f043 0301 	orr.w	r3, r3, #1
  409584:	f045 0501 	orr.w	r5, r5, #1
  409588:	6065      	str	r5, [r4, #4]
  40958a:	4630      	mov	r0, r6
  40958c:	60ba      	str	r2, [r7, #8]
  40958e:	6053      	str	r3, [r2, #4]
  409590:	f000 f9d4 	bl	40993c <__malloc_unlock>
  409594:	3408      	adds	r4, #8
  409596:	4620      	mov	r0, r4
  409598:	b003      	add	sp, #12
  40959a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40959e:	2b14      	cmp	r3, #20
  4095a0:	d971      	bls.n	409686 <_malloc_r+0x426>
  4095a2:	2b54      	cmp	r3, #84	; 0x54
  4095a4:	f200 80a4 	bhi.w	4096f0 <_malloc_r+0x490>
  4095a8:	0b28      	lsrs	r0, r5, #12
  4095aa:	f100 0e6f 	add.w	lr, r0, #111	; 0x6f
  4095ae:	ea4f 034e 	mov.w	r3, lr, lsl #1
  4095b2:	306e      	adds	r0, #110	; 0x6e
  4095b4:	e676      	b.n	4092a4 <_malloc_r+0x44>
  4095b6:	bf00      	nop
  4095b8:	20400498 	.word	0x20400498
  4095bc:	2040c450 	.word	0x2040c450
  4095c0:	2040c454 	.word	0x2040c454
  4095c4:	2040c44c 	.word	0x2040c44c
  4095c8:	2040c448 	.word	0x2040c448
  4095cc:	204008a4 	.word	0x204008a4
  4095d0:	0a5a      	lsrs	r2, r3, #9
  4095d2:	2a04      	cmp	r2, #4
  4095d4:	d95e      	bls.n	409694 <_malloc_r+0x434>
  4095d6:	2a14      	cmp	r2, #20
  4095d8:	f200 80b3 	bhi.w	409742 <_malloc_r+0x4e2>
  4095dc:	f102 015c 	add.w	r1, r2, #92	; 0x5c
  4095e0:	0049      	lsls	r1, r1, #1
  4095e2:	325b      	adds	r2, #91	; 0x5b
  4095e4:	eb07 0c81 	add.w	ip, r7, r1, lsl #2
  4095e8:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
  4095ec:	f8df 81dc 	ldr.w	r8, [pc, #476]	; 4097cc <_malloc_r+0x56c>
  4095f0:	f1ac 0c08 	sub.w	ip, ip, #8
  4095f4:	458c      	cmp	ip, r1
  4095f6:	f000 8088 	beq.w	40970a <_malloc_r+0x4aa>
  4095fa:	684a      	ldr	r2, [r1, #4]
  4095fc:	f022 0203 	bic.w	r2, r2, #3
  409600:	4293      	cmp	r3, r2
  409602:	d202      	bcs.n	40960a <_malloc_r+0x3aa>
  409604:	6889      	ldr	r1, [r1, #8]
  409606:	458c      	cmp	ip, r1
  409608:	d1f7      	bne.n	4095fa <_malloc_r+0x39a>
  40960a:	f8d1 c00c 	ldr.w	ip, [r1, #12]
  40960e:	687a      	ldr	r2, [r7, #4]
  409610:	f8c4 c00c 	str.w	ip, [r4, #12]
  409614:	60a1      	str	r1, [r4, #8]
  409616:	f8cc 4008 	str.w	r4, [ip, #8]
  40961a:	60cc      	str	r4, [r1, #12]
  40961c:	e688      	b.n	409330 <_malloc_r+0xd0>
  40961e:	1963      	adds	r3, r4, r5
  409620:	f042 0701 	orr.w	r7, r2, #1
  409624:	f045 0501 	orr.w	r5, r5, #1
  409628:	6065      	str	r5, [r4, #4]
  40962a:	4630      	mov	r0, r6
  40962c:	614b      	str	r3, [r1, #20]
  40962e:	610b      	str	r3, [r1, #16]
  409630:	f8c3 e00c 	str.w	lr, [r3, #12]
  409634:	f8c3 e008 	str.w	lr, [r3, #8]
  409638:	605f      	str	r7, [r3, #4]
  40963a:	509a      	str	r2, [r3, r2]
  40963c:	3408      	adds	r4, #8
  40963e:	f000 f97d 	bl	40993c <__malloc_unlock>
  409642:	e6d5      	b.n	4093f0 <_malloc_r+0x190>
  409644:	684a      	ldr	r2, [r1, #4]
  409646:	e673      	b.n	409330 <_malloc_r+0xd0>
  409648:	f108 0801 	add.w	r8, r8, #1
  40964c:	f018 0f03 	tst.w	r8, #3
  409650:	f10c 0c08 	add.w	ip, ip, #8
  409654:	f47f ae7f 	bne.w	409356 <_malloc_r+0xf6>
  409658:	e030      	b.n	4096bc <_malloc_r+0x45c>
  40965a:	68dc      	ldr	r4, [r3, #12]
  40965c:	42a3      	cmp	r3, r4
  40965e:	bf08      	it	eq
  409660:	3002      	addeq	r0, #2
  409662:	f43f ae35 	beq.w	4092d0 <_malloc_r+0x70>
  409666:	e6b3      	b.n	4093d0 <_malloc_r+0x170>
  409668:	440b      	add	r3, r1
  40966a:	460c      	mov	r4, r1
  40966c:	685a      	ldr	r2, [r3, #4]
  40966e:	68c9      	ldr	r1, [r1, #12]
  409670:	f854 5f08 	ldr.w	r5, [r4, #8]!
  409674:	f042 0201 	orr.w	r2, r2, #1
  409678:	605a      	str	r2, [r3, #4]
  40967a:	4630      	mov	r0, r6
  40967c:	60e9      	str	r1, [r5, #12]
  40967e:	608d      	str	r5, [r1, #8]
  409680:	f000 f95c 	bl	40993c <__malloc_unlock>
  409684:	e6b4      	b.n	4093f0 <_malloc_r+0x190>
  409686:	f103 0e5c 	add.w	lr, r3, #92	; 0x5c
  40968a:	f103 005b 	add.w	r0, r3, #91	; 0x5b
  40968e:	ea4f 034e 	mov.w	r3, lr, lsl #1
  409692:	e607      	b.n	4092a4 <_malloc_r+0x44>
  409694:	099a      	lsrs	r2, r3, #6
  409696:	f102 0139 	add.w	r1, r2, #57	; 0x39
  40969a:	0049      	lsls	r1, r1, #1
  40969c:	3238      	adds	r2, #56	; 0x38
  40969e:	e7a1      	b.n	4095e4 <_malloc_r+0x384>
  4096a0:	42bc      	cmp	r4, r7
  4096a2:	4b4a      	ldr	r3, [pc, #296]	; (4097cc <_malloc_r+0x56c>)
  4096a4:	f43f af00 	beq.w	4094a8 <_malloc_r+0x248>
  4096a8:	689c      	ldr	r4, [r3, #8]
  4096aa:	6862      	ldr	r2, [r4, #4]
  4096ac:	f022 0203 	bic.w	r2, r2, #3
  4096b0:	e75a      	b.n	409568 <_malloc_r+0x308>
  4096b2:	f859 3908 	ldr.w	r3, [r9], #-8
  4096b6:	4599      	cmp	r9, r3
  4096b8:	f040 8082 	bne.w	4097c0 <_malloc_r+0x560>
  4096bc:	f010 0f03 	tst.w	r0, #3
  4096c0:	f100 30ff 	add.w	r0, r0, #4294967295
  4096c4:	d1f5      	bne.n	4096b2 <_malloc_r+0x452>
  4096c6:	687b      	ldr	r3, [r7, #4]
  4096c8:	ea23 0304 	bic.w	r3, r3, r4
  4096cc:	607b      	str	r3, [r7, #4]
  4096ce:	0064      	lsls	r4, r4, #1
  4096d0:	429c      	cmp	r4, r3
  4096d2:	f63f aebd 	bhi.w	409450 <_malloc_r+0x1f0>
  4096d6:	2c00      	cmp	r4, #0
  4096d8:	f43f aeba 	beq.w	409450 <_malloc_r+0x1f0>
  4096dc:	421c      	tst	r4, r3
  4096de:	4640      	mov	r0, r8
  4096e0:	f47f ae35 	bne.w	40934e <_malloc_r+0xee>
  4096e4:	0064      	lsls	r4, r4, #1
  4096e6:	421c      	tst	r4, r3
  4096e8:	f100 0004 	add.w	r0, r0, #4
  4096ec:	d0fa      	beq.n	4096e4 <_malloc_r+0x484>
  4096ee:	e62e      	b.n	40934e <_malloc_r+0xee>
  4096f0:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
  4096f4:	d818      	bhi.n	409728 <_malloc_r+0x4c8>
  4096f6:	0be8      	lsrs	r0, r5, #15
  4096f8:	f100 0e78 	add.w	lr, r0, #120	; 0x78
  4096fc:	ea4f 034e 	mov.w	r3, lr, lsl #1
  409700:	3077      	adds	r0, #119	; 0x77
  409702:	e5cf      	b.n	4092a4 <_malloc_r+0x44>
  409704:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  409708:	e6eb      	b.n	4094e2 <_malloc_r+0x282>
  40970a:	2101      	movs	r1, #1
  40970c:	f8d8 3004 	ldr.w	r3, [r8, #4]
  409710:	1092      	asrs	r2, r2, #2
  409712:	fa01 f202 	lsl.w	r2, r1, r2
  409716:	431a      	orrs	r2, r3
  409718:	f8c8 2004 	str.w	r2, [r8, #4]
  40971c:	4661      	mov	r1, ip
  40971e:	e777      	b.n	409610 <_malloc_r+0x3b0>
  409720:	2301      	movs	r3, #1
  409722:	f8cb 3004 	str.w	r3, [fp, #4]
  409726:	e725      	b.n	409574 <_malloc_r+0x314>
  409728:	f240 5254 	movw	r2, #1364	; 0x554
  40972c:	4293      	cmp	r3, r2
  40972e:	d820      	bhi.n	409772 <_malloc_r+0x512>
  409730:	0ca8      	lsrs	r0, r5, #18
  409732:	f100 0e7d 	add.w	lr, r0, #125	; 0x7d
  409736:	ea4f 034e 	mov.w	r3, lr, lsl #1
  40973a:	307c      	adds	r0, #124	; 0x7c
  40973c:	e5b2      	b.n	4092a4 <_malloc_r+0x44>
  40973e:	3210      	adds	r2, #16
  409740:	e6a4      	b.n	40948c <_malloc_r+0x22c>
  409742:	2a54      	cmp	r2, #84	; 0x54
  409744:	d826      	bhi.n	409794 <_malloc_r+0x534>
  409746:	0b1a      	lsrs	r2, r3, #12
  409748:	f102 016f 	add.w	r1, r2, #111	; 0x6f
  40974c:	0049      	lsls	r1, r1, #1
  40974e:	326e      	adds	r2, #110	; 0x6e
  409750:	e748      	b.n	4095e4 <_malloc_r+0x384>
  409752:	68bc      	ldr	r4, [r7, #8]
  409754:	6862      	ldr	r2, [r4, #4]
  409756:	f022 0203 	bic.w	r2, r2, #3
  40975a:	e705      	b.n	409568 <_malloc_r+0x308>
  40975c:	f3ca 000b 	ubfx	r0, sl, #0, #12
  409760:	2800      	cmp	r0, #0
  409762:	f47f aea8 	bne.w	4094b6 <_malloc_r+0x256>
  409766:	4442      	add	r2, r8
  409768:	68bb      	ldr	r3, [r7, #8]
  40976a:	f042 0201 	orr.w	r2, r2, #1
  40976e:	605a      	str	r2, [r3, #4]
  409770:	e6ec      	b.n	40954c <_malloc_r+0x2ec>
  409772:	23fe      	movs	r3, #254	; 0xfe
  409774:	f04f 0e7f 	mov.w	lr, #127	; 0x7f
  409778:	207e      	movs	r0, #126	; 0x7e
  40977a:	e593      	b.n	4092a4 <_malloc_r+0x44>
  40977c:	2201      	movs	r2, #1
  40977e:	f04f 0900 	mov.w	r9, #0
  409782:	e6c1      	b.n	409508 <_malloc_r+0x2a8>
  409784:	f104 0108 	add.w	r1, r4, #8
  409788:	4630      	mov	r0, r6
  40978a:	f7ff fa4b 	bl	408c24 <_free_r>
  40978e:	f8d9 1000 	ldr.w	r1, [r9]
  409792:	e6db      	b.n	40954c <_malloc_r+0x2ec>
  409794:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
  409798:	d805      	bhi.n	4097a6 <_malloc_r+0x546>
  40979a:	0bda      	lsrs	r2, r3, #15
  40979c:	f102 0178 	add.w	r1, r2, #120	; 0x78
  4097a0:	0049      	lsls	r1, r1, #1
  4097a2:	3277      	adds	r2, #119	; 0x77
  4097a4:	e71e      	b.n	4095e4 <_malloc_r+0x384>
  4097a6:	f240 5154 	movw	r1, #1364	; 0x554
  4097aa:	428a      	cmp	r2, r1
  4097ac:	d805      	bhi.n	4097ba <_malloc_r+0x55a>
  4097ae:	0c9a      	lsrs	r2, r3, #18
  4097b0:	f102 017d 	add.w	r1, r2, #125	; 0x7d
  4097b4:	0049      	lsls	r1, r1, #1
  4097b6:	327c      	adds	r2, #124	; 0x7c
  4097b8:	e714      	b.n	4095e4 <_malloc_r+0x384>
  4097ba:	21fe      	movs	r1, #254	; 0xfe
  4097bc:	227e      	movs	r2, #126	; 0x7e
  4097be:	e711      	b.n	4095e4 <_malloc_r+0x384>
  4097c0:	687b      	ldr	r3, [r7, #4]
  4097c2:	e784      	b.n	4096ce <_malloc_r+0x46e>
  4097c4:	08e8      	lsrs	r0, r5, #3
  4097c6:	1c43      	adds	r3, r0, #1
  4097c8:	005b      	lsls	r3, r3, #1
  4097ca:	e5f8      	b.n	4093be <_malloc_r+0x15e>
  4097cc:	20400498 	.word	0x20400498

004097d0 <memchr>:
  4097d0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  4097d4:	2a10      	cmp	r2, #16
  4097d6:	db2b      	blt.n	409830 <memchr+0x60>
  4097d8:	f010 0f07 	tst.w	r0, #7
  4097dc:	d008      	beq.n	4097f0 <memchr+0x20>
  4097de:	f810 3b01 	ldrb.w	r3, [r0], #1
  4097e2:	3a01      	subs	r2, #1
  4097e4:	428b      	cmp	r3, r1
  4097e6:	d02d      	beq.n	409844 <memchr+0x74>
  4097e8:	f010 0f07 	tst.w	r0, #7
  4097ec:	b342      	cbz	r2, 409840 <memchr+0x70>
  4097ee:	d1f6      	bne.n	4097de <memchr+0xe>
  4097f0:	b4f0      	push	{r4, r5, r6, r7}
  4097f2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
  4097f6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
  4097fa:	f022 0407 	bic.w	r4, r2, #7
  4097fe:	f07f 0700 	mvns.w	r7, #0
  409802:	2300      	movs	r3, #0
  409804:	e8f0 5602 	ldrd	r5, r6, [r0], #8
  409808:	3c08      	subs	r4, #8
  40980a:	ea85 0501 	eor.w	r5, r5, r1
  40980e:	ea86 0601 	eor.w	r6, r6, r1
  409812:	fa85 f547 	uadd8	r5, r5, r7
  409816:	faa3 f587 	sel	r5, r3, r7
  40981a:	fa86 f647 	uadd8	r6, r6, r7
  40981e:	faa5 f687 	sel	r6, r5, r7
  409822:	b98e      	cbnz	r6, 409848 <memchr+0x78>
  409824:	d1ee      	bne.n	409804 <memchr+0x34>
  409826:	bcf0      	pop	{r4, r5, r6, r7}
  409828:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  40982c:	f002 0207 	and.w	r2, r2, #7
  409830:	b132      	cbz	r2, 409840 <memchr+0x70>
  409832:	f810 3b01 	ldrb.w	r3, [r0], #1
  409836:	3a01      	subs	r2, #1
  409838:	ea83 0301 	eor.w	r3, r3, r1
  40983c:	b113      	cbz	r3, 409844 <memchr+0x74>
  40983e:	d1f8      	bne.n	409832 <memchr+0x62>
  409840:	2000      	movs	r0, #0
  409842:	4770      	bx	lr
  409844:	3801      	subs	r0, #1
  409846:	4770      	bx	lr
  409848:	2d00      	cmp	r5, #0
  40984a:	bf06      	itte	eq
  40984c:	4635      	moveq	r5, r6
  40984e:	3803      	subeq	r0, #3
  409850:	3807      	subne	r0, #7
  409852:	f015 0f01 	tst.w	r5, #1
  409856:	d107      	bne.n	409868 <memchr+0x98>
  409858:	3001      	adds	r0, #1
  40985a:	f415 7f80 	tst.w	r5, #256	; 0x100
  40985e:	bf02      	ittt	eq
  409860:	3001      	addeq	r0, #1
  409862:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
  409866:	3001      	addeq	r0, #1
  409868:	bcf0      	pop	{r4, r5, r6, r7}
  40986a:	3801      	subs	r0, #1
  40986c:	4770      	bx	lr
  40986e:	bf00      	nop

00409870 <memmove>:
  409870:	4288      	cmp	r0, r1
  409872:	b5f0      	push	{r4, r5, r6, r7, lr}
  409874:	d90d      	bls.n	409892 <memmove+0x22>
  409876:	188b      	adds	r3, r1, r2
  409878:	4298      	cmp	r0, r3
  40987a:	d20a      	bcs.n	409892 <memmove+0x22>
  40987c:	1881      	adds	r1, r0, r2
  40987e:	2a00      	cmp	r2, #0
  409880:	d051      	beq.n	409926 <memmove+0xb6>
  409882:	1a9a      	subs	r2, r3, r2
  409884:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
  409888:	f801 4d01 	strb.w	r4, [r1, #-1]!
  40988c:	4293      	cmp	r3, r2
  40988e:	d1f9      	bne.n	409884 <memmove+0x14>
  409890:	bdf0      	pop	{r4, r5, r6, r7, pc}
  409892:	2a0f      	cmp	r2, #15
  409894:	d948      	bls.n	409928 <memmove+0xb8>
  409896:	ea41 0300 	orr.w	r3, r1, r0
  40989a:	079b      	lsls	r3, r3, #30
  40989c:	d146      	bne.n	40992c <memmove+0xbc>
  40989e:	f100 0410 	add.w	r4, r0, #16
  4098a2:	f101 0310 	add.w	r3, r1, #16
  4098a6:	4615      	mov	r5, r2
  4098a8:	f853 6c10 	ldr.w	r6, [r3, #-16]
  4098ac:	f844 6c10 	str.w	r6, [r4, #-16]
  4098b0:	f853 6c0c 	ldr.w	r6, [r3, #-12]
  4098b4:	f844 6c0c 	str.w	r6, [r4, #-12]
  4098b8:	f853 6c08 	ldr.w	r6, [r3, #-8]
  4098bc:	f844 6c08 	str.w	r6, [r4, #-8]
  4098c0:	3d10      	subs	r5, #16
  4098c2:	f853 6c04 	ldr.w	r6, [r3, #-4]
  4098c6:	f844 6c04 	str.w	r6, [r4, #-4]
  4098ca:	2d0f      	cmp	r5, #15
  4098cc:	f103 0310 	add.w	r3, r3, #16
  4098d0:	f104 0410 	add.w	r4, r4, #16
  4098d4:	d8e8      	bhi.n	4098a8 <memmove+0x38>
  4098d6:	f1a2 0310 	sub.w	r3, r2, #16
  4098da:	f023 030f 	bic.w	r3, r3, #15
  4098de:	f002 0e0f 	and.w	lr, r2, #15
  4098e2:	3310      	adds	r3, #16
  4098e4:	f1be 0f03 	cmp.w	lr, #3
  4098e8:	4419      	add	r1, r3
  4098ea:	4403      	add	r3, r0
  4098ec:	d921      	bls.n	409932 <memmove+0xc2>
  4098ee:	1f1e      	subs	r6, r3, #4
  4098f0:	460d      	mov	r5, r1
  4098f2:	4674      	mov	r4, lr
  4098f4:	3c04      	subs	r4, #4
  4098f6:	f855 7b04 	ldr.w	r7, [r5], #4
  4098fa:	f846 7f04 	str.w	r7, [r6, #4]!
  4098fe:	2c03      	cmp	r4, #3
  409900:	d8f8      	bhi.n	4098f4 <memmove+0x84>
  409902:	f1ae 0404 	sub.w	r4, lr, #4
  409906:	f024 0403 	bic.w	r4, r4, #3
  40990a:	3404      	adds	r4, #4
  40990c:	4423      	add	r3, r4
  40990e:	4421      	add	r1, r4
  409910:	f002 0203 	and.w	r2, r2, #3
  409914:	b162      	cbz	r2, 409930 <memmove+0xc0>
  409916:	3b01      	subs	r3, #1
  409918:	440a      	add	r2, r1
  40991a:	f811 4b01 	ldrb.w	r4, [r1], #1
  40991e:	f803 4f01 	strb.w	r4, [r3, #1]!
  409922:	428a      	cmp	r2, r1
  409924:	d1f9      	bne.n	40991a <memmove+0xaa>
  409926:	bdf0      	pop	{r4, r5, r6, r7, pc}
  409928:	4603      	mov	r3, r0
  40992a:	e7f3      	b.n	409914 <memmove+0xa4>
  40992c:	4603      	mov	r3, r0
  40992e:	e7f2      	b.n	409916 <memmove+0xa6>
  409930:	bdf0      	pop	{r4, r5, r6, r7, pc}
  409932:	4672      	mov	r2, lr
  409934:	e7ee      	b.n	409914 <memmove+0xa4>
  409936:	bf00      	nop

00409938 <__malloc_lock>:
  409938:	4770      	bx	lr
  40993a:	bf00      	nop

0040993c <__malloc_unlock>:
  40993c:	4770      	bx	lr
  40993e:	bf00      	nop

00409940 <_Balloc>:
  409940:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
  409942:	b570      	push	{r4, r5, r6, lr}
  409944:	4605      	mov	r5, r0
  409946:	460c      	mov	r4, r1
  409948:	b14b      	cbz	r3, 40995e <_Balloc+0x1e>
  40994a:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
  40994e:	b180      	cbz	r0, 409972 <_Balloc+0x32>
  409950:	6802      	ldr	r2, [r0, #0]
  409952:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
  409956:	2300      	movs	r3, #0
  409958:	6103      	str	r3, [r0, #16]
  40995a:	60c3      	str	r3, [r0, #12]
  40995c:	bd70      	pop	{r4, r5, r6, pc}
  40995e:	2221      	movs	r2, #33	; 0x21
  409960:	2104      	movs	r1, #4
  409962:	f000 fe81 	bl	40a668 <_calloc_r>
  409966:	64e8      	str	r0, [r5, #76]	; 0x4c
  409968:	4603      	mov	r3, r0
  40996a:	2800      	cmp	r0, #0
  40996c:	d1ed      	bne.n	40994a <_Balloc+0xa>
  40996e:	2000      	movs	r0, #0
  409970:	bd70      	pop	{r4, r5, r6, pc}
  409972:	2101      	movs	r1, #1
  409974:	fa01 f604 	lsl.w	r6, r1, r4
  409978:	1d72      	adds	r2, r6, #5
  40997a:	4628      	mov	r0, r5
  40997c:	0092      	lsls	r2, r2, #2
  40997e:	f000 fe73 	bl	40a668 <_calloc_r>
  409982:	2800      	cmp	r0, #0
  409984:	d0f3      	beq.n	40996e <_Balloc+0x2e>
  409986:	6044      	str	r4, [r0, #4]
  409988:	6086      	str	r6, [r0, #8]
  40998a:	e7e4      	b.n	409956 <_Balloc+0x16>

0040998c <_Bfree>:
  40998c:	b131      	cbz	r1, 40999c <_Bfree+0x10>
  40998e:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
  409990:	684a      	ldr	r2, [r1, #4]
  409992:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
  409996:	6008      	str	r0, [r1, #0]
  409998:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  40999c:	4770      	bx	lr
  40999e:	bf00      	nop

004099a0 <__multadd>:
  4099a0:	b5f0      	push	{r4, r5, r6, r7, lr}
  4099a2:	690c      	ldr	r4, [r1, #16]
  4099a4:	b083      	sub	sp, #12
  4099a6:	460d      	mov	r5, r1
  4099a8:	4606      	mov	r6, r0
  4099aa:	f101 0e14 	add.w	lr, r1, #20
  4099ae:	2700      	movs	r7, #0
  4099b0:	f8de 0000 	ldr.w	r0, [lr]
  4099b4:	b281      	uxth	r1, r0
  4099b6:	fb02 3101 	mla	r1, r2, r1, r3
  4099ba:	0c0b      	lsrs	r3, r1, #16
  4099bc:	0c00      	lsrs	r0, r0, #16
  4099be:	fb02 3300 	mla	r3, r2, r0, r3
  4099c2:	b289      	uxth	r1, r1
  4099c4:	3701      	adds	r7, #1
  4099c6:	eb01 4103 	add.w	r1, r1, r3, lsl #16
  4099ca:	42bc      	cmp	r4, r7
  4099cc:	f84e 1b04 	str.w	r1, [lr], #4
  4099d0:	ea4f 4313 	mov.w	r3, r3, lsr #16
  4099d4:	dcec      	bgt.n	4099b0 <__multadd+0x10>
  4099d6:	b13b      	cbz	r3, 4099e8 <__multadd+0x48>
  4099d8:	68aa      	ldr	r2, [r5, #8]
  4099da:	4294      	cmp	r4, r2
  4099dc:	da07      	bge.n	4099ee <__multadd+0x4e>
  4099de:	eb05 0284 	add.w	r2, r5, r4, lsl #2
  4099e2:	3401      	adds	r4, #1
  4099e4:	6153      	str	r3, [r2, #20]
  4099e6:	612c      	str	r4, [r5, #16]
  4099e8:	4628      	mov	r0, r5
  4099ea:	b003      	add	sp, #12
  4099ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4099ee:	6869      	ldr	r1, [r5, #4]
  4099f0:	9301      	str	r3, [sp, #4]
  4099f2:	3101      	adds	r1, #1
  4099f4:	4630      	mov	r0, r6
  4099f6:	f7ff ffa3 	bl	409940 <_Balloc>
  4099fa:	692a      	ldr	r2, [r5, #16]
  4099fc:	3202      	adds	r2, #2
  4099fe:	f105 010c 	add.w	r1, r5, #12
  409a02:	4607      	mov	r7, r0
  409a04:	0092      	lsls	r2, r2, #2
  409a06:	300c      	adds	r0, #12
  409a08:	f7fb f980 	bl	404d0c <memcpy>
  409a0c:	6cf2      	ldr	r2, [r6, #76]	; 0x4c
  409a0e:	6869      	ldr	r1, [r5, #4]
  409a10:	9b01      	ldr	r3, [sp, #4]
  409a12:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
  409a16:	6028      	str	r0, [r5, #0]
  409a18:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
  409a1c:	463d      	mov	r5, r7
  409a1e:	e7de      	b.n	4099de <__multadd+0x3e>

00409a20 <__hi0bits>:
  409a20:	0c03      	lsrs	r3, r0, #16
  409a22:	041b      	lsls	r3, r3, #16
  409a24:	b9b3      	cbnz	r3, 409a54 <__hi0bits+0x34>
  409a26:	0400      	lsls	r0, r0, #16
  409a28:	2310      	movs	r3, #16
  409a2a:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
  409a2e:	bf04      	itt	eq
  409a30:	0200      	lsleq	r0, r0, #8
  409a32:	3308      	addeq	r3, #8
  409a34:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
  409a38:	bf04      	itt	eq
  409a3a:	0100      	lsleq	r0, r0, #4
  409a3c:	3304      	addeq	r3, #4
  409a3e:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
  409a42:	bf04      	itt	eq
  409a44:	0080      	lsleq	r0, r0, #2
  409a46:	3302      	addeq	r3, #2
  409a48:	2800      	cmp	r0, #0
  409a4a:	db07      	blt.n	409a5c <__hi0bits+0x3c>
  409a4c:	0042      	lsls	r2, r0, #1
  409a4e:	d403      	bmi.n	409a58 <__hi0bits+0x38>
  409a50:	2020      	movs	r0, #32
  409a52:	4770      	bx	lr
  409a54:	2300      	movs	r3, #0
  409a56:	e7e8      	b.n	409a2a <__hi0bits+0xa>
  409a58:	1c58      	adds	r0, r3, #1
  409a5a:	4770      	bx	lr
  409a5c:	4618      	mov	r0, r3
  409a5e:	4770      	bx	lr

00409a60 <__lo0bits>:
  409a60:	6803      	ldr	r3, [r0, #0]
  409a62:	f013 0207 	ands.w	r2, r3, #7
  409a66:	d007      	beq.n	409a78 <__lo0bits+0x18>
  409a68:	07d9      	lsls	r1, r3, #31
  409a6a:	d420      	bmi.n	409aae <__lo0bits+0x4e>
  409a6c:	079a      	lsls	r2, r3, #30
  409a6e:	d420      	bmi.n	409ab2 <__lo0bits+0x52>
  409a70:	089b      	lsrs	r3, r3, #2
  409a72:	6003      	str	r3, [r0, #0]
  409a74:	2002      	movs	r0, #2
  409a76:	4770      	bx	lr
  409a78:	b299      	uxth	r1, r3
  409a7a:	b909      	cbnz	r1, 409a80 <__lo0bits+0x20>
  409a7c:	0c1b      	lsrs	r3, r3, #16
  409a7e:	2210      	movs	r2, #16
  409a80:	f013 0fff 	tst.w	r3, #255	; 0xff
  409a84:	bf04      	itt	eq
  409a86:	0a1b      	lsreq	r3, r3, #8
  409a88:	3208      	addeq	r2, #8
  409a8a:	0719      	lsls	r1, r3, #28
  409a8c:	bf04      	itt	eq
  409a8e:	091b      	lsreq	r3, r3, #4
  409a90:	3204      	addeq	r2, #4
  409a92:	0799      	lsls	r1, r3, #30
  409a94:	bf04      	itt	eq
  409a96:	089b      	lsreq	r3, r3, #2
  409a98:	3202      	addeq	r2, #2
  409a9a:	07d9      	lsls	r1, r3, #31
  409a9c:	d404      	bmi.n	409aa8 <__lo0bits+0x48>
  409a9e:	085b      	lsrs	r3, r3, #1
  409aa0:	d101      	bne.n	409aa6 <__lo0bits+0x46>
  409aa2:	2020      	movs	r0, #32
  409aa4:	4770      	bx	lr
  409aa6:	3201      	adds	r2, #1
  409aa8:	6003      	str	r3, [r0, #0]
  409aaa:	4610      	mov	r0, r2
  409aac:	4770      	bx	lr
  409aae:	2000      	movs	r0, #0
  409ab0:	4770      	bx	lr
  409ab2:	085b      	lsrs	r3, r3, #1
  409ab4:	6003      	str	r3, [r0, #0]
  409ab6:	2001      	movs	r0, #1
  409ab8:	4770      	bx	lr
  409aba:	bf00      	nop

00409abc <__i2b>:
  409abc:	b510      	push	{r4, lr}
  409abe:	460c      	mov	r4, r1
  409ac0:	2101      	movs	r1, #1
  409ac2:	f7ff ff3d 	bl	409940 <_Balloc>
  409ac6:	2201      	movs	r2, #1
  409ac8:	6144      	str	r4, [r0, #20]
  409aca:	6102      	str	r2, [r0, #16]
  409acc:	bd10      	pop	{r4, pc}
  409ace:	bf00      	nop

00409ad0 <__multiply>:
  409ad0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  409ad4:	690d      	ldr	r5, [r1, #16]
  409ad6:	6917      	ldr	r7, [r2, #16]
  409ad8:	42bd      	cmp	r5, r7
  409ada:	b083      	sub	sp, #12
  409adc:	460c      	mov	r4, r1
  409ade:	4616      	mov	r6, r2
  409ae0:	da04      	bge.n	409aec <__multiply+0x1c>
  409ae2:	462a      	mov	r2, r5
  409ae4:	4634      	mov	r4, r6
  409ae6:	463d      	mov	r5, r7
  409ae8:	460e      	mov	r6, r1
  409aea:	4617      	mov	r7, r2
  409aec:	68a3      	ldr	r3, [r4, #8]
  409aee:	6861      	ldr	r1, [r4, #4]
  409af0:	eb05 0807 	add.w	r8, r5, r7
  409af4:	4598      	cmp	r8, r3
  409af6:	bfc8      	it	gt
  409af8:	3101      	addgt	r1, #1
  409afa:	f7ff ff21 	bl	409940 <_Balloc>
  409afe:	f100 0c14 	add.w	ip, r0, #20
  409b02:	eb0c 0988 	add.w	r9, ip, r8, lsl #2
  409b06:	45cc      	cmp	ip, r9
  409b08:	9000      	str	r0, [sp, #0]
  409b0a:	d205      	bcs.n	409b18 <__multiply+0x48>
  409b0c:	4663      	mov	r3, ip
  409b0e:	2100      	movs	r1, #0
  409b10:	f843 1b04 	str.w	r1, [r3], #4
  409b14:	4599      	cmp	r9, r3
  409b16:	d8fb      	bhi.n	409b10 <__multiply+0x40>
  409b18:	f106 0214 	add.w	r2, r6, #20
  409b1c:	eb02 0a87 	add.w	sl, r2, r7, lsl #2
  409b20:	f104 0314 	add.w	r3, r4, #20
  409b24:	4552      	cmp	r2, sl
  409b26:	eb03 0e85 	add.w	lr, r3, r5, lsl #2
  409b2a:	d254      	bcs.n	409bd6 <__multiply+0x106>
  409b2c:	f8cd 9004 	str.w	r9, [sp, #4]
  409b30:	4699      	mov	r9, r3
  409b32:	f852 3b04 	ldr.w	r3, [r2], #4
  409b36:	fa1f fb83 	uxth.w	fp, r3
  409b3a:	f1bb 0f00 	cmp.w	fp, #0
  409b3e:	d020      	beq.n	409b82 <__multiply+0xb2>
  409b40:	2000      	movs	r0, #0
  409b42:	464f      	mov	r7, r9
  409b44:	4666      	mov	r6, ip
  409b46:	4605      	mov	r5, r0
  409b48:	e000      	b.n	409b4c <__multiply+0x7c>
  409b4a:	461e      	mov	r6, r3
  409b4c:	f857 4b04 	ldr.w	r4, [r7], #4
  409b50:	6830      	ldr	r0, [r6, #0]
  409b52:	b2a1      	uxth	r1, r4
  409b54:	b283      	uxth	r3, r0
  409b56:	fb0b 3101 	mla	r1, fp, r1, r3
  409b5a:	0c24      	lsrs	r4, r4, #16
  409b5c:	0c00      	lsrs	r0, r0, #16
  409b5e:	194b      	adds	r3, r1, r5
  409b60:	fb0b 0004 	mla	r0, fp, r4, r0
  409b64:	eb00 4013 	add.w	r0, r0, r3, lsr #16
  409b68:	b299      	uxth	r1, r3
  409b6a:	4633      	mov	r3, r6
  409b6c:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
  409b70:	45be      	cmp	lr, r7
  409b72:	ea4f 4510 	mov.w	r5, r0, lsr #16
  409b76:	f843 1b04 	str.w	r1, [r3], #4
  409b7a:	d8e6      	bhi.n	409b4a <__multiply+0x7a>
  409b7c:	6075      	str	r5, [r6, #4]
  409b7e:	f852 3c04 	ldr.w	r3, [r2, #-4]
  409b82:	ea5f 4b13 	movs.w	fp, r3, lsr #16
  409b86:	d020      	beq.n	409bca <__multiply+0xfa>
  409b88:	f8dc 3000 	ldr.w	r3, [ip]
  409b8c:	4667      	mov	r7, ip
  409b8e:	4618      	mov	r0, r3
  409b90:	464d      	mov	r5, r9
  409b92:	2100      	movs	r1, #0
  409b94:	e000      	b.n	409b98 <__multiply+0xc8>
  409b96:	4637      	mov	r7, r6
  409b98:	882c      	ldrh	r4, [r5, #0]
  409b9a:	0c00      	lsrs	r0, r0, #16
  409b9c:	fb0b 0004 	mla	r0, fp, r4, r0
  409ba0:	4401      	add	r1, r0
  409ba2:	b29c      	uxth	r4, r3
  409ba4:	463e      	mov	r6, r7
  409ba6:	ea44 4301 	orr.w	r3, r4, r1, lsl #16
  409baa:	f846 3b04 	str.w	r3, [r6], #4
  409bae:	6878      	ldr	r0, [r7, #4]
  409bb0:	f855 4b04 	ldr.w	r4, [r5], #4
  409bb4:	b283      	uxth	r3, r0
  409bb6:	0c24      	lsrs	r4, r4, #16
  409bb8:	fb0b 3404 	mla	r4, fp, r4, r3
  409bbc:	eb04 4311 	add.w	r3, r4, r1, lsr #16
  409bc0:	45ae      	cmp	lr, r5
  409bc2:	ea4f 4113 	mov.w	r1, r3, lsr #16
  409bc6:	d8e6      	bhi.n	409b96 <__multiply+0xc6>
  409bc8:	607b      	str	r3, [r7, #4]
  409bca:	4592      	cmp	sl, r2
  409bcc:	f10c 0c04 	add.w	ip, ip, #4
  409bd0:	d8af      	bhi.n	409b32 <__multiply+0x62>
  409bd2:	f8dd 9004 	ldr.w	r9, [sp, #4]
  409bd6:	f1b8 0f00 	cmp.w	r8, #0
  409bda:	dd0b      	ble.n	409bf4 <__multiply+0x124>
  409bdc:	f859 3c04 	ldr.w	r3, [r9, #-4]
  409be0:	f1a9 0904 	sub.w	r9, r9, #4
  409be4:	b11b      	cbz	r3, 409bee <__multiply+0x11e>
  409be6:	e005      	b.n	409bf4 <__multiply+0x124>
  409be8:	f859 3d04 	ldr.w	r3, [r9, #-4]!
  409bec:	b913      	cbnz	r3, 409bf4 <__multiply+0x124>
  409bee:	f1b8 0801 	subs.w	r8, r8, #1
  409bf2:	d1f9      	bne.n	409be8 <__multiply+0x118>
  409bf4:	9800      	ldr	r0, [sp, #0]
  409bf6:	f8c0 8010 	str.w	r8, [r0, #16]
  409bfa:	b003      	add	sp, #12
  409bfc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00409c00 <__pow5mult>:
  409c00:	f012 0303 	ands.w	r3, r2, #3
  409c04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  409c08:	4614      	mov	r4, r2
  409c0a:	4607      	mov	r7, r0
  409c0c:	d12e      	bne.n	409c6c <__pow5mult+0x6c>
  409c0e:	460e      	mov	r6, r1
  409c10:	10a4      	asrs	r4, r4, #2
  409c12:	d01c      	beq.n	409c4e <__pow5mult+0x4e>
  409c14:	6cbd      	ldr	r5, [r7, #72]	; 0x48
  409c16:	b395      	cbz	r5, 409c7e <__pow5mult+0x7e>
  409c18:	07e3      	lsls	r3, r4, #31
  409c1a:	f04f 0800 	mov.w	r8, #0
  409c1e:	d406      	bmi.n	409c2e <__pow5mult+0x2e>
  409c20:	1064      	asrs	r4, r4, #1
  409c22:	d014      	beq.n	409c4e <__pow5mult+0x4e>
  409c24:	6828      	ldr	r0, [r5, #0]
  409c26:	b1a8      	cbz	r0, 409c54 <__pow5mult+0x54>
  409c28:	4605      	mov	r5, r0
  409c2a:	07e3      	lsls	r3, r4, #31
  409c2c:	d5f8      	bpl.n	409c20 <__pow5mult+0x20>
  409c2e:	462a      	mov	r2, r5
  409c30:	4631      	mov	r1, r6
  409c32:	4638      	mov	r0, r7
  409c34:	f7ff ff4c 	bl	409ad0 <__multiply>
  409c38:	b1b6      	cbz	r6, 409c68 <__pow5mult+0x68>
  409c3a:	6872      	ldr	r2, [r6, #4]
  409c3c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  409c3e:	1064      	asrs	r4, r4, #1
  409c40:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
  409c44:	6031      	str	r1, [r6, #0]
  409c46:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
  409c4a:	4606      	mov	r6, r0
  409c4c:	d1ea      	bne.n	409c24 <__pow5mult+0x24>
  409c4e:	4630      	mov	r0, r6
  409c50:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  409c54:	462a      	mov	r2, r5
  409c56:	4629      	mov	r1, r5
  409c58:	4638      	mov	r0, r7
  409c5a:	f7ff ff39 	bl	409ad0 <__multiply>
  409c5e:	6028      	str	r0, [r5, #0]
  409c60:	f8c0 8000 	str.w	r8, [r0]
  409c64:	4605      	mov	r5, r0
  409c66:	e7e0      	b.n	409c2a <__pow5mult+0x2a>
  409c68:	4606      	mov	r6, r0
  409c6a:	e7d9      	b.n	409c20 <__pow5mult+0x20>
  409c6c:	1e5a      	subs	r2, r3, #1
  409c6e:	4d0b      	ldr	r5, [pc, #44]	; (409c9c <__pow5mult+0x9c>)
  409c70:	2300      	movs	r3, #0
  409c72:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
  409c76:	f7ff fe93 	bl	4099a0 <__multadd>
  409c7a:	4606      	mov	r6, r0
  409c7c:	e7c8      	b.n	409c10 <__pow5mult+0x10>
  409c7e:	2101      	movs	r1, #1
  409c80:	4638      	mov	r0, r7
  409c82:	f7ff fe5d 	bl	409940 <_Balloc>
  409c86:	f240 2171 	movw	r1, #625	; 0x271
  409c8a:	2201      	movs	r2, #1
  409c8c:	2300      	movs	r3, #0
  409c8e:	6141      	str	r1, [r0, #20]
  409c90:	6102      	str	r2, [r0, #16]
  409c92:	4605      	mov	r5, r0
  409c94:	64b8      	str	r0, [r7, #72]	; 0x48
  409c96:	6003      	str	r3, [r0, #0]
  409c98:	e7be      	b.n	409c18 <__pow5mult+0x18>
  409c9a:	bf00      	nop
  409c9c:	0040af68 	.word	0x0040af68

00409ca0 <__lshift>:
  409ca0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  409ca4:	4691      	mov	r9, r2
  409ca6:	690a      	ldr	r2, [r1, #16]
  409ca8:	688b      	ldr	r3, [r1, #8]
  409caa:	ea4f 1469 	mov.w	r4, r9, asr #5
  409cae:	eb04 0802 	add.w	r8, r4, r2
  409cb2:	f108 0501 	add.w	r5, r8, #1
  409cb6:	429d      	cmp	r5, r3
  409cb8:	460e      	mov	r6, r1
  409cba:	4682      	mov	sl, r0
  409cbc:	6849      	ldr	r1, [r1, #4]
  409cbe:	dd04      	ble.n	409cca <__lshift+0x2a>
  409cc0:	005b      	lsls	r3, r3, #1
  409cc2:	429d      	cmp	r5, r3
  409cc4:	f101 0101 	add.w	r1, r1, #1
  409cc8:	dcfa      	bgt.n	409cc0 <__lshift+0x20>
  409cca:	4650      	mov	r0, sl
  409ccc:	f7ff fe38 	bl	409940 <_Balloc>
  409cd0:	2c00      	cmp	r4, #0
  409cd2:	f100 0214 	add.w	r2, r0, #20
  409cd6:	dd38      	ble.n	409d4a <__lshift+0xaa>
  409cd8:	eb02 0384 	add.w	r3, r2, r4, lsl #2
  409cdc:	2100      	movs	r1, #0
  409cde:	f842 1b04 	str.w	r1, [r2], #4
  409ce2:	4293      	cmp	r3, r2
  409ce4:	d1fb      	bne.n	409cde <__lshift+0x3e>
  409ce6:	6934      	ldr	r4, [r6, #16]
  409ce8:	f106 0114 	add.w	r1, r6, #20
  409cec:	f019 091f 	ands.w	r9, r9, #31
  409cf0:	eb01 0e84 	add.w	lr, r1, r4, lsl #2
  409cf4:	d021      	beq.n	409d3a <__lshift+0x9a>
  409cf6:	f1c9 0220 	rsb	r2, r9, #32
  409cfa:	2400      	movs	r4, #0
  409cfc:	680f      	ldr	r7, [r1, #0]
  409cfe:	fa07 fc09 	lsl.w	ip, r7, r9
  409d02:	ea4c 0404 	orr.w	r4, ip, r4
  409d06:	469c      	mov	ip, r3
  409d08:	f843 4b04 	str.w	r4, [r3], #4
  409d0c:	f851 4b04 	ldr.w	r4, [r1], #4
  409d10:	458e      	cmp	lr, r1
  409d12:	fa24 f402 	lsr.w	r4, r4, r2
  409d16:	d8f1      	bhi.n	409cfc <__lshift+0x5c>
  409d18:	f8cc 4004 	str.w	r4, [ip, #4]
  409d1c:	b10c      	cbz	r4, 409d22 <__lshift+0x82>
  409d1e:	f108 0502 	add.w	r5, r8, #2
  409d22:	f8da 304c 	ldr.w	r3, [sl, #76]	; 0x4c
  409d26:	6872      	ldr	r2, [r6, #4]
  409d28:	3d01      	subs	r5, #1
  409d2a:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
  409d2e:	6105      	str	r5, [r0, #16]
  409d30:	6031      	str	r1, [r6, #0]
  409d32:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
  409d36:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  409d3a:	3b04      	subs	r3, #4
  409d3c:	f851 2b04 	ldr.w	r2, [r1], #4
  409d40:	f843 2f04 	str.w	r2, [r3, #4]!
  409d44:	458e      	cmp	lr, r1
  409d46:	d8f9      	bhi.n	409d3c <__lshift+0x9c>
  409d48:	e7eb      	b.n	409d22 <__lshift+0x82>
  409d4a:	4613      	mov	r3, r2
  409d4c:	e7cb      	b.n	409ce6 <__lshift+0x46>
  409d4e:	bf00      	nop

00409d50 <__mcmp>:
  409d50:	6902      	ldr	r2, [r0, #16]
  409d52:	690b      	ldr	r3, [r1, #16]
  409d54:	1ad2      	subs	r2, r2, r3
  409d56:	d112      	bne.n	409d7e <__mcmp+0x2e>
  409d58:	009b      	lsls	r3, r3, #2
  409d5a:	3014      	adds	r0, #20
  409d5c:	3114      	adds	r1, #20
  409d5e:	4419      	add	r1, r3
  409d60:	b410      	push	{r4}
  409d62:	4403      	add	r3, r0
  409d64:	e001      	b.n	409d6a <__mcmp+0x1a>
  409d66:	4298      	cmp	r0, r3
  409d68:	d20b      	bcs.n	409d82 <__mcmp+0x32>
  409d6a:	f853 4d04 	ldr.w	r4, [r3, #-4]!
  409d6e:	f851 2d04 	ldr.w	r2, [r1, #-4]!
  409d72:	4294      	cmp	r4, r2
  409d74:	d0f7      	beq.n	409d66 <__mcmp+0x16>
  409d76:	d307      	bcc.n	409d88 <__mcmp+0x38>
  409d78:	2001      	movs	r0, #1
  409d7a:	bc10      	pop	{r4}
  409d7c:	4770      	bx	lr
  409d7e:	4610      	mov	r0, r2
  409d80:	4770      	bx	lr
  409d82:	2000      	movs	r0, #0
  409d84:	bc10      	pop	{r4}
  409d86:	4770      	bx	lr
  409d88:	f04f 30ff 	mov.w	r0, #4294967295
  409d8c:	e7f5      	b.n	409d7a <__mcmp+0x2a>
  409d8e:	bf00      	nop

00409d90 <__mdiff>:
  409d90:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  409d94:	690b      	ldr	r3, [r1, #16]
  409d96:	460f      	mov	r7, r1
  409d98:	6911      	ldr	r1, [r2, #16]
  409d9a:	1a5b      	subs	r3, r3, r1
  409d9c:	2b00      	cmp	r3, #0
  409d9e:	4690      	mov	r8, r2
  409da0:	d117      	bne.n	409dd2 <__mdiff+0x42>
  409da2:	0089      	lsls	r1, r1, #2
  409da4:	f107 0214 	add.w	r2, r7, #20
  409da8:	f108 0514 	add.w	r5, r8, #20
  409dac:	1853      	adds	r3, r2, r1
  409dae:	4429      	add	r1, r5
  409db0:	e001      	b.n	409db6 <__mdiff+0x26>
  409db2:	429a      	cmp	r2, r3
  409db4:	d25e      	bcs.n	409e74 <__mdiff+0xe4>
  409db6:	f853 6d04 	ldr.w	r6, [r3, #-4]!
  409dba:	f851 4d04 	ldr.w	r4, [r1, #-4]!
  409dbe:	42a6      	cmp	r6, r4
  409dc0:	d0f7      	beq.n	409db2 <__mdiff+0x22>
  409dc2:	d260      	bcs.n	409e86 <__mdiff+0xf6>
  409dc4:	463b      	mov	r3, r7
  409dc6:	4614      	mov	r4, r2
  409dc8:	4647      	mov	r7, r8
  409dca:	f04f 0901 	mov.w	r9, #1
  409dce:	4698      	mov	r8, r3
  409dd0:	e006      	b.n	409de0 <__mdiff+0x50>
  409dd2:	db5d      	blt.n	409e90 <__mdiff+0x100>
  409dd4:	f107 0514 	add.w	r5, r7, #20
  409dd8:	f102 0414 	add.w	r4, r2, #20
  409ddc:	f04f 0900 	mov.w	r9, #0
  409de0:	6879      	ldr	r1, [r7, #4]
  409de2:	f7ff fdad 	bl	409940 <_Balloc>
  409de6:	f8d8 3010 	ldr.w	r3, [r8, #16]
  409dea:	693e      	ldr	r6, [r7, #16]
  409dec:	f8c0 900c 	str.w	r9, [r0, #12]
  409df0:	eb04 0c83 	add.w	ip, r4, r3, lsl #2
  409df4:	46a6      	mov	lr, r4
  409df6:	eb05 0786 	add.w	r7, r5, r6, lsl #2
  409dfa:	f100 0414 	add.w	r4, r0, #20
  409dfe:	2300      	movs	r3, #0
  409e00:	f85e 1b04 	ldr.w	r1, [lr], #4
  409e04:	f855 8b04 	ldr.w	r8, [r5], #4
  409e08:	b28a      	uxth	r2, r1
  409e0a:	fa13 f388 	uxtah	r3, r3, r8
  409e0e:	0c09      	lsrs	r1, r1, #16
  409e10:	1a9a      	subs	r2, r3, r2
  409e12:	ebc1 4318 	rsb	r3, r1, r8, lsr #16
  409e16:	eb03 4322 	add.w	r3, r3, r2, asr #16
  409e1a:	b292      	uxth	r2, r2
  409e1c:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
  409e20:	45f4      	cmp	ip, lr
  409e22:	f844 2b04 	str.w	r2, [r4], #4
  409e26:	ea4f 4323 	mov.w	r3, r3, asr #16
  409e2a:	d8e9      	bhi.n	409e00 <__mdiff+0x70>
  409e2c:	42af      	cmp	r7, r5
  409e2e:	d917      	bls.n	409e60 <__mdiff+0xd0>
  409e30:	46a4      	mov	ip, r4
  409e32:	4629      	mov	r1, r5
  409e34:	f851 eb04 	ldr.w	lr, [r1], #4
  409e38:	fa13 f28e 	uxtah	r2, r3, lr
  409e3c:	1413      	asrs	r3, r2, #16
  409e3e:	eb03 431e 	add.w	r3, r3, lr, lsr #16
  409e42:	b292      	uxth	r2, r2
  409e44:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
  409e48:	428f      	cmp	r7, r1
  409e4a:	f84c 2b04 	str.w	r2, [ip], #4
  409e4e:	ea4f 4323 	mov.w	r3, r3, asr #16
  409e52:	d8ef      	bhi.n	409e34 <__mdiff+0xa4>
  409e54:	43ed      	mvns	r5, r5
  409e56:	443d      	add	r5, r7
  409e58:	f025 0503 	bic.w	r5, r5, #3
  409e5c:	3504      	adds	r5, #4
  409e5e:	442c      	add	r4, r5
  409e60:	3c04      	subs	r4, #4
  409e62:	b922      	cbnz	r2, 409e6e <__mdiff+0xde>
  409e64:	f854 3d04 	ldr.w	r3, [r4, #-4]!
  409e68:	3e01      	subs	r6, #1
  409e6a:	2b00      	cmp	r3, #0
  409e6c:	d0fa      	beq.n	409e64 <__mdiff+0xd4>
  409e6e:	6106      	str	r6, [r0, #16]
  409e70:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  409e74:	2100      	movs	r1, #0
  409e76:	f7ff fd63 	bl	409940 <_Balloc>
  409e7a:	2201      	movs	r2, #1
  409e7c:	2300      	movs	r3, #0
  409e7e:	6102      	str	r2, [r0, #16]
  409e80:	6143      	str	r3, [r0, #20]
  409e82:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  409e86:	462c      	mov	r4, r5
  409e88:	f04f 0900 	mov.w	r9, #0
  409e8c:	4615      	mov	r5, r2
  409e8e:	e7a7      	b.n	409de0 <__mdiff+0x50>
  409e90:	463b      	mov	r3, r7
  409e92:	f107 0414 	add.w	r4, r7, #20
  409e96:	f108 0514 	add.w	r5, r8, #20
  409e9a:	4647      	mov	r7, r8
  409e9c:	f04f 0901 	mov.w	r9, #1
  409ea0:	4698      	mov	r8, r3
  409ea2:	e79d      	b.n	409de0 <__mdiff+0x50>

00409ea4 <__d2b>:
  409ea4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  409ea8:	b082      	sub	sp, #8
  409eaa:	2101      	movs	r1, #1
  409eac:	461c      	mov	r4, r3
  409eae:	f3c3 570a 	ubfx	r7, r3, #20, #11
  409eb2:	4615      	mov	r5, r2
  409eb4:	9e08      	ldr	r6, [sp, #32]
  409eb6:	f7ff fd43 	bl	409940 <_Balloc>
  409eba:	f3c4 0413 	ubfx	r4, r4, #0, #20
  409ebe:	4680      	mov	r8, r0
  409ec0:	b10f      	cbz	r7, 409ec6 <__d2b+0x22>
  409ec2:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
  409ec6:	9401      	str	r4, [sp, #4]
  409ec8:	b31d      	cbz	r5, 409f12 <__d2b+0x6e>
  409eca:	a802      	add	r0, sp, #8
  409ecc:	f840 5d08 	str.w	r5, [r0, #-8]!
  409ed0:	f7ff fdc6 	bl	409a60 <__lo0bits>
  409ed4:	2800      	cmp	r0, #0
  409ed6:	d134      	bne.n	409f42 <__d2b+0x9e>
  409ed8:	e89d 000c 	ldmia.w	sp, {r2, r3}
  409edc:	f8c8 2014 	str.w	r2, [r8, #20]
  409ee0:	2b00      	cmp	r3, #0
  409ee2:	bf0c      	ite	eq
  409ee4:	2101      	moveq	r1, #1
  409ee6:	2102      	movne	r1, #2
  409ee8:	f8c8 3018 	str.w	r3, [r8, #24]
  409eec:	f8c8 1010 	str.w	r1, [r8, #16]
  409ef0:	b9df      	cbnz	r7, 409f2a <__d2b+0x86>
  409ef2:	eb08 0381 	add.w	r3, r8, r1, lsl #2
  409ef6:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
  409efa:	6030      	str	r0, [r6, #0]
  409efc:	6918      	ldr	r0, [r3, #16]
  409efe:	f7ff fd8f 	bl	409a20 <__hi0bits>
  409f02:	9b09      	ldr	r3, [sp, #36]	; 0x24
  409f04:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
  409f08:	6018      	str	r0, [r3, #0]
  409f0a:	4640      	mov	r0, r8
  409f0c:	b002      	add	sp, #8
  409f0e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  409f12:	a801      	add	r0, sp, #4
  409f14:	f7ff fda4 	bl	409a60 <__lo0bits>
  409f18:	9b01      	ldr	r3, [sp, #4]
  409f1a:	f8c8 3014 	str.w	r3, [r8, #20]
  409f1e:	2101      	movs	r1, #1
  409f20:	3020      	adds	r0, #32
  409f22:	f8c8 1010 	str.w	r1, [r8, #16]
  409f26:	2f00      	cmp	r7, #0
  409f28:	d0e3      	beq.n	409ef2 <__d2b+0x4e>
  409f2a:	9b09      	ldr	r3, [sp, #36]	; 0x24
  409f2c:	f2a7 4733 	subw	r7, r7, #1075	; 0x433
  409f30:	4407      	add	r7, r0
  409f32:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
  409f36:	6037      	str	r7, [r6, #0]
  409f38:	6018      	str	r0, [r3, #0]
  409f3a:	4640      	mov	r0, r8
  409f3c:	b002      	add	sp, #8
  409f3e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  409f42:	e89d 000c 	ldmia.w	sp, {r2, r3}
  409f46:	f1c0 0120 	rsb	r1, r0, #32
  409f4a:	fa03 f101 	lsl.w	r1, r3, r1
  409f4e:	430a      	orrs	r2, r1
  409f50:	40c3      	lsrs	r3, r0
  409f52:	9301      	str	r3, [sp, #4]
  409f54:	f8c8 2014 	str.w	r2, [r8, #20]
  409f58:	e7c2      	b.n	409ee0 <__d2b+0x3c>
  409f5a:	bf00      	nop

00409f5c <_realloc_r>:
  409f5c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  409f60:	4617      	mov	r7, r2
  409f62:	b083      	sub	sp, #12
  409f64:	2900      	cmp	r1, #0
  409f66:	f000 80c1 	beq.w	40a0ec <_realloc_r+0x190>
  409f6a:	460e      	mov	r6, r1
  409f6c:	4681      	mov	r9, r0
  409f6e:	f107 050b 	add.w	r5, r7, #11
  409f72:	f7ff fce1 	bl	409938 <__malloc_lock>
  409f76:	f856 ec04 	ldr.w	lr, [r6, #-4]
  409f7a:	2d16      	cmp	r5, #22
  409f7c:	f02e 0403 	bic.w	r4, lr, #3
  409f80:	f1a6 0808 	sub.w	r8, r6, #8
  409f84:	d840      	bhi.n	40a008 <_realloc_r+0xac>
  409f86:	2210      	movs	r2, #16
  409f88:	4615      	mov	r5, r2
  409f8a:	42af      	cmp	r7, r5
  409f8c:	d841      	bhi.n	40a012 <_realloc_r+0xb6>
  409f8e:	4294      	cmp	r4, r2
  409f90:	da75      	bge.n	40a07e <_realloc_r+0x122>
  409f92:	4bc9      	ldr	r3, [pc, #804]	; (40a2b8 <_realloc_r+0x35c>)
  409f94:	6899      	ldr	r1, [r3, #8]
  409f96:	eb08 0004 	add.w	r0, r8, r4
  409f9a:	4288      	cmp	r0, r1
  409f9c:	6841      	ldr	r1, [r0, #4]
  409f9e:	f000 80d9 	beq.w	40a154 <_realloc_r+0x1f8>
  409fa2:	f021 0301 	bic.w	r3, r1, #1
  409fa6:	4403      	add	r3, r0
  409fa8:	685b      	ldr	r3, [r3, #4]
  409faa:	07db      	lsls	r3, r3, #31
  409fac:	d57d      	bpl.n	40a0aa <_realloc_r+0x14e>
  409fae:	f01e 0f01 	tst.w	lr, #1
  409fb2:	d035      	beq.n	40a020 <_realloc_r+0xc4>
  409fb4:	4639      	mov	r1, r7
  409fb6:	4648      	mov	r0, r9
  409fb8:	f7ff f952 	bl	409260 <_malloc_r>
  409fbc:	4607      	mov	r7, r0
  409fbe:	b1e0      	cbz	r0, 409ffa <_realloc_r+0x9e>
  409fc0:	f856 3c04 	ldr.w	r3, [r6, #-4]
  409fc4:	f023 0301 	bic.w	r3, r3, #1
  409fc8:	4443      	add	r3, r8
  409fca:	f1a0 0208 	sub.w	r2, r0, #8
  409fce:	429a      	cmp	r2, r3
  409fd0:	f000 8144 	beq.w	40a25c <_realloc_r+0x300>
  409fd4:	1f22      	subs	r2, r4, #4
  409fd6:	2a24      	cmp	r2, #36	; 0x24
  409fd8:	f200 8131 	bhi.w	40a23e <_realloc_r+0x2e2>
  409fdc:	2a13      	cmp	r2, #19
  409fde:	f200 8104 	bhi.w	40a1ea <_realloc_r+0x28e>
  409fe2:	4603      	mov	r3, r0
  409fe4:	4632      	mov	r2, r6
  409fe6:	6811      	ldr	r1, [r2, #0]
  409fe8:	6019      	str	r1, [r3, #0]
  409fea:	6851      	ldr	r1, [r2, #4]
  409fec:	6059      	str	r1, [r3, #4]
  409fee:	6892      	ldr	r2, [r2, #8]
  409ff0:	609a      	str	r2, [r3, #8]
  409ff2:	4631      	mov	r1, r6
  409ff4:	4648      	mov	r0, r9
  409ff6:	f7fe fe15 	bl	408c24 <_free_r>
  409ffa:	4648      	mov	r0, r9
  409ffc:	f7ff fc9e 	bl	40993c <__malloc_unlock>
  40a000:	4638      	mov	r0, r7
  40a002:	b003      	add	sp, #12
  40a004:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40a008:	f025 0507 	bic.w	r5, r5, #7
  40a00c:	2d00      	cmp	r5, #0
  40a00e:	462a      	mov	r2, r5
  40a010:	dabb      	bge.n	409f8a <_realloc_r+0x2e>
  40a012:	230c      	movs	r3, #12
  40a014:	2000      	movs	r0, #0
  40a016:	f8c9 3000 	str.w	r3, [r9]
  40a01a:	b003      	add	sp, #12
  40a01c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40a020:	f856 3c08 	ldr.w	r3, [r6, #-8]
  40a024:	ebc3 0a08 	rsb	sl, r3, r8
  40a028:	f8da 3004 	ldr.w	r3, [sl, #4]
  40a02c:	f023 0c03 	bic.w	ip, r3, #3
  40a030:	eb04 030c 	add.w	r3, r4, ip
  40a034:	4293      	cmp	r3, r2
  40a036:	dbbd      	blt.n	409fb4 <_realloc_r+0x58>
  40a038:	4657      	mov	r7, sl
  40a03a:	f8da 100c 	ldr.w	r1, [sl, #12]
  40a03e:	f857 0f08 	ldr.w	r0, [r7, #8]!
  40a042:	1f22      	subs	r2, r4, #4
  40a044:	2a24      	cmp	r2, #36	; 0x24
  40a046:	60c1      	str	r1, [r0, #12]
  40a048:	6088      	str	r0, [r1, #8]
  40a04a:	f200 8117 	bhi.w	40a27c <_realloc_r+0x320>
  40a04e:	2a13      	cmp	r2, #19
  40a050:	f240 8112 	bls.w	40a278 <_realloc_r+0x31c>
  40a054:	6831      	ldr	r1, [r6, #0]
  40a056:	f8ca 1008 	str.w	r1, [sl, #8]
  40a05a:	6871      	ldr	r1, [r6, #4]
  40a05c:	f8ca 100c 	str.w	r1, [sl, #12]
  40a060:	2a1b      	cmp	r2, #27
  40a062:	f200 812b 	bhi.w	40a2bc <_realloc_r+0x360>
  40a066:	3608      	adds	r6, #8
  40a068:	f10a 0210 	add.w	r2, sl, #16
  40a06c:	6831      	ldr	r1, [r6, #0]
  40a06e:	6011      	str	r1, [r2, #0]
  40a070:	6871      	ldr	r1, [r6, #4]
  40a072:	6051      	str	r1, [r2, #4]
  40a074:	68b1      	ldr	r1, [r6, #8]
  40a076:	6091      	str	r1, [r2, #8]
  40a078:	463e      	mov	r6, r7
  40a07a:	461c      	mov	r4, r3
  40a07c:	46d0      	mov	r8, sl
  40a07e:	1b63      	subs	r3, r4, r5
  40a080:	2b0f      	cmp	r3, #15
  40a082:	d81d      	bhi.n	40a0c0 <_realloc_r+0x164>
  40a084:	f8d8 3004 	ldr.w	r3, [r8, #4]
  40a088:	f003 0301 	and.w	r3, r3, #1
  40a08c:	4323      	orrs	r3, r4
  40a08e:	4444      	add	r4, r8
  40a090:	f8c8 3004 	str.w	r3, [r8, #4]
  40a094:	6863      	ldr	r3, [r4, #4]
  40a096:	f043 0301 	orr.w	r3, r3, #1
  40a09a:	6063      	str	r3, [r4, #4]
  40a09c:	4648      	mov	r0, r9
  40a09e:	f7ff fc4d 	bl	40993c <__malloc_unlock>
  40a0a2:	4630      	mov	r0, r6
  40a0a4:	b003      	add	sp, #12
  40a0a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40a0aa:	f021 0103 	bic.w	r1, r1, #3
  40a0ae:	4421      	add	r1, r4
  40a0b0:	4291      	cmp	r1, r2
  40a0b2:	db21      	blt.n	40a0f8 <_realloc_r+0x19c>
  40a0b4:	68c3      	ldr	r3, [r0, #12]
  40a0b6:	6882      	ldr	r2, [r0, #8]
  40a0b8:	460c      	mov	r4, r1
  40a0ba:	60d3      	str	r3, [r2, #12]
  40a0bc:	609a      	str	r2, [r3, #8]
  40a0be:	e7de      	b.n	40a07e <_realloc_r+0x122>
  40a0c0:	f8d8 2004 	ldr.w	r2, [r8, #4]
  40a0c4:	eb08 0105 	add.w	r1, r8, r5
  40a0c8:	f002 0201 	and.w	r2, r2, #1
  40a0cc:	4315      	orrs	r5, r2
  40a0ce:	f043 0201 	orr.w	r2, r3, #1
  40a0d2:	440b      	add	r3, r1
  40a0d4:	f8c8 5004 	str.w	r5, [r8, #4]
  40a0d8:	604a      	str	r2, [r1, #4]
  40a0da:	685a      	ldr	r2, [r3, #4]
  40a0dc:	f042 0201 	orr.w	r2, r2, #1
  40a0e0:	3108      	adds	r1, #8
  40a0e2:	605a      	str	r2, [r3, #4]
  40a0e4:	4648      	mov	r0, r9
  40a0e6:	f7fe fd9d 	bl	408c24 <_free_r>
  40a0ea:	e7d7      	b.n	40a09c <_realloc_r+0x140>
  40a0ec:	4611      	mov	r1, r2
  40a0ee:	b003      	add	sp, #12
  40a0f0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40a0f4:	f7ff b8b4 	b.w	409260 <_malloc_r>
  40a0f8:	f01e 0f01 	tst.w	lr, #1
  40a0fc:	f47f af5a 	bne.w	409fb4 <_realloc_r+0x58>
  40a100:	f856 3c08 	ldr.w	r3, [r6, #-8]
  40a104:	ebc3 0a08 	rsb	sl, r3, r8
  40a108:	f8da 3004 	ldr.w	r3, [sl, #4]
  40a10c:	f023 0c03 	bic.w	ip, r3, #3
  40a110:	eb01 0e0c 	add.w	lr, r1, ip
  40a114:	4596      	cmp	lr, r2
  40a116:	db8b      	blt.n	40a030 <_realloc_r+0xd4>
  40a118:	68c3      	ldr	r3, [r0, #12]
  40a11a:	6882      	ldr	r2, [r0, #8]
  40a11c:	4657      	mov	r7, sl
  40a11e:	60d3      	str	r3, [r2, #12]
  40a120:	609a      	str	r2, [r3, #8]
  40a122:	f857 1f08 	ldr.w	r1, [r7, #8]!
  40a126:	f8da 300c 	ldr.w	r3, [sl, #12]
  40a12a:	60cb      	str	r3, [r1, #12]
  40a12c:	1f22      	subs	r2, r4, #4
  40a12e:	2a24      	cmp	r2, #36	; 0x24
  40a130:	6099      	str	r1, [r3, #8]
  40a132:	f200 8099 	bhi.w	40a268 <_realloc_r+0x30c>
  40a136:	2a13      	cmp	r2, #19
  40a138:	d962      	bls.n	40a200 <_realloc_r+0x2a4>
  40a13a:	6833      	ldr	r3, [r6, #0]
  40a13c:	f8ca 3008 	str.w	r3, [sl, #8]
  40a140:	6873      	ldr	r3, [r6, #4]
  40a142:	f8ca 300c 	str.w	r3, [sl, #12]
  40a146:	2a1b      	cmp	r2, #27
  40a148:	f200 80a0 	bhi.w	40a28c <_realloc_r+0x330>
  40a14c:	3608      	adds	r6, #8
  40a14e:	f10a 0310 	add.w	r3, sl, #16
  40a152:	e056      	b.n	40a202 <_realloc_r+0x2a6>
  40a154:	f021 0b03 	bic.w	fp, r1, #3
  40a158:	44a3      	add	fp, r4
  40a15a:	f105 0010 	add.w	r0, r5, #16
  40a15e:	4583      	cmp	fp, r0
  40a160:	da59      	bge.n	40a216 <_realloc_r+0x2ba>
  40a162:	f01e 0f01 	tst.w	lr, #1
  40a166:	f47f af25 	bne.w	409fb4 <_realloc_r+0x58>
  40a16a:	f856 1c08 	ldr.w	r1, [r6, #-8]
  40a16e:	ebc1 0a08 	rsb	sl, r1, r8
  40a172:	f8da 1004 	ldr.w	r1, [sl, #4]
  40a176:	f021 0c03 	bic.w	ip, r1, #3
  40a17a:	44e3      	add	fp, ip
  40a17c:	4558      	cmp	r0, fp
  40a17e:	f73f af57 	bgt.w	40a030 <_realloc_r+0xd4>
  40a182:	4657      	mov	r7, sl
  40a184:	f8da 100c 	ldr.w	r1, [sl, #12]
  40a188:	f857 0f08 	ldr.w	r0, [r7, #8]!
  40a18c:	1f22      	subs	r2, r4, #4
  40a18e:	2a24      	cmp	r2, #36	; 0x24
  40a190:	60c1      	str	r1, [r0, #12]
  40a192:	6088      	str	r0, [r1, #8]
  40a194:	f200 80b4 	bhi.w	40a300 <_realloc_r+0x3a4>
  40a198:	2a13      	cmp	r2, #19
  40a19a:	f240 80a5 	bls.w	40a2e8 <_realloc_r+0x38c>
  40a19e:	6831      	ldr	r1, [r6, #0]
  40a1a0:	f8ca 1008 	str.w	r1, [sl, #8]
  40a1a4:	6871      	ldr	r1, [r6, #4]
  40a1a6:	f8ca 100c 	str.w	r1, [sl, #12]
  40a1aa:	2a1b      	cmp	r2, #27
  40a1ac:	f200 80af 	bhi.w	40a30e <_realloc_r+0x3b2>
  40a1b0:	3608      	adds	r6, #8
  40a1b2:	f10a 0210 	add.w	r2, sl, #16
  40a1b6:	6831      	ldr	r1, [r6, #0]
  40a1b8:	6011      	str	r1, [r2, #0]
  40a1ba:	6871      	ldr	r1, [r6, #4]
  40a1bc:	6051      	str	r1, [r2, #4]
  40a1be:	68b1      	ldr	r1, [r6, #8]
  40a1c0:	6091      	str	r1, [r2, #8]
  40a1c2:	eb0a 0105 	add.w	r1, sl, r5
  40a1c6:	ebc5 020b 	rsb	r2, r5, fp
  40a1ca:	f042 0201 	orr.w	r2, r2, #1
  40a1ce:	6099      	str	r1, [r3, #8]
  40a1d0:	604a      	str	r2, [r1, #4]
  40a1d2:	f8da 3004 	ldr.w	r3, [sl, #4]
  40a1d6:	f003 0301 	and.w	r3, r3, #1
  40a1da:	431d      	orrs	r5, r3
  40a1dc:	4648      	mov	r0, r9
  40a1de:	f8ca 5004 	str.w	r5, [sl, #4]
  40a1e2:	f7ff fbab 	bl	40993c <__malloc_unlock>
  40a1e6:	4638      	mov	r0, r7
  40a1e8:	e75c      	b.n	40a0a4 <_realloc_r+0x148>
  40a1ea:	6833      	ldr	r3, [r6, #0]
  40a1ec:	6003      	str	r3, [r0, #0]
  40a1ee:	6873      	ldr	r3, [r6, #4]
  40a1f0:	6043      	str	r3, [r0, #4]
  40a1f2:	2a1b      	cmp	r2, #27
  40a1f4:	d827      	bhi.n	40a246 <_realloc_r+0x2ea>
  40a1f6:	f100 0308 	add.w	r3, r0, #8
  40a1fa:	f106 0208 	add.w	r2, r6, #8
  40a1fe:	e6f2      	b.n	409fe6 <_realloc_r+0x8a>
  40a200:	463b      	mov	r3, r7
  40a202:	6832      	ldr	r2, [r6, #0]
  40a204:	601a      	str	r2, [r3, #0]
  40a206:	6872      	ldr	r2, [r6, #4]
  40a208:	605a      	str	r2, [r3, #4]
  40a20a:	68b2      	ldr	r2, [r6, #8]
  40a20c:	609a      	str	r2, [r3, #8]
  40a20e:	463e      	mov	r6, r7
  40a210:	4674      	mov	r4, lr
  40a212:	46d0      	mov	r8, sl
  40a214:	e733      	b.n	40a07e <_realloc_r+0x122>
  40a216:	eb08 0105 	add.w	r1, r8, r5
  40a21a:	ebc5 0b0b 	rsb	fp, r5, fp
  40a21e:	f04b 0201 	orr.w	r2, fp, #1
  40a222:	6099      	str	r1, [r3, #8]
  40a224:	604a      	str	r2, [r1, #4]
  40a226:	f856 3c04 	ldr.w	r3, [r6, #-4]
  40a22a:	f003 0301 	and.w	r3, r3, #1
  40a22e:	431d      	orrs	r5, r3
  40a230:	4648      	mov	r0, r9
  40a232:	f846 5c04 	str.w	r5, [r6, #-4]
  40a236:	f7ff fb81 	bl	40993c <__malloc_unlock>
  40a23a:	4630      	mov	r0, r6
  40a23c:	e732      	b.n	40a0a4 <_realloc_r+0x148>
  40a23e:	4631      	mov	r1, r6
  40a240:	f7ff fb16 	bl	409870 <memmove>
  40a244:	e6d5      	b.n	409ff2 <_realloc_r+0x96>
  40a246:	68b3      	ldr	r3, [r6, #8]
  40a248:	6083      	str	r3, [r0, #8]
  40a24a:	68f3      	ldr	r3, [r6, #12]
  40a24c:	60c3      	str	r3, [r0, #12]
  40a24e:	2a24      	cmp	r2, #36	; 0x24
  40a250:	d028      	beq.n	40a2a4 <_realloc_r+0x348>
  40a252:	f100 0310 	add.w	r3, r0, #16
  40a256:	f106 0210 	add.w	r2, r6, #16
  40a25a:	e6c4      	b.n	409fe6 <_realloc_r+0x8a>
  40a25c:	f850 3c04 	ldr.w	r3, [r0, #-4]
  40a260:	f023 0303 	bic.w	r3, r3, #3
  40a264:	441c      	add	r4, r3
  40a266:	e70a      	b.n	40a07e <_realloc_r+0x122>
  40a268:	4631      	mov	r1, r6
  40a26a:	4638      	mov	r0, r7
  40a26c:	4674      	mov	r4, lr
  40a26e:	46d0      	mov	r8, sl
  40a270:	f7ff fafe 	bl	409870 <memmove>
  40a274:	463e      	mov	r6, r7
  40a276:	e702      	b.n	40a07e <_realloc_r+0x122>
  40a278:	463a      	mov	r2, r7
  40a27a:	e6f7      	b.n	40a06c <_realloc_r+0x110>
  40a27c:	4631      	mov	r1, r6
  40a27e:	4638      	mov	r0, r7
  40a280:	461c      	mov	r4, r3
  40a282:	46d0      	mov	r8, sl
  40a284:	f7ff faf4 	bl	409870 <memmove>
  40a288:	463e      	mov	r6, r7
  40a28a:	e6f8      	b.n	40a07e <_realloc_r+0x122>
  40a28c:	68b3      	ldr	r3, [r6, #8]
  40a28e:	f8ca 3010 	str.w	r3, [sl, #16]
  40a292:	68f3      	ldr	r3, [r6, #12]
  40a294:	f8ca 3014 	str.w	r3, [sl, #20]
  40a298:	2a24      	cmp	r2, #36	; 0x24
  40a29a:	d01b      	beq.n	40a2d4 <_realloc_r+0x378>
  40a29c:	3610      	adds	r6, #16
  40a29e:	f10a 0318 	add.w	r3, sl, #24
  40a2a2:	e7ae      	b.n	40a202 <_realloc_r+0x2a6>
  40a2a4:	6933      	ldr	r3, [r6, #16]
  40a2a6:	6103      	str	r3, [r0, #16]
  40a2a8:	6973      	ldr	r3, [r6, #20]
  40a2aa:	6143      	str	r3, [r0, #20]
  40a2ac:	f106 0218 	add.w	r2, r6, #24
  40a2b0:	f100 0318 	add.w	r3, r0, #24
  40a2b4:	e697      	b.n	409fe6 <_realloc_r+0x8a>
  40a2b6:	bf00      	nop
  40a2b8:	20400498 	.word	0x20400498
  40a2bc:	68b1      	ldr	r1, [r6, #8]
  40a2be:	f8ca 1010 	str.w	r1, [sl, #16]
  40a2c2:	68f1      	ldr	r1, [r6, #12]
  40a2c4:	f8ca 1014 	str.w	r1, [sl, #20]
  40a2c8:	2a24      	cmp	r2, #36	; 0x24
  40a2ca:	d00f      	beq.n	40a2ec <_realloc_r+0x390>
  40a2cc:	3610      	adds	r6, #16
  40a2ce:	f10a 0218 	add.w	r2, sl, #24
  40a2d2:	e6cb      	b.n	40a06c <_realloc_r+0x110>
  40a2d4:	6933      	ldr	r3, [r6, #16]
  40a2d6:	f8ca 3018 	str.w	r3, [sl, #24]
  40a2da:	6973      	ldr	r3, [r6, #20]
  40a2dc:	f8ca 301c 	str.w	r3, [sl, #28]
  40a2e0:	3618      	adds	r6, #24
  40a2e2:	f10a 0320 	add.w	r3, sl, #32
  40a2e6:	e78c      	b.n	40a202 <_realloc_r+0x2a6>
  40a2e8:	463a      	mov	r2, r7
  40a2ea:	e764      	b.n	40a1b6 <_realloc_r+0x25a>
  40a2ec:	6932      	ldr	r2, [r6, #16]
  40a2ee:	f8ca 2018 	str.w	r2, [sl, #24]
  40a2f2:	6972      	ldr	r2, [r6, #20]
  40a2f4:	f8ca 201c 	str.w	r2, [sl, #28]
  40a2f8:	3618      	adds	r6, #24
  40a2fa:	f10a 0220 	add.w	r2, sl, #32
  40a2fe:	e6b5      	b.n	40a06c <_realloc_r+0x110>
  40a300:	4631      	mov	r1, r6
  40a302:	4638      	mov	r0, r7
  40a304:	9301      	str	r3, [sp, #4]
  40a306:	f7ff fab3 	bl	409870 <memmove>
  40a30a:	9b01      	ldr	r3, [sp, #4]
  40a30c:	e759      	b.n	40a1c2 <_realloc_r+0x266>
  40a30e:	68b1      	ldr	r1, [r6, #8]
  40a310:	f8ca 1010 	str.w	r1, [sl, #16]
  40a314:	68f1      	ldr	r1, [r6, #12]
  40a316:	f8ca 1014 	str.w	r1, [sl, #20]
  40a31a:	2a24      	cmp	r2, #36	; 0x24
  40a31c:	d003      	beq.n	40a326 <_realloc_r+0x3ca>
  40a31e:	3610      	adds	r6, #16
  40a320:	f10a 0218 	add.w	r2, sl, #24
  40a324:	e747      	b.n	40a1b6 <_realloc_r+0x25a>
  40a326:	6932      	ldr	r2, [r6, #16]
  40a328:	f8ca 2018 	str.w	r2, [sl, #24]
  40a32c:	6972      	ldr	r2, [r6, #20]
  40a32e:	f8ca 201c 	str.w	r2, [sl, #28]
  40a332:	3618      	adds	r6, #24
  40a334:	f10a 0220 	add.w	r2, sl, #32
  40a338:	e73d      	b.n	40a1b6 <_realloc_r+0x25a>
  40a33a:	bf00      	nop

0040a33c <_sbrk_r>:
  40a33c:	b538      	push	{r3, r4, r5, lr}
  40a33e:	4c07      	ldr	r4, [pc, #28]	; (40a35c <_sbrk_r+0x20>)
  40a340:	2300      	movs	r3, #0
  40a342:	4605      	mov	r5, r0
  40a344:	4608      	mov	r0, r1
  40a346:	6023      	str	r3, [r4, #0]
  40a348:	f7f9 fc00 	bl	403b4c <_sbrk>
  40a34c:	1c43      	adds	r3, r0, #1
  40a34e:	d000      	beq.n	40a352 <_sbrk_r+0x16>
  40a350:	bd38      	pop	{r3, r4, r5, pc}
  40a352:	6823      	ldr	r3, [r4, #0]
  40a354:	2b00      	cmp	r3, #0
  40a356:	d0fb      	beq.n	40a350 <_sbrk_r+0x14>
  40a358:	602b      	str	r3, [r5, #0]
  40a35a:	bd38      	pop	{r3, r4, r5, pc}
  40a35c:	2040c4bc 	.word	0x2040c4bc

0040a360 <_raise_r>:
  40a360:	291f      	cmp	r1, #31
  40a362:	b538      	push	{r3, r4, r5, lr}
  40a364:	d822      	bhi.n	40a3ac <_raise_r+0x4c>
  40a366:	f8d0 22dc 	ldr.w	r2, [r0, #732]	; 0x2dc
  40a36a:	4605      	mov	r5, r0
  40a36c:	460c      	mov	r4, r1
  40a36e:	b19a      	cbz	r2, 40a398 <_raise_r+0x38>
  40a370:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
  40a374:	b183      	cbz	r3, 40a398 <_raise_r+0x38>
  40a376:	2b01      	cmp	r3, #1
  40a378:	d00c      	beq.n	40a394 <_raise_r+0x34>
  40a37a:	1c59      	adds	r1, r3, #1
  40a37c:	d006      	beq.n	40a38c <_raise_r+0x2c>
  40a37e:	2500      	movs	r5, #0
  40a380:	4620      	mov	r0, r4
  40a382:	f842 5024 	str.w	r5, [r2, r4, lsl #2]
  40a386:	4798      	blx	r3
  40a388:	4628      	mov	r0, r5
  40a38a:	bd38      	pop	{r3, r4, r5, pc}
  40a38c:	2316      	movs	r3, #22
  40a38e:	6003      	str	r3, [r0, #0]
  40a390:	2001      	movs	r0, #1
  40a392:	bd38      	pop	{r3, r4, r5, pc}
  40a394:	2000      	movs	r0, #0
  40a396:	bd38      	pop	{r3, r4, r5, pc}
  40a398:	4628      	mov	r0, r5
  40a39a:	f000 f829 	bl	40a3f0 <_getpid_r>
  40a39e:	4622      	mov	r2, r4
  40a3a0:	4601      	mov	r1, r0
  40a3a2:	4628      	mov	r0, r5
  40a3a4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  40a3a8:	f000 b80e 	b.w	40a3c8 <_kill_r>
  40a3ac:	2316      	movs	r3, #22
  40a3ae:	6003      	str	r3, [r0, #0]
  40a3b0:	f04f 30ff 	mov.w	r0, #4294967295
  40a3b4:	bd38      	pop	{r3, r4, r5, pc}
  40a3b6:	bf00      	nop

0040a3b8 <raise>:
  40a3b8:	4b02      	ldr	r3, [pc, #8]	; (40a3c4 <raise+0xc>)
  40a3ba:	4601      	mov	r1, r0
  40a3bc:	6818      	ldr	r0, [r3, #0]
  40a3be:	f7ff bfcf 	b.w	40a360 <_raise_r>
  40a3c2:	bf00      	nop
  40a3c4:	20400438 	.word	0x20400438

0040a3c8 <_kill_r>:
  40a3c8:	b538      	push	{r3, r4, r5, lr}
  40a3ca:	460b      	mov	r3, r1
  40a3cc:	4c07      	ldr	r4, [pc, #28]	; (40a3ec <_kill_r+0x24>)
  40a3ce:	4605      	mov	r5, r0
  40a3d0:	4611      	mov	r1, r2
  40a3d2:	4618      	mov	r0, r3
  40a3d4:	2300      	movs	r3, #0
  40a3d6:	6023      	str	r3, [r4, #0]
  40a3d8:	f7f9 fc4a 	bl	403c70 <_kill>
  40a3dc:	1c43      	adds	r3, r0, #1
  40a3de:	d000      	beq.n	40a3e2 <_kill_r+0x1a>
  40a3e0:	bd38      	pop	{r3, r4, r5, pc}
  40a3e2:	6823      	ldr	r3, [r4, #0]
  40a3e4:	2b00      	cmp	r3, #0
  40a3e6:	d0fb      	beq.n	40a3e0 <_kill_r+0x18>
  40a3e8:	602b      	str	r3, [r5, #0]
  40a3ea:	bd38      	pop	{r3, r4, r5, pc}
  40a3ec:	2040c4bc 	.word	0x2040c4bc

0040a3f0 <_getpid_r>:
  40a3f0:	f7f9 bc4a 	b.w	403c88 <_getpid>

0040a3f4 <__sread>:
  40a3f4:	b510      	push	{r4, lr}
  40a3f6:	460c      	mov	r4, r1
  40a3f8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  40a3fc:	f000 f9f4 	bl	40a7e8 <_read_r>
  40a400:	2800      	cmp	r0, #0
  40a402:	db03      	blt.n	40a40c <__sread+0x18>
  40a404:	6d23      	ldr	r3, [r4, #80]	; 0x50
  40a406:	4403      	add	r3, r0
  40a408:	6523      	str	r3, [r4, #80]	; 0x50
  40a40a:	bd10      	pop	{r4, pc}
  40a40c:	89a3      	ldrh	r3, [r4, #12]
  40a40e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  40a412:	81a3      	strh	r3, [r4, #12]
  40a414:	bd10      	pop	{r4, pc}
  40a416:	bf00      	nop

0040a418 <__swrite>:
  40a418:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40a41c:	4616      	mov	r6, r2
  40a41e:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
  40a422:	461f      	mov	r7, r3
  40a424:	05d3      	lsls	r3, r2, #23
  40a426:	460c      	mov	r4, r1
  40a428:	4605      	mov	r5, r0
  40a42a:	d507      	bpl.n	40a43c <__swrite+0x24>
  40a42c:	2200      	movs	r2, #0
  40a42e:	2302      	movs	r3, #2
  40a430:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  40a434:	f000 f9c2 	bl	40a7bc <_lseek_r>
  40a438:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
  40a43c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
  40a440:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
  40a444:	81a2      	strh	r2, [r4, #12]
  40a446:	463b      	mov	r3, r7
  40a448:	4632      	mov	r2, r6
  40a44a:	4628      	mov	r0, r5
  40a44c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  40a450:	f000 b8a2 	b.w	40a598 <_write_r>

0040a454 <__sseek>:
  40a454:	b510      	push	{r4, lr}
  40a456:	460c      	mov	r4, r1
  40a458:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  40a45c:	f000 f9ae 	bl	40a7bc <_lseek_r>
  40a460:	89a3      	ldrh	r3, [r4, #12]
  40a462:	1c42      	adds	r2, r0, #1
  40a464:	bf0e      	itee	eq
  40a466:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
  40a46a:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
  40a46e:	6520      	strne	r0, [r4, #80]	; 0x50
  40a470:	81a3      	strh	r3, [r4, #12]
  40a472:	bd10      	pop	{r4, pc}

0040a474 <__sclose>:
  40a474:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  40a478:	f000 b926 	b.w	40a6c8 <_close_r>

0040a47c <__swbuf_r>:
  40a47c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40a47e:	460e      	mov	r6, r1
  40a480:	4614      	mov	r4, r2
  40a482:	4607      	mov	r7, r0
  40a484:	b110      	cbz	r0, 40a48c <__swbuf_r+0x10>
  40a486:	6b83      	ldr	r3, [r0, #56]	; 0x38
  40a488:	2b00      	cmp	r3, #0
  40a48a:	d04a      	beq.n	40a522 <__swbuf_r+0xa6>
  40a48c:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
  40a490:	69a3      	ldr	r3, [r4, #24]
  40a492:	60a3      	str	r3, [r4, #8]
  40a494:	b291      	uxth	r1, r2
  40a496:	0708      	lsls	r0, r1, #28
  40a498:	d538      	bpl.n	40a50c <__swbuf_r+0x90>
  40a49a:	6923      	ldr	r3, [r4, #16]
  40a49c:	2b00      	cmp	r3, #0
  40a49e:	d035      	beq.n	40a50c <__swbuf_r+0x90>
  40a4a0:	0489      	lsls	r1, r1, #18
  40a4a2:	b2f5      	uxtb	r5, r6
  40a4a4:	d515      	bpl.n	40a4d2 <__swbuf_r+0x56>
  40a4a6:	6822      	ldr	r2, [r4, #0]
  40a4a8:	6961      	ldr	r1, [r4, #20]
  40a4aa:	1ad3      	subs	r3, r2, r3
  40a4ac:	428b      	cmp	r3, r1
  40a4ae:	da1c      	bge.n	40a4ea <__swbuf_r+0x6e>
  40a4b0:	3301      	adds	r3, #1
  40a4b2:	68a1      	ldr	r1, [r4, #8]
  40a4b4:	1c50      	adds	r0, r2, #1
  40a4b6:	3901      	subs	r1, #1
  40a4b8:	60a1      	str	r1, [r4, #8]
  40a4ba:	6020      	str	r0, [r4, #0]
  40a4bc:	7016      	strb	r6, [r2, #0]
  40a4be:	6962      	ldr	r2, [r4, #20]
  40a4c0:	429a      	cmp	r2, r3
  40a4c2:	d01a      	beq.n	40a4fa <__swbuf_r+0x7e>
  40a4c4:	89a3      	ldrh	r3, [r4, #12]
  40a4c6:	07db      	lsls	r3, r3, #31
  40a4c8:	d501      	bpl.n	40a4ce <__swbuf_r+0x52>
  40a4ca:	2d0a      	cmp	r5, #10
  40a4cc:	d015      	beq.n	40a4fa <__swbuf_r+0x7e>
  40a4ce:	4628      	mov	r0, r5
  40a4d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40a4d2:	6e61      	ldr	r1, [r4, #100]	; 0x64
  40a4d4:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
  40a4d8:	f421 5100 	bic.w	r1, r1, #8192	; 0x2000
  40a4dc:	81a2      	strh	r2, [r4, #12]
  40a4de:	6822      	ldr	r2, [r4, #0]
  40a4e0:	6661      	str	r1, [r4, #100]	; 0x64
  40a4e2:	6961      	ldr	r1, [r4, #20]
  40a4e4:	1ad3      	subs	r3, r2, r3
  40a4e6:	428b      	cmp	r3, r1
  40a4e8:	dbe2      	blt.n	40a4b0 <__swbuf_r+0x34>
  40a4ea:	4621      	mov	r1, r4
  40a4ec:	4638      	mov	r0, r7
  40a4ee:	f7fe fa3b 	bl	408968 <_fflush_r>
  40a4f2:	b940      	cbnz	r0, 40a506 <__swbuf_r+0x8a>
  40a4f4:	6822      	ldr	r2, [r4, #0]
  40a4f6:	2301      	movs	r3, #1
  40a4f8:	e7db      	b.n	40a4b2 <__swbuf_r+0x36>
  40a4fa:	4621      	mov	r1, r4
  40a4fc:	4638      	mov	r0, r7
  40a4fe:	f7fe fa33 	bl	408968 <_fflush_r>
  40a502:	2800      	cmp	r0, #0
  40a504:	d0e3      	beq.n	40a4ce <__swbuf_r+0x52>
  40a506:	f04f 30ff 	mov.w	r0, #4294967295
  40a50a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40a50c:	4621      	mov	r1, r4
  40a50e:	4638      	mov	r0, r7
  40a510:	f7fd f94a 	bl	4077a8 <__swsetup_r>
  40a514:	2800      	cmp	r0, #0
  40a516:	d1f6      	bne.n	40a506 <__swbuf_r+0x8a>
  40a518:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
  40a51c:	6923      	ldr	r3, [r4, #16]
  40a51e:	b291      	uxth	r1, r2
  40a520:	e7be      	b.n	40a4a0 <__swbuf_r+0x24>
  40a522:	f7fe fab5 	bl	408a90 <__sinit>
  40a526:	e7b1      	b.n	40a48c <__swbuf_r+0x10>

0040a528 <_wcrtomb_r>:
  40a528:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40a52c:	4605      	mov	r5, r0
  40a52e:	b086      	sub	sp, #24
  40a530:	461e      	mov	r6, r3
  40a532:	460c      	mov	r4, r1
  40a534:	b1a1      	cbz	r1, 40a560 <_wcrtomb_r+0x38>
  40a536:	4b10      	ldr	r3, [pc, #64]	; (40a578 <_wcrtomb_r+0x50>)
  40a538:	4617      	mov	r7, r2
  40a53a:	f8d3 8000 	ldr.w	r8, [r3]
  40a53e:	f7fe fe05 	bl	40914c <__locale_charset>
  40a542:	9600      	str	r6, [sp, #0]
  40a544:	4603      	mov	r3, r0
  40a546:	463a      	mov	r2, r7
  40a548:	4621      	mov	r1, r4
  40a54a:	4628      	mov	r0, r5
  40a54c:	47c0      	blx	r8
  40a54e:	1c43      	adds	r3, r0, #1
  40a550:	d103      	bne.n	40a55a <_wcrtomb_r+0x32>
  40a552:	2200      	movs	r2, #0
  40a554:	238a      	movs	r3, #138	; 0x8a
  40a556:	6032      	str	r2, [r6, #0]
  40a558:	602b      	str	r3, [r5, #0]
  40a55a:	b006      	add	sp, #24
  40a55c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40a560:	4b05      	ldr	r3, [pc, #20]	; (40a578 <_wcrtomb_r+0x50>)
  40a562:	681f      	ldr	r7, [r3, #0]
  40a564:	f7fe fdf2 	bl	40914c <__locale_charset>
  40a568:	9600      	str	r6, [sp, #0]
  40a56a:	4603      	mov	r3, r0
  40a56c:	4622      	mov	r2, r4
  40a56e:	a903      	add	r1, sp, #12
  40a570:	4628      	mov	r0, r5
  40a572:	47b8      	blx	r7
  40a574:	e7eb      	b.n	40a54e <_wcrtomb_r+0x26>
  40a576:	bf00      	nop
  40a578:	204008a8 	.word	0x204008a8

0040a57c <__ascii_wctomb>:
  40a57c:	b121      	cbz	r1, 40a588 <__ascii_wctomb+0xc>
  40a57e:	2aff      	cmp	r2, #255	; 0xff
  40a580:	d804      	bhi.n	40a58c <__ascii_wctomb+0x10>
  40a582:	700a      	strb	r2, [r1, #0]
  40a584:	2001      	movs	r0, #1
  40a586:	4770      	bx	lr
  40a588:	4608      	mov	r0, r1
  40a58a:	4770      	bx	lr
  40a58c:	238a      	movs	r3, #138	; 0x8a
  40a58e:	6003      	str	r3, [r0, #0]
  40a590:	f04f 30ff 	mov.w	r0, #4294967295
  40a594:	4770      	bx	lr
  40a596:	bf00      	nop

0040a598 <_write_r>:
  40a598:	b570      	push	{r4, r5, r6, lr}
  40a59a:	460d      	mov	r5, r1
  40a59c:	4c08      	ldr	r4, [pc, #32]	; (40a5c0 <_write_r+0x28>)
  40a59e:	4611      	mov	r1, r2
  40a5a0:	4606      	mov	r6, r0
  40a5a2:	461a      	mov	r2, r3
  40a5a4:	4628      	mov	r0, r5
  40a5a6:	2300      	movs	r3, #0
  40a5a8:	6023      	str	r3, [r4, #0]
  40a5aa:	f7f9 fb33 	bl	403c14 <_write>
  40a5ae:	1c43      	adds	r3, r0, #1
  40a5b0:	d000      	beq.n	40a5b4 <_write_r+0x1c>
  40a5b2:	bd70      	pop	{r4, r5, r6, pc}
  40a5b4:	6823      	ldr	r3, [r4, #0]
  40a5b6:	2b00      	cmp	r3, #0
  40a5b8:	d0fb      	beq.n	40a5b2 <_write_r+0x1a>
  40a5ba:	6033      	str	r3, [r6, #0]
  40a5bc:	bd70      	pop	{r4, r5, r6, pc}
  40a5be:	bf00      	nop
  40a5c0:	2040c4bc 	.word	0x2040c4bc

0040a5c4 <__register_exitproc>:
  40a5c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  40a5c8:	4c25      	ldr	r4, [pc, #148]	; (40a660 <__register_exitproc+0x9c>)
  40a5ca:	6825      	ldr	r5, [r4, #0]
  40a5cc:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
  40a5d0:	4606      	mov	r6, r0
  40a5d2:	4688      	mov	r8, r1
  40a5d4:	4692      	mov	sl, r2
  40a5d6:	4699      	mov	r9, r3
  40a5d8:	b3c4      	cbz	r4, 40a64c <__register_exitproc+0x88>
  40a5da:	6860      	ldr	r0, [r4, #4]
  40a5dc:	281f      	cmp	r0, #31
  40a5de:	dc17      	bgt.n	40a610 <__register_exitproc+0x4c>
  40a5e0:	1c43      	adds	r3, r0, #1
  40a5e2:	b176      	cbz	r6, 40a602 <__register_exitproc+0x3e>
  40a5e4:	eb04 0580 	add.w	r5, r4, r0, lsl #2
  40a5e8:	2201      	movs	r2, #1
  40a5ea:	f8c5 a088 	str.w	sl, [r5, #136]	; 0x88
  40a5ee:	f8d4 1188 	ldr.w	r1, [r4, #392]	; 0x188
  40a5f2:	4082      	lsls	r2, r0
  40a5f4:	4311      	orrs	r1, r2
  40a5f6:	2e02      	cmp	r6, #2
  40a5f8:	f8c4 1188 	str.w	r1, [r4, #392]	; 0x188
  40a5fc:	f8c5 9108 	str.w	r9, [r5, #264]	; 0x108
  40a600:	d01e      	beq.n	40a640 <__register_exitproc+0x7c>
  40a602:	3002      	adds	r0, #2
  40a604:	6063      	str	r3, [r4, #4]
  40a606:	f844 8020 	str.w	r8, [r4, r0, lsl #2]
  40a60a:	2000      	movs	r0, #0
  40a60c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40a610:	4b14      	ldr	r3, [pc, #80]	; (40a664 <__register_exitproc+0xa0>)
  40a612:	b303      	cbz	r3, 40a656 <__register_exitproc+0x92>
  40a614:	f44f 70c8 	mov.w	r0, #400	; 0x190
  40a618:	f7fe fe1a 	bl	409250 <malloc>
  40a61c:	4604      	mov	r4, r0
  40a61e:	b1d0      	cbz	r0, 40a656 <__register_exitproc+0x92>
  40a620:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
  40a624:	2700      	movs	r7, #0
  40a626:	e880 0088 	stmia.w	r0, {r3, r7}
  40a62a:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
  40a62e:	4638      	mov	r0, r7
  40a630:	2301      	movs	r3, #1
  40a632:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
  40a636:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
  40a63a:	2e00      	cmp	r6, #0
  40a63c:	d0e1      	beq.n	40a602 <__register_exitproc+0x3e>
  40a63e:	e7d1      	b.n	40a5e4 <__register_exitproc+0x20>
  40a640:	f8d4 118c 	ldr.w	r1, [r4, #396]	; 0x18c
  40a644:	430a      	orrs	r2, r1
  40a646:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
  40a64a:	e7da      	b.n	40a602 <__register_exitproc+0x3e>
  40a64c:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
  40a650:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
  40a654:	e7c1      	b.n	40a5da <__register_exitproc+0x16>
  40a656:	f04f 30ff 	mov.w	r0, #4294967295
  40a65a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40a65e:	bf00      	nop
  40a660:	0040add4 	.word	0x0040add4
  40a664:	00409251 	.word	0x00409251

0040a668 <_calloc_r>:
  40a668:	b510      	push	{r4, lr}
  40a66a:	fb02 f101 	mul.w	r1, r2, r1
  40a66e:	f7fe fdf7 	bl	409260 <_malloc_r>
  40a672:	4604      	mov	r4, r0
  40a674:	b1d8      	cbz	r0, 40a6ae <_calloc_r+0x46>
  40a676:	f850 2c04 	ldr.w	r2, [r0, #-4]
  40a67a:	f022 0203 	bic.w	r2, r2, #3
  40a67e:	3a04      	subs	r2, #4
  40a680:	2a24      	cmp	r2, #36	; 0x24
  40a682:	d818      	bhi.n	40a6b6 <_calloc_r+0x4e>
  40a684:	2a13      	cmp	r2, #19
  40a686:	d914      	bls.n	40a6b2 <_calloc_r+0x4a>
  40a688:	2300      	movs	r3, #0
  40a68a:	2a1b      	cmp	r2, #27
  40a68c:	6003      	str	r3, [r0, #0]
  40a68e:	6043      	str	r3, [r0, #4]
  40a690:	d916      	bls.n	40a6c0 <_calloc_r+0x58>
  40a692:	2a24      	cmp	r2, #36	; 0x24
  40a694:	6083      	str	r3, [r0, #8]
  40a696:	60c3      	str	r3, [r0, #12]
  40a698:	bf11      	iteee	ne
  40a69a:	f100 0210 	addne.w	r2, r0, #16
  40a69e:	6103      	streq	r3, [r0, #16]
  40a6a0:	6143      	streq	r3, [r0, #20]
  40a6a2:	f100 0218 	addeq.w	r2, r0, #24
  40a6a6:	2300      	movs	r3, #0
  40a6a8:	6013      	str	r3, [r2, #0]
  40a6aa:	6053      	str	r3, [r2, #4]
  40a6ac:	6093      	str	r3, [r2, #8]
  40a6ae:	4620      	mov	r0, r4
  40a6b0:	bd10      	pop	{r4, pc}
  40a6b2:	4602      	mov	r2, r0
  40a6b4:	e7f7      	b.n	40a6a6 <_calloc_r+0x3e>
  40a6b6:	2100      	movs	r1, #0
  40a6b8:	f7fa fbc2 	bl	404e40 <memset>
  40a6bc:	4620      	mov	r0, r4
  40a6be:	bd10      	pop	{r4, pc}
  40a6c0:	f100 0208 	add.w	r2, r0, #8
  40a6c4:	e7ef      	b.n	40a6a6 <_calloc_r+0x3e>
  40a6c6:	bf00      	nop

0040a6c8 <_close_r>:
  40a6c8:	b538      	push	{r3, r4, r5, lr}
  40a6ca:	4c07      	ldr	r4, [pc, #28]	; (40a6e8 <_close_r+0x20>)
  40a6cc:	2300      	movs	r3, #0
  40a6ce:	4605      	mov	r5, r0
  40a6d0:	4608      	mov	r0, r1
  40a6d2:	6023      	str	r3, [r4, #0]
  40a6d4:	f7f9 fa5a 	bl	403b8c <_close>
  40a6d8:	1c43      	adds	r3, r0, #1
  40a6da:	d000      	beq.n	40a6de <_close_r+0x16>
  40a6dc:	bd38      	pop	{r3, r4, r5, pc}
  40a6de:	6823      	ldr	r3, [r4, #0]
  40a6e0:	2b00      	cmp	r3, #0
  40a6e2:	d0fb      	beq.n	40a6dc <_close_r+0x14>
  40a6e4:	602b      	str	r3, [r5, #0]
  40a6e6:	bd38      	pop	{r3, r4, r5, pc}
  40a6e8:	2040c4bc 	.word	0x2040c4bc

0040a6ec <_fclose_r>:
  40a6ec:	2900      	cmp	r1, #0
  40a6ee:	d03d      	beq.n	40a76c <_fclose_r+0x80>
  40a6f0:	b570      	push	{r4, r5, r6, lr}
  40a6f2:	4605      	mov	r5, r0
  40a6f4:	460c      	mov	r4, r1
  40a6f6:	b108      	cbz	r0, 40a6fc <_fclose_r+0x10>
  40a6f8:	6b83      	ldr	r3, [r0, #56]	; 0x38
  40a6fa:	b37b      	cbz	r3, 40a75c <_fclose_r+0x70>
  40a6fc:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  40a700:	b90b      	cbnz	r3, 40a706 <_fclose_r+0x1a>
  40a702:	2000      	movs	r0, #0
  40a704:	bd70      	pop	{r4, r5, r6, pc}
  40a706:	4621      	mov	r1, r4
  40a708:	4628      	mov	r0, r5
  40a70a:	f7fe f889 	bl	408820 <__sflush_r>
  40a70e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  40a710:	4606      	mov	r6, r0
  40a712:	b133      	cbz	r3, 40a722 <_fclose_r+0x36>
  40a714:	69e1      	ldr	r1, [r4, #28]
  40a716:	4628      	mov	r0, r5
  40a718:	4798      	blx	r3
  40a71a:	2800      	cmp	r0, #0
  40a71c:	bfb8      	it	lt
  40a71e:	f04f 36ff 	movlt.w	r6, #4294967295
  40a722:	89a3      	ldrh	r3, [r4, #12]
  40a724:	061b      	lsls	r3, r3, #24
  40a726:	d41c      	bmi.n	40a762 <_fclose_r+0x76>
  40a728:	6b21      	ldr	r1, [r4, #48]	; 0x30
  40a72a:	b141      	cbz	r1, 40a73e <_fclose_r+0x52>
  40a72c:	f104 0340 	add.w	r3, r4, #64	; 0x40
  40a730:	4299      	cmp	r1, r3
  40a732:	d002      	beq.n	40a73a <_fclose_r+0x4e>
  40a734:	4628      	mov	r0, r5
  40a736:	f7fe fa75 	bl	408c24 <_free_r>
  40a73a:	2300      	movs	r3, #0
  40a73c:	6323      	str	r3, [r4, #48]	; 0x30
  40a73e:	6c61      	ldr	r1, [r4, #68]	; 0x44
  40a740:	b121      	cbz	r1, 40a74c <_fclose_r+0x60>
  40a742:	4628      	mov	r0, r5
  40a744:	f7fe fa6e 	bl	408c24 <_free_r>
  40a748:	2300      	movs	r3, #0
  40a74a:	6463      	str	r3, [r4, #68]	; 0x44
  40a74c:	f7fe f9a6 	bl	408a9c <__sfp_lock_acquire>
  40a750:	2300      	movs	r3, #0
  40a752:	81a3      	strh	r3, [r4, #12]
  40a754:	f7fe f9a4 	bl	408aa0 <__sfp_lock_release>
  40a758:	4630      	mov	r0, r6
  40a75a:	bd70      	pop	{r4, r5, r6, pc}
  40a75c:	f7fe f998 	bl	408a90 <__sinit>
  40a760:	e7cc      	b.n	40a6fc <_fclose_r+0x10>
  40a762:	6921      	ldr	r1, [r4, #16]
  40a764:	4628      	mov	r0, r5
  40a766:	f7fe fa5d 	bl	408c24 <_free_r>
  40a76a:	e7dd      	b.n	40a728 <_fclose_r+0x3c>
  40a76c:	2000      	movs	r0, #0
  40a76e:	4770      	bx	lr

0040a770 <_fstat_r>:
  40a770:	b538      	push	{r3, r4, r5, lr}
  40a772:	460b      	mov	r3, r1
  40a774:	4c07      	ldr	r4, [pc, #28]	; (40a794 <_fstat_r+0x24>)
  40a776:	4605      	mov	r5, r0
  40a778:	4611      	mov	r1, r2
  40a77a:	4618      	mov	r0, r3
  40a77c:	2300      	movs	r3, #0
  40a77e:	6023      	str	r3, [r4, #0]
  40a780:	f7f9 fa10 	bl	403ba4 <_fstat>
  40a784:	1c43      	adds	r3, r0, #1
  40a786:	d000      	beq.n	40a78a <_fstat_r+0x1a>
  40a788:	bd38      	pop	{r3, r4, r5, pc}
  40a78a:	6823      	ldr	r3, [r4, #0]
  40a78c:	2b00      	cmp	r3, #0
  40a78e:	d0fb      	beq.n	40a788 <_fstat_r+0x18>
  40a790:	602b      	str	r3, [r5, #0]
  40a792:	bd38      	pop	{r3, r4, r5, pc}
  40a794:	2040c4bc 	.word	0x2040c4bc

0040a798 <_isatty_r>:
  40a798:	b538      	push	{r3, r4, r5, lr}
  40a79a:	4c07      	ldr	r4, [pc, #28]	; (40a7b8 <_isatty_r+0x20>)
  40a79c:	2300      	movs	r3, #0
  40a79e:	4605      	mov	r5, r0
  40a7a0:	4608      	mov	r0, r1
  40a7a2:	6023      	str	r3, [r4, #0]
  40a7a4:	f7f9 fa0e 	bl	403bc4 <_isatty>
  40a7a8:	1c43      	adds	r3, r0, #1
  40a7aa:	d000      	beq.n	40a7ae <_isatty_r+0x16>
  40a7ac:	bd38      	pop	{r3, r4, r5, pc}
  40a7ae:	6823      	ldr	r3, [r4, #0]
  40a7b0:	2b00      	cmp	r3, #0
  40a7b2:	d0fb      	beq.n	40a7ac <_isatty_r+0x14>
  40a7b4:	602b      	str	r3, [r5, #0]
  40a7b6:	bd38      	pop	{r3, r4, r5, pc}
  40a7b8:	2040c4bc 	.word	0x2040c4bc

0040a7bc <_lseek_r>:
  40a7bc:	b570      	push	{r4, r5, r6, lr}
  40a7be:	460d      	mov	r5, r1
  40a7c0:	4c08      	ldr	r4, [pc, #32]	; (40a7e4 <_lseek_r+0x28>)
  40a7c2:	4611      	mov	r1, r2
  40a7c4:	4606      	mov	r6, r0
  40a7c6:	461a      	mov	r2, r3
  40a7c8:	4628      	mov	r0, r5
  40a7ca:	2300      	movs	r3, #0
  40a7cc:	6023      	str	r3, [r4, #0]
  40a7ce:	f7f9 fa05 	bl	403bdc <_lseek>
  40a7d2:	1c43      	adds	r3, r0, #1
  40a7d4:	d000      	beq.n	40a7d8 <_lseek_r+0x1c>
  40a7d6:	bd70      	pop	{r4, r5, r6, pc}
  40a7d8:	6823      	ldr	r3, [r4, #0]
  40a7da:	2b00      	cmp	r3, #0
  40a7dc:	d0fb      	beq.n	40a7d6 <_lseek_r+0x1a>
  40a7de:	6033      	str	r3, [r6, #0]
  40a7e0:	bd70      	pop	{r4, r5, r6, pc}
  40a7e2:	bf00      	nop
  40a7e4:	2040c4bc 	.word	0x2040c4bc

0040a7e8 <_read_r>:
  40a7e8:	b570      	push	{r4, r5, r6, lr}
  40a7ea:	460d      	mov	r5, r1
  40a7ec:	4c08      	ldr	r4, [pc, #32]	; (40a810 <_read_r+0x28>)
  40a7ee:	4611      	mov	r1, r2
  40a7f0:	4606      	mov	r6, r0
  40a7f2:	461a      	mov	r2, r3
  40a7f4:	4628      	mov	r0, r5
  40a7f6:	2300      	movs	r3, #0
  40a7f8:	6023      	str	r3, [r4, #0]
  40a7fa:	f7f9 f9fd 	bl	403bf8 <_read>
  40a7fe:	1c43      	adds	r3, r0, #1
  40a800:	d000      	beq.n	40a804 <_read_r+0x1c>
  40a802:	bd70      	pop	{r4, r5, r6, pc}
  40a804:	6823      	ldr	r3, [r4, #0]
  40a806:	2b00      	cmp	r3, #0
  40a808:	d0fb      	beq.n	40a802 <_read_r+0x1a>
  40a80a:	6033      	str	r3, [r6, #0]
  40a80c:	bd70      	pop	{r4, r5, r6, pc}
  40a80e:	bf00      	nop
  40a810:	2040c4bc 	.word	0x2040c4bc

0040a814 <__aeabi_dcmpun>:
  40a814:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  40a818:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  40a81c:	d102      	bne.n	40a824 <__aeabi_dcmpun+0x10>
  40a81e:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
  40a822:	d10a      	bne.n	40a83a <__aeabi_dcmpun+0x26>
  40a824:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  40a828:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  40a82c:	d102      	bne.n	40a834 <__aeabi_dcmpun+0x20>
  40a82e:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
  40a832:	d102      	bne.n	40a83a <__aeabi_dcmpun+0x26>
  40a834:	f04f 0000 	mov.w	r0, #0
  40a838:	4770      	bx	lr
  40a83a:	f04f 0001 	mov.w	r0, #1
  40a83e:	4770      	bx	lr

0040a840 <__aeabi_d2iz>:
  40a840:	ea4f 0241 	mov.w	r2, r1, lsl #1
  40a844:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
  40a848:	d215      	bcs.n	40a876 <__aeabi_d2iz+0x36>
  40a84a:	d511      	bpl.n	40a870 <__aeabi_d2iz+0x30>
  40a84c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
  40a850:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
  40a854:	d912      	bls.n	40a87c <__aeabi_d2iz+0x3c>
  40a856:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  40a85a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  40a85e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
  40a862:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  40a866:	fa23 f002 	lsr.w	r0, r3, r2
  40a86a:	bf18      	it	ne
  40a86c:	4240      	negne	r0, r0
  40a86e:	4770      	bx	lr
  40a870:	f04f 0000 	mov.w	r0, #0
  40a874:	4770      	bx	lr
  40a876:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
  40a87a:	d105      	bne.n	40a888 <__aeabi_d2iz+0x48>
  40a87c:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
  40a880:	bf08      	it	eq
  40a882:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
  40a886:	4770      	bx	lr
  40a888:	f04f 0000 	mov.w	r0, #0
  40a88c:	4770      	bx	lr
  40a88e:	bf00      	nop

0040a890 <__aeabi_uldivmod>:
  40a890:	b953      	cbnz	r3, 40a8a8 <__aeabi_uldivmod+0x18>
  40a892:	b94a      	cbnz	r2, 40a8a8 <__aeabi_uldivmod+0x18>
  40a894:	2900      	cmp	r1, #0
  40a896:	bf08      	it	eq
  40a898:	2800      	cmpeq	r0, #0
  40a89a:	bf1c      	itt	ne
  40a89c:	f04f 31ff 	movne.w	r1, #4294967295
  40a8a0:	f04f 30ff 	movne.w	r0, #4294967295
  40a8a4:	f000 b97e 	b.w	40aba4 <__aeabi_idiv0>
  40a8a8:	f1ad 0c08 	sub.w	ip, sp, #8
  40a8ac:	e96d ce04 	strd	ip, lr, [sp, #-16]!
  40a8b0:	f000 f806 	bl	40a8c0 <__udivmoddi4>
  40a8b4:	f8dd e004 	ldr.w	lr, [sp, #4]
  40a8b8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  40a8bc:	b004      	add	sp, #16
  40a8be:	4770      	bx	lr

0040a8c0 <__udivmoddi4>:
  40a8c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  40a8c4:	468c      	mov	ip, r1
  40a8c6:	460e      	mov	r6, r1
  40a8c8:	4604      	mov	r4, r0
  40a8ca:	9d08      	ldr	r5, [sp, #32]
  40a8cc:	2b00      	cmp	r3, #0
  40a8ce:	d150      	bne.n	40a972 <__udivmoddi4+0xb2>
  40a8d0:	428a      	cmp	r2, r1
  40a8d2:	4617      	mov	r7, r2
  40a8d4:	d96c      	bls.n	40a9b0 <__udivmoddi4+0xf0>
  40a8d6:	fab2 fe82 	clz	lr, r2
  40a8da:	f1be 0f00 	cmp.w	lr, #0
  40a8de:	d00b      	beq.n	40a8f8 <__udivmoddi4+0x38>
  40a8e0:	f1ce 0420 	rsb	r4, lr, #32
  40a8e4:	fa20 f404 	lsr.w	r4, r0, r4
  40a8e8:	fa01 f60e 	lsl.w	r6, r1, lr
  40a8ec:	ea44 0c06 	orr.w	ip, r4, r6
  40a8f0:	fa02 f70e 	lsl.w	r7, r2, lr
  40a8f4:	fa00 f40e 	lsl.w	r4, r0, lr
  40a8f8:	ea4f 4917 	mov.w	r9, r7, lsr #16
  40a8fc:	0c22      	lsrs	r2, r4, #16
  40a8fe:	fbbc f0f9 	udiv	r0, ip, r9
  40a902:	fa1f f887 	uxth.w	r8, r7
  40a906:	fb09 c610 	mls	r6, r9, r0, ip
  40a90a:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
  40a90e:	fb00 f308 	mul.w	r3, r0, r8
  40a912:	42b3      	cmp	r3, r6
  40a914:	d909      	bls.n	40a92a <__udivmoddi4+0x6a>
  40a916:	19f6      	adds	r6, r6, r7
  40a918:	f100 32ff 	add.w	r2, r0, #4294967295
  40a91c:	f080 8122 	bcs.w	40ab64 <__udivmoddi4+0x2a4>
  40a920:	42b3      	cmp	r3, r6
  40a922:	f240 811f 	bls.w	40ab64 <__udivmoddi4+0x2a4>
  40a926:	3802      	subs	r0, #2
  40a928:	443e      	add	r6, r7
  40a92a:	1af6      	subs	r6, r6, r3
  40a92c:	b2a2      	uxth	r2, r4
  40a92e:	fbb6 f3f9 	udiv	r3, r6, r9
  40a932:	fb09 6613 	mls	r6, r9, r3, r6
  40a936:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
  40a93a:	fb03 f808 	mul.w	r8, r3, r8
  40a93e:	45a0      	cmp	r8, r4
  40a940:	d909      	bls.n	40a956 <__udivmoddi4+0x96>
  40a942:	19e4      	adds	r4, r4, r7
  40a944:	f103 32ff 	add.w	r2, r3, #4294967295
  40a948:	f080 810a 	bcs.w	40ab60 <__udivmoddi4+0x2a0>
  40a94c:	45a0      	cmp	r8, r4
  40a94e:	f240 8107 	bls.w	40ab60 <__udivmoddi4+0x2a0>
  40a952:	3b02      	subs	r3, #2
  40a954:	443c      	add	r4, r7
  40a956:	ebc8 0404 	rsb	r4, r8, r4
  40a95a:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
  40a95e:	2100      	movs	r1, #0
  40a960:	2d00      	cmp	r5, #0
  40a962:	d062      	beq.n	40aa2a <__udivmoddi4+0x16a>
  40a964:	fa24 f40e 	lsr.w	r4, r4, lr
  40a968:	2300      	movs	r3, #0
  40a96a:	602c      	str	r4, [r5, #0]
  40a96c:	606b      	str	r3, [r5, #4]
  40a96e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40a972:	428b      	cmp	r3, r1
  40a974:	d907      	bls.n	40a986 <__udivmoddi4+0xc6>
  40a976:	2d00      	cmp	r5, #0
  40a978:	d055      	beq.n	40aa26 <__udivmoddi4+0x166>
  40a97a:	2100      	movs	r1, #0
  40a97c:	e885 0041 	stmia.w	r5, {r0, r6}
  40a980:	4608      	mov	r0, r1
  40a982:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40a986:	fab3 f183 	clz	r1, r3
  40a98a:	2900      	cmp	r1, #0
  40a98c:	f040 8090 	bne.w	40aab0 <__udivmoddi4+0x1f0>
  40a990:	42b3      	cmp	r3, r6
  40a992:	d302      	bcc.n	40a99a <__udivmoddi4+0xda>
  40a994:	4282      	cmp	r2, r0
  40a996:	f200 80f8 	bhi.w	40ab8a <__udivmoddi4+0x2ca>
  40a99a:	1a84      	subs	r4, r0, r2
  40a99c:	eb66 0603 	sbc.w	r6, r6, r3
  40a9a0:	2001      	movs	r0, #1
  40a9a2:	46b4      	mov	ip, r6
  40a9a4:	2d00      	cmp	r5, #0
  40a9a6:	d040      	beq.n	40aa2a <__udivmoddi4+0x16a>
  40a9a8:	e885 1010 	stmia.w	r5, {r4, ip}
  40a9ac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40a9b0:	b912      	cbnz	r2, 40a9b8 <__udivmoddi4+0xf8>
  40a9b2:	2701      	movs	r7, #1
  40a9b4:	fbb7 f7f2 	udiv	r7, r7, r2
  40a9b8:	fab7 fe87 	clz	lr, r7
  40a9bc:	f1be 0f00 	cmp.w	lr, #0
  40a9c0:	d135      	bne.n	40aa2e <__udivmoddi4+0x16e>
  40a9c2:	1bf3      	subs	r3, r6, r7
  40a9c4:	ea4f 4817 	mov.w	r8, r7, lsr #16
  40a9c8:	fa1f fc87 	uxth.w	ip, r7
  40a9cc:	2101      	movs	r1, #1
  40a9ce:	fbb3 f0f8 	udiv	r0, r3, r8
  40a9d2:	0c22      	lsrs	r2, r4, #16
  40a9d4:	fb08 3610 	mls	r6, r8, r0, r3
  40a9d8:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
  40a9dc:	fb0c f300 	mul.w	r3, ip, r0
  40a9e0:	42b3      	cmp	r3, r6
  40a9e2:	d907      	bls.n	40a9f4 <__udivmoddi4+0x134>
  40a9e4:	19f6      	adds	r6, r6, r7
  40a9e6:	f100 32ff 	add.w	r2, r0, #4294967295
  40a9ea:	d202      	bcs.n	40a9f2 <__udivmoddi4+0x132>
  40a9ec:	42b3      	cmp	r3, r6
  40a9ee:	f200 80ce 	bhi.w	40ab8e <__udivmoddi4+0x2ce>
  40a9f2:	4610      	mov	r0, r2
  40a9f4:	1af6      	subs	r6, r6, r3
  40a9f6:	b2a2      	uxth	r2, r4
  40a9f8:	fbb6 f3f8 	udiv	r3, r6, r8
  40a9fc:	fb08 6613 	mls	r6, r8, r3, r6
  40aa00:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
  40aa04:	fb0c fc03 	mul.w	ip, ip, r3
  40aa08:	45a4      	cmp	ip, r4
  40aa0a:	d907      	bls.n	40aa1c <__udivmoddi4+0x15c>
  40aa0c:	19e4      	adds	r4, r4, r7
  40aa0e:	f103 32ff 	add.w	r2, r3, #4294967295
  40aa12:	d202      	bcs.n	40aa1a <__udivmoddi4+0x15a>
  40aa14:	45a4      	cmp	ip, r4
  40aa16:	f200 80b5 	bhi.w	40ab84 <__udivmoddi4+0x2c4>
  40aa1a:	4613      	mov	r3, r2
  40aa1c:	ebcc 0404 	rsb	r4, ip, r4
  40aa20:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
  40aa24:	e79c      	b.n	40a960 <__udivmoddi4+0xa0>
  40aa26:	4629      	mov	r1, r5
  40aa28:	4628      	mov	r0, r5
  40aa2a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40aa2e:	f1ce 0120 	rsb	r1, lr, #32
  40aa32:	fa06 f30e 	lsl.w	r3, r6, lr
  40aa36:	fa07 f70e 	lsl.w	r7, r7, lr
  40aa3a:	fa20 f901 	lsr.w	r9, r0, r1
  40aa3e:	ea4f 4817 	mov.w	r8, r7, lsr #16
  40aa42:	40ce      	lsrs	r6, r1
  40aa44:	ea49 0903 	orr.w	r9, r9, r3
  40aa48:	fbb6 faf8 	udiv	sl, r6, r8
  40aa4c:	ea4f 4419 	mov.w	r4, r9, lsr #16
  40aa50:	fb08 661a 	mls	r6, r8, sl, r6
  40aa54:	fa1f fc87 	uxth.w	ip, r7
  40aa58:	ea44 4306 	orr.w	r3, r4, r6, lsl #16
  40aa5c:	fb0a f20c 	mul.w	r2, sl, ip
  40aa60:	429a      	cmp	r2, r3
  40aa62:	fa00 f40e 	lsl.w	r4, r0, lr
  40aa66:	d90a      	bls.n	40aa7e <__udivmoddi4+0x1be>
  40aa68:	19db      	adds	r3, r3, r7
  40aa6a:	f10a 31ff 	add.w	r1, sl, #4294967295
  40aa6e:	f080 8087 	bcs.w	40ab80 <__udivmoddi4+0x2c0>
  40aa72:	429a      	cmp	r2, r3
  40aa74:	f240 8084 	bls.w	40ab80 <__udivmoddi4+0x2c0>
  40aa78:	f1aa 0a02 	sub.w	sl, sl, #2
  40aa7c:	443b      	add	r3, r7
  40aa7e:	1a9b      	subs	r3, r3, r2
  40aa80:	fa1f f989 	uxth.w	r9, r9
  40aa84:	fbb3 f1f8 	udiv	r1, r3, r8
  40aa88:	fb08 3311 	mls	r3, r8, r1, r3
  40aa8c:	ea49 4303 	orr.w	r3, r9, r3, lsl #16
  40aa90:	fb01 f60c 	mul.w	r6, r1, ip
  40aa94:	429e      	cmp	r6, r3
  40aa96:	d907      	bls.n	40aaa8 <__udivmoddi4+0x1e8>
  40aa98:	19db      	adds	r3, r3, r7
  40aa9a:	f101 32ff 	add.w	r2, r1, #4294967295
  40aa9e:	d26b      	bcs.n	40ab78 <__udivmoddi4+0x2b8>
  40aaa0:	429e      	cmp	r6, r3
  40aaa2:	d969      	bls.n	40ab78 <__udivmoddi4+0x2b8>
  40aaa4:	3902      	subs	r1, #2
  40aaa6:	443b      	add	r3, r7
  40aaa8:	1b9b      	subs	r3, r3, r6
  40aaaa:	ea41 410a 	orr.w	r1, r1, sl, lsl #16
  40aaae:	e78e      	b.n	40a9ce <__udivmoddi4+0x10e>
  40aab0:	f1c1 0e20 	rsb	lr, r1, #32
  40aab4:	fa22 f40e 	lsr.w	r4, r2, lr
  40aab8:	408b      	lsls	r3, r1
  40aaba:	4323      	orrs	r3, r4
  40aabc:	fa20 f70e 	lsr.w	r7, r0, lr
  40aac0:	fa06 f401 	lsl.w	r4, r6, r1
  40aac4:	ea4f 4c13 	mov.w	ip, r3, lsr #16
  40aac8:	fa26 f60e 	lsr.w	r6, r6, lr
  40aacc:	433c      	orrs	r4, r7
  40aace:	fbb6 f9fc 	udiv	r9, r6, ip
  40aad2:	0c27      	lsrs	r7, r4, #16
  40aad4:	fb0c 6619 	mls	r6, ip, r9, r6
  40aad8:	fa1f f883 	uxth.w	r8, r3
  40aadc:	ea47 4606 	orr.w	r6, r7, r6, lsl #16
  40aae0:	fb09 f708 	mul.w	r7, r9, r8
  40aae4:	42b7      	cmp	r7, r6
  40aae6:	fa02 f201 	lsl.w	r2, r2, r1
  40aaea:	fa00 fa01 	lsl.w	sl, r0, r1
  40aaee:	d908      	bls.n	40ab02 <__udivmoddi4+0x242>
  40aaf0:	18f6      	adds	r6, r6, r3
  40aaf2:	f109 30ff 	add.w	r0, r9, #4294967295
  40aaf6:	d241      	bcs.n	40ab7c <__udivmoddi4+0x2bc>
  40aaf8:	42b7      	cmp	r7, r6
  40aafa:	d93f      	bls.n	40ab7c <__udivmoddi4+0x2bc>
  40aafc:	f1a9 0902 	sub.w	r9, r9, #2
  40ab00:	441e      	add	r6, r3
  40ab02:	1bf6      	subs	r6, r6, r7
  40ab04:	b2a0      	uxth	r0, r4
  40ab06:	fbb6 f4fc 	udiv	r4, r6, ip
  40ab0a:	fb0c 6614 	mls	r6, ip, r4, r6
  40ab0e:	ea40 4706 	orr.w	r7, r0, r6, lsl #16
  40ab12:	fb04 f808 	mul.w	r8, r4, r8
  40ab16:	45b8      	cmp	r8, r7
  40ab18:	d907      	bls.n	40ab2a <__udivmoddi4+0x26a>
  40ab1a:	18ff      	adds	r7, r7, r3
  40ab1c:	f104 30ff 	add.w	r0, r4, #4294967295
  40ab20:	d228      	bcs.n	40ab74 <__udivmoddi4+0x2b4>
  40ab22:	45b8      	cmp	r8, r7
  40ab24:	d926      	bls.n	40ab74 <__udivmoddi4+0x2b4>
  40ab26:	3c02      	subs	r4, #2
  40ab28:	441f      	add	r7, r3
  40ab2a:	ea44 4009 	orr.w	r0, r4, r9, lsl #16
  40ab2e:	ebc8 0707 	rsb	r7, r8, r7
  40ab32:	fba0 8902 	umull	r8, r9, r0, r2
  40ab36:	454f      	cmp	r7, r9
  40ab38:	4644      	mov	r4, r8
  40ab3a:	464e      	mov	r6, r9
  40ab3c:	d314      	bcc.n	40ab68 <__udivmoddi4+0x2a8>
  40ab3e:	d029      	beq.n	40ab94 <__udivmoddi4+0x2d4>
  40ab40:	b365      	cbz	r5, 40ab9c <__udivmoddi4+0x2dc>
  40ab42:	ebba 0304 	subs.w	r3, sl, r4
  40ab46:	eb67 0706 	sbc.w	r7, r7, r6
  40ab4a:	fa07 fe0e 	lsl.w	lr, r7, lr
  40ab4e:	40cb      	lsrs	r3, r1
  40ab50:	40cf      	lsrs	r7, r1
  40ab52:	ea4e 0303 	orr.w	r3, lr, r3
  40ab56:	e885 0088 	stmia.w	r5, {r3, r7}
  40ab5a:	2100      	movs	r1, #0
  40ab5c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40ab60:	4613      	mov	r3, r2
  40ab62:	e6f8      	b.n	40a956 <__udivmoddi4+0x96>
  40ab64:	4610      	mov	r0, r2
  40ab66:	e6e0      	b.n	40a92a <__udivmoddi4+0x6a>
  40ab68:	ebb8 0402 	subs.w	r4, r8, r2
  40ab6c:	eb69 0603 	sbc.w	r6, r9, r3
  40ab70:	3801      	subs	r0, #1
  40ab72:	e7e5      	b.n	40ab40 <__udivmoddi4+0x280>
  40ab74:	4604      	mov	r4, r0
  40ab76:	e7d8      	b.n	40ab2a <__udivmoddi4+0x26a>
  40ab78:	4611      	mov	r1, r2
  40ab7a:	e795      	b.n	40aaa8 <__udivmoddi4+0x1e8>
  40ab7c:	4681      	mov	r9, r0
  40ab7e:	e7c0      	b.n	40ab02 <__udivmoddi4+0x242>
  40ab80:	468a      	mov	sl, r1
  40ab82:	e77c      	b.n	40aa7e <__udivmoddi4+0x1be>
  40ab84:	3b02      	subs	r3, #2
  40ab86:	443c      	add	r4, r7
  40ab88:	e748      	b.n	40aa1c <__udivmoddi4+0x15c>
  40ab8a:	4608      	mov	r0, r1
  40ab8c:	e70a      	b.n	40a9a4 <__udivmoddi4+0xe4>
  40ab8e:	3802      	subs	r0, #2
  40ab90:	443e      	add	r6, r7
  40ab92:	e72f      	b.n	40a9f4 <__udivmoddi4+0x134>
  40ab94:	45c2      	cmp	sl, r8
  40ab96:	d3e7      	bcc.n	40ab68 <__udivmoddi4+0x2a8>
  40ab98:	463e      	mov	r6, r7
  40ab9a:	e7d1      	b.n	40ab40 <__udivmoddi4+0x280>
  40ab9c:	4629      	mov	r1, r5
  40ab9e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40aba2:	bf00      	nop

0040aba4 <__aeabi_idiv0>:
  40aba4:	4770      	bx	lr
  40aba6:	bf00      	nop
  40aba8:	454c4449 	.word	0x454c4449
  40abac:	00000000 	.word	0x00000000
  40abb0:	09632509 	.word	0x09632509
  40abb4:	25097525 	.word	0x25097525
  40abb8:	75250975 	.word	0x75250975
  40abbc:	00000a0d 	.word	0x00000a0d
  40abc0:	20726d54 	.word	0x20726d54
  40abc4:	00637653 	.word	0x00637653
  40abc8:	51726d54 	.word	0x51726d54
  40abcc:	00000000 	.word	0x00000000
  40abd0:	00007852 	.word	0x00007852
  40abd4:	00005854 	.word	0x00005854
  40abd8:	00000010 	.word	0x00000010
  40abdc:	400e1000 	.word	0x400e1000
  40abe0:	0000030b 	.word	0x0000030b
  40abe4:	00200000 	.word	0x00200000
  40abe8:	400e0e00 	.word	0x400e0e00
  40abec:	0000000a 	.word	0x0000000a
  40abf0:	58323025 	.word	0x58323025
  40abf4:	00000020 	.word	0x00000020
  40abf8:	00000d0a 	.word	0x00000d0a
  40abfc:	30257830 	.word	0x30257830
  40ac00:	203a5838 	.word	0x203a5838
  40ac04:	00000000 	.word	0x00000000
  40ac08:	58323025 	.word	0x58323025
  40ac0c:	58323025 	.word	0x58323025
  40ac10:	58323025 	.word	0x58323025
  40ac14:	58323025 	.word	0x58323025
  40ac18:	00000020 	.word	0x00000020
  40ac1c:	58323025 	.word	0x58323025
  40ac20:	00000000 	.word	0x00000000
  40ac24:	00002020 	.word	0x00002020
  40ac28:	72570d0a 	.word	0x72570d0a
  40ac2c:	20657469 	.word	0x20657469
  40ac30:	756e2061 	.word	0x756e2061
  40ac34:	7265626d 	.word	0x7265626d
  40ac38:	646e6120 	.word	0x646e6120
  40ac3c:	65727020 	.word	0x65727020
  40ac40:	45207373 	.word	0x45207373
  40ac44:	5245544e 	.word	0x5245544e
  40ac48:	20726f20 	.word	0x20726f20
  40ac4c:	43415053 	.word	0x43415053
  40ac50:	0d0a2145 	.word	0x0d0a2145
  40ac54:	00000000 	.word	0x00000000
  40ac58:	25270d0a 	.word	0x25270d0a
  40ac5c:	6e202763 	.word	0x6e202763
  40ac60:	6120746f 	.word	0x6120746f
  40ac64:	6d756e20 	.word	0x6d756e20
  40ac68:	20726562 	.word	0x20726562
  40ac6c:	7320726f 	.word	0x7320726f
  40ac70:	286e6769 	.word	0x286e6769
  40ac74:	292d2f2b 	.word	0x292d2f2b
  40ac78:	000d0a21 	.word	0x000d0a21
  40ac7c:	68540d0a 	.word	0x68540d0a
  40ac80:	756e2065 	.word	0x756e2065
  40ac84:	7265626d 	.word	0x7265626d
  40ac88:	76616820 	.word	0x76616820
  40ac8c:	6f742065 	.word	0x6f742065
  40ac90:	20656220 	.word	0x20656220
  40ac94:	77746562 	.word	0x77746562
  40ac98:	206e6565 	.word	0x206e6565
  40ac9c:	61206425 	.word	0x61206425
  40aca0:	2520646e 	.word	0x2520646e
  40aca4:	000d0a64 	.word	0x000d0a64
  40aca8:	74490d0a 	.word	0x74490d0a
  40acac:	20736920 	.word	0x20736920
  40acb0:	20746f6e 	.word	0x20746f6e
  40acb4:	65682061 	.word	0x65682061
  40acb8:	65646178 	.word	0x65646178
  40acbc:	616d6963 	.word	0x616d6963
  40acc0:	6863206c 	.word	0x6863206c
  40acc4:	63617261 	.word	0x63617261
  40acc8:	21726574 	.word	0x21726574
  40accc:	00000d0a 	.word	0x00000d0a

0040acd0 <pinsLeds>:
  40acd0:	00800000 400e0e00 0000050a 00000200     .......@........
  40ace0:	400e1200 0000050c                       ...@....

0040ace8 <numLeds>:
  40ace8:	00000002 74697845 20676e69 68746977     ....Exiting with
  40acf8:	61747320 20737574 0a2e6425 00000000      status %d......
  40ad08:	64497764 36203c20 00000033 6c2f2e2e     dwId < 63...../l
  40ad18:	68636269 735f7069 37766d61 756f732f     ibchip_samv7/sou
  40ad28:	2f656372 2e636d70 00000063 64497764     rce/pmc.c...dwId
  40ad38:	49203c20 45505f44 48504952 554f435f      < ID_PERIPH_COU
  40ad48:	0000544e                                NT..

0040ad4c <__func__.10750>:
  40ad4c:	5f434d50 62616e45 6550656c 68706972     PMC_EnablePeriph
  40ad5c:	6c617265 00000000                       eral....

0040ad64 <__func__.10754>:
  40ad64:	5f434d50 61736944 50656c62 70697265     PMC_DisablePerip
  40ad74:	61726568 0000006c                       heral...

0040ad7c <__func__.10776>:
  40ad7c:	5f434d50 65507349 68706972 62616e45     PMC_IsPeriphEnab
  40ad8c:	0064656c 7566202c 6974636e 203a6e6f     led., function: 
  40ad9c:	00000000 65737361 6f697472 2522206e     ....assertion "%
  40adac:	66202273 656c6961 66203a64 20656c69     s" failed: file 
  40adbc:	22732522 696c202c 2520656e 25732564     "%s", line %d%s%
  40adcc:	00000a73 00000043                       s...C...

0040add4 <_global_impure_ptr>:
  40add4:	20400010                                ..@ 

0040add8 <zeroes.6993>:
  40add8:	30303030 30303030 30303030 30303030     0000000000000000
  40ade8:	33323130 37363534 42413938 46454443     0123456789ABCDEF
  40adf8:	00000000 33323130 37363534 62613938     ....0123456789ab
  40ae08:	66656463 00000000 6c756e28 0000296c     cdef....(null)..

0040ae18 <blanks.6992>:
  40ae18:	20202020 20202020 20202020 20202020                     

0040ae28 <zeroes.7050>:
  40ae28:	30303030 30303030 30303030 30303030     0000000000000000
  40ae38:	00464e49 00666e69 004e414e 006e616e     INF.inf.NAN.nan.
  40ae48:	00000030                                0...

0040ae4c <blanks.7049>:
  40ae4c:	20202020 20202020 20202020 20202020                     
  40ae5c:	69666e49 7974696e 00000000 004e614e     Infinity....NaN.
  40ae6c:	49534f50 00000058 0000002e              POSIX.......

0040ae78 <__mprec_tens>:
  40ae78:	00000000 3ff00000 00000000 40240000     .......?......$@
  40ae88:	00000000 40590000 00000000 408f4000     ......Y@.....@.@
  40ae98:	00000000 40c38800 00000000 40f86a00     .......@.....j.@
  40aea8:	00000000 412e8480 00000000 416312d0     .......A......cA
  40aeb8:	00000000 4197d784 00000000 41cdcd65     .......A....e..A
  40aec8:	20000000 4202a05f e8000000 42374876     ... _..B....vH7B
  40aed8:	a2000000 426d1a94 e5400000 42a2309c     ......mB..@..0.B
  40aee8:	1e900000 42d6bcc4 26340000 430c6bf5     .......B..4&.k.C
  40aef8:	37e08000 4341c379 85d8a000 43763457     ...7y.AC....W4vC
  40af08:	674ec800 43abc16d 60913d00 43e158e4     ..Ngm..C.=.`.X.C
  40af18:	78b58c40 4415af1d d6e2ef50 444b1ae4     @..x...DP.....KD
  40af28:	064dd592 4480f0cf c7e14af6 44b52d02     ..M....D.J...-.D
  40af38:	79d99db4 44ea7843                       ...yCx.D

0040af40 <__mprec_bigtens>:
  40af40:	37e08000 4341c379 b5056e17 4693b8b5     ...7y.AC.n.....F
  40af50:	e93ff9f5 4d384f03 f9301d32 5a827748     ..?..O8M2.0.Hw.Z
  40af60:	7f73bf3c 75154fdd                       <.s..O.u

0040af68 <p05.5373>:
  40af68:	00000005 00000019 0000007d              ........}...

0040af74 <_init>:
  40af74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40af76:	bf00      	nop
  40af78:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40af7a:	bc08      	pop	{r3}
  40af7c:	469e      	mov	lr, r3
  40af7e:	4770      	bx	lr

0040af80 <__init_array_start>:
  40af80:	00407871 	.word	0x00407871

0040af84 <__frame_dummy_init_array_entry>:
  40af84:	00400165                                e.@.

0040af88 <_fini>:
  40af88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40af8a:	bf00      	nop
  40af8c:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40af8e:	bc08      	pop	{r3}
  40af90:	469e      	mov	lr, r3
  40af92:	4770      	bx	lr

0040af94 <__fini_array_start>:
  40af94:	00400141 	.word	0x00400141
